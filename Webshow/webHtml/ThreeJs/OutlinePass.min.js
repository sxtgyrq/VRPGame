THREE.OutlinePass = function (e, t, r, a) { this.renderScene = t, this.renderCamera = r, this.selectedObjects = void 0 !== a ? a : [], this.visibleEdgeColor = new THREE.Color(1, 1, 1), this.hiddenEdgeColor = new THREE.Color(.1, .04, .02), this.edgeGlow = 0, this.usePatternTexture = !1, this.edgeThickness = 1, this.edgeStrength = 3, this.downSampleRatio = 2, this.pulsePeriod = 0, THREE.Pass.call(this), this.resolution = void 0 !== e ? new THREE.Vector2(e.x, e.y) : new THREE.Vector2(256, 256); r = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat }, a = Math.round(this.resolution.x / this.downSampleRatio), e = Math.round(this.resolution.y / this.downSampleRatio); this.maskBufferMaterial = new THREE.MeshBasicMaterial({ color: 16777215 }), this.maskBufferMaterial.side = THREE.DoubleSide, this.renderTargetMaskBuffer = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, r), this.renderTargetMaskBuffer.texture.name = "OutlinePass.mask", this.renderTargetMaskBuffer.texture.generateMipmaps = !1, this.depthMaterial = new THREE.MeshDepthMaterial, this.depthMaterial.side = THREE.DoubleSide, this.depthMaterial.depthPacking = THREE.RGBADepthPacking, this.depthMaterial.blending = THREE.NoBlending, this.prepareMaskMaterial = this.getPrepareMaskMaterial(), this.prepareMaskMaterial.side = THREE.DoubleSide, this.prepareMaskMaterial.fragmentShader = function (e, t) { t = t.isPerspectiveCamera ? "perspective" : "orthographic"; return e.replace(/DEPTH_TO_VIEW_Z/g, t + "DepthToViewZ") }(this.prepareMaskMaterial.fragmentShader, this.renderCamera), this.renderTargetDepthBuffer = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, r), this.renderTargetDepthBuffer.texture.name = "OutlinePass.depth", this.renderTargetDepthBuffer.texture.generateMipmaps = !1, this.renderTargetMaskDownSampleBuffer = new THREE.WebGLRenderTarget(a, e, r), this.renderTargetMaskDownSampleBuffer.texture.name = "OutlinePass.depthDownSample", this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = !1, this.renderTargetBlurBuffer1 = new THREE.WebGLRenderTarget(a, e, r), this.renderTargetBlurBuffer1.texture.name = "OutlinePass.blur1", this.renderTargetBlurBuffer1.texture.generateMipmaps = !1, this.renderTargetBlurBuffer2 = new THREE.WebGLRenderTarget(Math.round(a / 2), Math.round(e / 2), r), this.renderTargetBlurBuffer2.texture.name = "OutlinePass.blur2", this.renderTargetBlurBuffer2.texture.generateMipmaps = !1, this.edgeDetectionMaterial = this.getEdgeDetectionMaterial(), this.renderTargetEdgeBuffer1 = new THREE.WebGLRenderTarget(a, e, r), this.renderTargetEdgeBuffer1.texture.name = "OutlinePass.edge1", this.renderTargetEdgeBuffer1.texture.generateMipmaps = !1, this.renderTargetEdgeBuffer2 = new THREE.WebGLRenderTarget(Math.round(a / 2), Math.round(e / 2), r), this.renderTargetEdgeBuffer2.texture.name = "OutlinePass.edge2", this.renderTargetEdgeBuffer2.texture.generateMipmaps = !1; this.separableBlurMaterial1 = this.getSeperableBlurMaterial(4), this.separableBlurMaterial1.uniforms.texSize.value = new THREE.Vector2(a, e), this.separableBlurMaterial1.uniforms.kernelRadius.value = 1, this.separableBlurMaterial2 = this.getSeperableBlurMaterial(4), this.separableBlurMaterial2.uniforms.texSize.value = new THREE.Vector2(Math.round(a / 2), Math.round(e / 2)), this.separableBlurMaterial2.uniforms.kernelRadius.value = 4, this.overlayMaterial = this.getOverlayMaterial(), void 0 === THREE.CopyShader && console.error("THREE.OutlinePass relies on THREE.CopyShader"); e = THREE.CopyShader; this.copyUniforms = THREE.UniformsUtils.clone(e.uniforms), this.copyUniforms.opacity.value = 1, this.materialCopy = new THREE.ShaderMaterial({ uniforms: this.copyUniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader, blending: THREE.NoBlending, depthTest: !1, depthWrite: !1, transparent: !0 }), this.enabled = !0, this.needsSwap = !1, this.oldClearColor = new THREE.Color, this.oldClearAlpha = 1, this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1), this.scene = new THREE.Scene, this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null), this.quad.frustumCulled = !1, this.scene.add(this.quad), this.tempPulseColor1 = new THREE.Color, this.tempPulseColor2 = new THREE.Color, this.textureMatrix = new THREE.Matrix4 }, THREE.OutlinePass.prototype = Object.assign(Object.create(THREE.Pass.prototype), { constructor: THREE.OutlinePass, dispose: function () { this.renderTargetMaskBuffer.dispose(), this.renderTargetDepthBuffer.dispose(), this.renderTargetMaskDownSampleBuffer.dispose(), this.renderTargetBlurBuffer1.dispose(), this.renderTargetBlurBuffer2.dispose(), this.renderTargetEdgeBuffer1.dispose(), this.renderTargetEdgeBuffer2.dispose() }, setSize: function (e, t) { this.renderTargetMaskBuffer.setSize(e, t); e = Math.round(e / this.downSampleRatio), t = Math.round(t / this.downSampleRatio); this.renderTargetMaskDownSampleBuffer.setSize(e, t), this.renderTargetBlurBuffer1.setSize(e, t), this.renderTargetEdgeBuffer1.setSize(e, t), this.separableBlurMaterial1.uniforms.texSize.value = new THREE.Vector2(e, t), e = Math.round(e / 2), t = Math.round(t / 2), this.renderTargetBlurBuffer2.setSize(e, t), this.renderTargetEdgeBuffer2.setSize(e, t), this.separableBlurMaterial2.uniforms.texSize.value = new THREE.Vector2(e, t) }, changeVisibilityOfSelectedObjects: function (t) { function e(e) { e.isMesh && (t ? (e.visible = e.userData.oldVisible, delete e.userData.oldVisible) : (e.userData.oldVisible = e.visible, e.visible = t)) } for (var r = 0; r < this.selectedObjects.length; r++)this.selectedObjects[r].traverse(e) }, changeVisibilityOfNonSelectedObjects: function (i) { var s = []; function e(e) { e.isMesh && s.push(e) } for (var t = 0; t < this.selectedObjects.length; t++)this.selectedObjects[t].traverse(e); this.renderScene.traverse(function (e) { if (e.isMesh || e.isLine || e.isSprite) { for (var t, r = !1, a = 0; a < s.length; a++)if (s[a].id === e.id) { r = !0; break } r || (t = e.visible, i && !e.bVisible || (e.visible = i), e.bVisible = t) } }) }, updateTextureMatrix: function () { this.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), this.textureMatrix.multiply(this.renderCamera.projectionMatrix), this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse) }, render: function (e, t, r, a, i) { var s, n; 0 < this.selectedObjects.length && (this.oldClearColor.copy(e.getClearColor()), this.oldClearAlpha = e.getClearAlpha(), s = e.autoClear, e.autoClear = !1, i && e.context.disable(e.context.STENCIL_TEST), e.setClearColor(16777215, 1), this.changeVisibilityOfSelectedObjects(!1), n = this.renderScene.background, this.renderScene.background = null, this.renderScene.overrideMaterial = this.depthMaterial, e.setRenderTarget(this.renderTargetDepthBuffer), e.clear(), e.render(this.renderScene, this.renderCamera), this.changeVisibilityOfSelectedObjects(!0), this.updateTextureMatrix(), this.changeVisibilityOfNonSelectedObjects(!1), this.renderScene.overrideMaterial = this.prepareMaskMaterial, this.prepareMaskMaterial.uniforms.cameraNearFar.value = new THREE.Vector2(this.renderCamera.near, this.renderCamera.far), this.prepareMaskMaterial.uniforms.depthTexture.value = this.renderTargetDepthBuffer.texture, this.prepareMaskMaterial.uniforms.textureMatrix.value = this.textureMatrix, e.setRenderTarget(this.renderTargetMaskBuffer), e.clear(), e.render(this.renderScene, this.renderCamera), this.renderScene.overrideMaterial = null, this.changeVisibilityOfNonSelectedObjects(!0), this.renderScene.background = n, this.quad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetMaskBuffer.texture, e.setRenderTarget(this.renderTargetMaskDownSampleBuffer), e.clear(), e.render(this.scene, this.camera), this.tempPulseColor1.copy(this.visibleEdgeColor), this.tempPulseColor2.copy(this.hiddenEdgeColor), 0 < this.pulsePeriod && (n = .625 + .75 * Math.cos(.01 * performance.now() / this.pulsePeriod) / 2, this.tempPulseColor1.multiplyScalar(n), this.tempPulseColor2.multiplyScalar(n)), this.quad.material = this.edgeDetectionMaterial, this.edgeDetectionMaterial.uniforms.maskTexture.value = this.renderTargetMaskDownSampleBuffer.texture, this.edgeDetectionMaterial.uniforms.texSize.value = new THREE.Vector2(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height), this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value = this.tempPulseColor1, this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value = this.tempPulseColor2, e.setRenderTarget(this.renderTargetEdgeBuffer1), e.clear(), e.render(this.scene, this.camera), this.quad.material = this.separableBlurMaterial1, this.separableBlurMaterial1.uniforms.colorTexture.value = this.renderTargetEdgeBuffer1.texture, this.separableBlurMaterial1.uniforms.direction.value = THREE.OutlinePass.BlurDirectionX, this.separableBlurMaterial1.uniforms.kernelRadius.value = this.edgeThickness, e.setRenderTarget(this.renderTargetBlurBuffer1), e.clear(), e.render(this.scene, this.camera), this.separableBlurMaterial1.uniforms.colorTexture.value = this.renderTargetBlurBuffer1.texture, this.separableBlurMaterial1.uniforms.direction.value = THREE.OutlinePass.BlurDirectionY, e.setRenderTarget(this.renderTargetEdgeBuffer1), e.clear(), e.render(this.scene, this.camera), this.quad.material = this.separableBlurMaterial2, this.separableBlurMaterial2.uniforms.colorTexture.value = this.renderTargetEdgeBuffer1.texture, this.separableBlurMaterial2.uniforms.direction.value = THREE.OutlinePass.BlurDirectionX, e.setRenderTarget(this.renderTargetBlurBuffer2), e.clear(), e.render(this.scene, this.camera), this.separableBlurMaterial2.uniforms.colorTexture.value = this.renderTargetBlurBuffer2.texture, this.separableBlurMaterial2.uniforms.direction.value = THREE.OutlinePass.BlurDirectionY, e.setRenderTarget(this.renderTargetEdgeBuffer2), e.clear(), e.render(this.scene, this.camera), this.quad.material = this.overlayMaterial, this.overlayMaterial.uniforms.maskTexture.value = this.renderTargetMaskBuffer.texture, this.overlayMaterial.uniforms.edgeTexture1.value = this.renderTargetEdgeBuffer1.texture, this.overlayMaterial.uniforms.edgeTexture2.value = this.renderTargetEdgeBuffer2.texture, this.overlayMaterial.uniforms.patternTexture.value = this.patternTexture, this.overlayMaterial.uniforms.edgeStrength.value = this.edgeStrength, this.overlayMaterial.uniforms.edgeGlow.value = this.edgeGlow, this.overlayMaterial.uniforms.usePatternTexture.value = this.usePatternTexture, i && e.context.enable(e.context.STENCIL_TEST), e.setRenderTarget(r), e.render(this.scene, this.camera), e.setClearColor(this.oldClearColor, this.oldClearAlpha), e.autoClear = s), this.renderToScreen && (this.quad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = r.texture, e.setRenderTarget(null), e.render(this.scene, this.camera)) }, getPrepareMaskMaterial: function () { return new THREE.ShaderMaterial({ uniforms: { depthTexture: { value: null }, cameraNearFar: { value: new THREE.Vector2(.5, .5) }, textureMatrix: { value: new THREE.Matrix4 } }, vertexShader: ["varying vec4 projTexCoord;", "varying vec4 vPosition;", "uniform mat4 textureMatrix;", "void main() {", "\tvPosition = modelViewMatrix * vec4( position, 1.0 );", "\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "\tprojTexCoord = textureMatrix * worldPosition;", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"), fragmentShader: ["#include <packing>", "varying vec4 vPosition;", "varying vec4 projTexCoord;", "uniform sampler2D depthTexture;", "uniform vec2 cameraNearFar;", "void main() {", "\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));", "\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );", "\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;", "\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);", "}"].join("\n") }) }, getEdgeDetectionMaterial: function () { return new THREE.ShaderMaterial({ uniforms: { maskTexture: { value: null }, texSize: { value: new THREE.Vector2(.5, .5) }, visibleEdgeColor: { value: new THREE.Vector3(1, 1, 1) }, hiddenEdgeColor: { value: new THREE.Vector3(1, 1, 1) } }, vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}", fragmentShader: "varying vec2 vUv;\t\t\t\tuniform sampler2D maskTexture;\t\t\t\tuniform vec2 texSize;\t\t\t\tuniform vec3 visibleEdgeColor;\t\t\t\tuniform vec3 hiddenEdgeColor;\t\t\t\t\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\t\t\t\t}" }) }, getSeperableBlurMaterial: function (e) { return new THREE.ShaderMaterial({ defines: { MAX_RADIUS: e }, uniforms: { colorTexture: { value: null }, texSize: { value: new THREE.Vector2(.5, .5) }, direction: { value: new THREE.Vector2(.5, .5) }, kernelRadius: { value: 1 } }, vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}", fragmentShader: "#include <common>\t\t\t\tvarying vec2 vUv;\t\t\t\tuniform sampler2D colorTexture;\t\t\t\tuniform vec2 texSize;\t\t\t\tuniform vec2 direction;\t\t\t\tuniform float kernelRadius;\t\t\t\t\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\t\t\t\t}\t\t\t\tvoid main() {\t\t\t\t\tvec2 invSize = 1.0 / texSize;\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\t\t\t\t\tvec2 uvOffset = delta;\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\t\t\t\t\t\tweightSum += (2.0 * w);\t\t\t\t\t\tuvOffset += delta;\t\t\t\t\t}\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\t\t\t\t}" }) }, getOverlayMaterial: function () { return new THREE.ShaderMaterial({ uniforms: { maskTexture: { value: null }, edgeTexture1: { value: null }, edgeTexture2: { value: null }, patternTexture: { value: null }, edgeStrength: { value: 1 }, edgeGlow: { value: 1 }, usePatternTexture: { value: 0 } }, vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}", fragmentShader: "varying vec2 vUv;\t\t\t\tuniform sampler2D maskTexture;\t\t\t\tuniform sampler2D edgeTexture1;\t\t\t\tuniform sampler2D edgeTexture2;\t\t\t\tuniform sampler2D patternTexture;\t\t\t\tuniform float edgeStrength;\t\t\t\tuniform float edgeGlow;\t\t\t\tuniform bool usePatternTexture;\t\t\t\t\t\t\t\tvoid main() {\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\t\t\t\t\tif(usePatternTexture)\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\t\t\t\t\tgl_FragColor = finalColor;\t\t\t\t}", blending: THREE.AdditiveBlending, depthTest: !1, depthWrite: !1, transparent: !0 }) } }), THREE.OutlinePass.BlurDirectionX = new THREE.Vector2(1, 0), THREE.OutlinePass.BlurDirectionY = new THREE.Vector2(0, 1);