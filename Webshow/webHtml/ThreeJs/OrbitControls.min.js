THREE.OrbitControls = function (e, t) { var n, o, a, i, s; this.object = e, this.domElement = void 0 !== t ? t : document, this.enabled = !0, this.target = new THREE.Vector3, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .25, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !1, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableKeys = !0, this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 }, this.mouseButtons = { LEFT: THREE.MOUSE.LEFT, MIDDLE: THREE.MOUSE.MIDDLE, RIGHT: THREE.MOUSE.RIGHT }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = function () { return h.phi }, this.getAzimuthalAngle = function () { return h.theta }, this.saveState = function () { r.target0.copy(r.target), r.position0.copy(r.object.position), r.zoom0 = r.object.zoom }, this.reset = function () { r.target.copy(r.target0), r.object.position.copy(r.position0), r.object.zoom = r.zoom0, r.object.updateProjectionMatrix(), r.dispatchEvent(c), r.update(), u = d.NONE }, this.update = (n = new THREE.Vector3, o = (new THREE.Quaternion).setFromUnitVectors(e.up, new THREE.Vector3(0, 1, 0)), a = o.clone().inverse(), i = new THREE.Vector3, s = new THREE.Quaternion, function () { var e = r.object.position; return n.copy(e).sub(r.target), n.applyQuaternion(o), h.setFromVector3(n), r.autoRotate && u === d.NONE && C(2 * Math.PI / 60 / 60 * r.autoRotateSpeed), h.theta += E.theta, h.phi += E.phi, h.theta = Math.max(r.minAzimuthAngle, Math.min(r.maxAzimuthAngle, h.theta)), h.phi = Math.max(r.minPolarAngle, Math.min(r.maxPolarAngle, h.phi)), h.makeSafe(), h.radius *= b, h.radius = Math.max(r.minDistance, Math.min(r.maxDistance, h.radius)), r.target.add(g), n.setFromSpherical(h), n.applyQuaternion(a), e.copy(r.target).add(n), r.object.lookAt(r.target), !0 === r.enableDamping ? (E.theta *= 1 - r.dampingFactor, E.phi *= 1 - r.dampingFactor, g.multiplyScalar(1 - r.dampingFactor)) : (E.set(0, 0, 0), g.set(0, 0, 0)), b = 1, !!(T || i.distanceToSquared(r.object.position) > p || 8 * (1 - s.dot(r.object.quaternion)) > p) && (r.dispatchEvent(c), i.copy(r.object.position), s.copy(r.object.quaternion), !(T = !1)) }), this.dispose = function () { r.domElement.removeEventListener("contextmenu", G, !1), r.domElement.removeEventListener("mousedown", z, !1), r.domElement.removeEventListener("wheel", Z, !1), r.domElement.removeEventListener("touchstart", X, !1), r.domElement.removeEventListener("touchend", K, !1), r.domElement.removeEventListener("touchmove", _, !1), document.removeEventListener("mousemove", Y, !1), document.removeEventListener("mouseup", F, !1), window.removeEventListener("keydown", I, !1) }; var r = this, c = { type: "change" }, l = { type: "start" }, m = { type: "end" }, d = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4, TOUCH_PAN: 5 }, u = d.NONE, p = 1e-6, h = new THREE.Spherical, E = new THREE.Spherical, b = 1, g = new THREE.Vector3, T = !1, v = new THREE.Vector2, R = new THREE.Vector2, f = new THREE.Vector2, y = new THREE.Vector2, w = new THREE.Vector2, O = new THREE.Vector2, H = new THREE.Vector2, P = new THREE.Vector2, j = new THREE.Vector2; function M() { return Math.pow(.95, r.zoomSpeed) } function C(e) { E.theta -= e } function N(e) { E.phi -= e } this.gamePad = [null, null, null, null], this.gamePadThread = [null, null, null, null]; var x, L, S, A = (x = new THREE.Vector3, function (e, t) { x.setFromMatrixColumn(t, 0), x.multiplyScalar(-e), g.add(x) }), D = (L = new THREE.Vector3, function (e, t) { !0 === r.screenSpacePanning ? L.setFromMatrixColumn(t, 1) : (L.setFromMatrixColumn(t, 0), L.crossVectors(r.object.up, L)), L.multiplyScalar(e), g.add(L) }), k = (S = new THREE.Vector3, function (e, t) { var n, o = r.domElement === document ? r.domElement.body : r.domElement; r.object.isPerspectiveCamera ? (n = r.object.position, S.copy(n).sub(r.target), n = S.length(), n *= Math.tan(r.object.fov / 2 * Math.PI / 180), A(2 * e * n / o.clientHeight, r.object.matrix), D(2 * t * n / o.clientHeight, r.object.matrix)) : r.object.isOrthographicCamera ? (A(e * (r.object.right - r.object.left) / r.object.zoom / o.clientWidth, r.object.matrix), D(t * (r.object.top - r.object.bottom) / r.object.zoom / o.clientHeight, r.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), r.enablePan = !1) }); function U(e) { r.object.isPerspectiveCamera ? b /= e : r.object.isOrthographicCamera ? (r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom * e)), r.object.updateProjectionMatrix(), T = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r.enableZoom = !1) } function V(e) { r.object.isPerspectiveCamera ? b *= e : r.object.isOrthographicCamera ? (r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom / e)), r.object.updateProjectionMatrix(), T = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r.enableZoom = !1) } function z(e) { if (!1 !== r.enabled) { if (e.preventDefault(), (r.domElement.focus ? r.domElement : window).focus(), e.button === r.mouseButtons.LEFT) if ("rotate" === objMain.panOrRotate) { if (!1 === r.enableRotate) return; t = e, v.set(t.clientX, t.clientY), u = d.ROTATE } else { if (!1 === r.enablePan) return; e = e, y.set(e.clientX, e.clientY), u = d.PAN } var t; u !== d.NONE && (document.addEventListener("mousemove", Y, !1), document.addEventListener("mouseup", F, !1), r.dispatchEvent(l)) } } function Y(e) { var t, n; if (!1 !== r.enabled) switch (e.preventDefault(), u) { case d.ROTATE: if (!1 === r.enableRotate) return; n = e, R.set(n.clientX, n.clientY), f.subVectors(R, v).multiplyScalar(r.rotateSpeed), n = r.domElement === document ? r.domElement.body : r.domElement, C(2 * Math.PI * f.x / n.clientHeight), N(2 * Math.PI * f.y / n.clientHeight), v.copy(R), r.update(); break; case d.DOLLY: if (!1 === r.enableZoom) return; t = e, P.set(t.clientX, t.clientY), j.subVectors(P, H), 0 < j.y ? U(M()) : j.y < 0 && V(M()), H.copy(P), r.update(); break; case d.PAN: if (!1 === r.enablePan) return; t = e, w.set(t.clientX, t.clientY), O.subVectors(w, y).multiplyScalar(r.panSpeed), k(O.x, O.y), y.copy(w), r.update() } } function F(e) { !1 !== r.enabled && (document.removeEventListener("mousemove", Y, !1), document.removeEventListener("mouseup", F, !1), r.dispatchEvent(m), u = d.NONE) } function Z(e) { !1 === r.enabled || !1 === r.enableZoom || u !== d.NONE && u !== d.ROTATE || (e.preventDefault(), e.stopPropagation(), r.dispatchEvent(l), (e = e).deltaY < 0 ? V(M()) : 0 < e.deltaY && U(M()), r.update(), r.dispatchEvent(m)) } function I(e) { !1 !== r.enabled && !1 !== r.enableKeys && !1 !== r.enablePan && function (e) { var t = !1; switch (e.keyCode) { case r.keys.UP: k(0, r.keyPanSpeed), t = !0; break; case r.keys.BOTTOM: k(0, -r.keyPanSpeed), t = !0; break; case r.keys.LEFT: k(r.keyPanSpeed, 0), t = !0; break; case r.keys.RIGHT: k(-r.keyPanSpeed, 0), t = !0 }t && (e.preventDefault(), r.update()) }(e) } function X(e) { if (null != window.touchEndEventSelfRegester && window.touchEndEventSelfRegester(e), !1 !== r.enabled) { switch (e.preventDefault(), e.touches.length) { case 1: if (!1 === r.enableRotate) return; if ("rotate" === objMain.panOrRotate) { if (!1 === r.enableRotate) return; o = e, v.set(o.touches[0].pageX, o.touches[0].pageY), u = d.TOUCH_ROTATE } else { if (!1 === r.enablePan) return; n = e, y.set(n.touches[0].clientX, n.touches[0].clientY), u = d.TOUCH_PAN } break; case 2: if (!1 === r.enableZoom && !1 === r.enablePan) return; o = e, r.enableZoom && (n = o.touches[0].pageX - o.touches[1].pageX, t = o.touches[0].pageY - o.touches[1].pageY, t = Math.sqrt(n * n + t * t), H.set(0, t)), r.enablePan && (t = .5 * (o.touches[0].pageX + o.touches[1].pageX), o = .5 * (o.touches[0].pageY + o.touches[1].pageY), y.set(t, o)), u = d.TOUCH_DOLLY_PAN; break; default: u = d.NONE }var t, n, o; u !== d.NONE && r.dispatchEvent(l) } } function _(e) { var t, n, o; if (!1 !== r.enabled) switch (e.preventDefault(), e.stopPropagation(), e.touches.length) { case 1: if (!1 === r.enableRotate) return; if (u !== d.TOUCH_ROTATE && u !== d.TOUCH_PAN) return; "rotate" === objMain.panOrRotate ? (o = e, R.set(o.touches[0].pageX, o.touches[0].pageY), f.subVectors(R, v).multiplyScalar(r.rotateSpeed), o = r.domElement === document ? r.domElement.body : r.domElement, C(2 * Math.PI * f.x / o.clientHeight), N(2 * Math.PI * f.y / o.clientHeight), v.copy(R)) : (n = e, w.set(n.touches[0].clientX, n.touches[0].clientY), O.subVectors(w, y).multiplyScalar(r.panSpeed), k(O.x, O.y), y.copy(w)), r.update(); break; case 2: if (!1 === r.enableZoom && !1 === r.enablePan) return; if (u !== d.TOUCH_DOLLY_PAN) return; o = e, r.enableZoom && (n = o.touches[0].pageX - o.touches[1].pageX, t = o.touches[0].pageY - o.touches[1].pageY, t = Math.sqrt(n * n + t * t), P.set(0, t), j.set(0, Math.pow(P.y / H.y, r.zoomSpeed)), U(j.y), H.copy(P)), r.enablePan && (t = .5 * (o.touches[0].pageX + o.touches[1].pageX), o = .5 * (o.touches[0].pageY + o.touches[1].pageY), w.set(t, o), O.subVectors(w, y).multiplyScalar(r.panSpeed), k(O.x, O.y), y.copy(w)), r.update(); break; default: u = d.NONE } } function K(e) { !1 !== r.enabled && (r.dispatchEvent(m), u = d.NONE) } function G(e) { !1 !== r.enabled && e.preventDefault() } r.domElement.addEventListener("contextmenu", G, !1), r.domElement.addEventListener("mousedown", z, !1), r.domElement.addEventListener("wheel", Z, !1), r.domElement.addEventListener("touchstart", X, !1), r.domElement.addEventListener("touchend", K, !1), r.domElement.addEventListener("touchmove", _, !1), window.addEventListener("gamepadconnected", function (e) { var a, i = window.c; console.log("A gamepad connected:"), console.log(e.gamepad), e.gamepad.index < 4 && (a = null, a = e.gamepad.index, r.gamePad[e.gamepad.index] = e.gamepad, r.gamePadThread[a] = setInterval(() => { var e, t, n, o; null != r.gamePad[a] && (n = (o = navigator.getGamepads()[a]).axes[0], t = o.axes[1], .05 < (e = Math.sqrt(n * n + t * t)) && (o = new i(n / e, -t / e), n = r.object, e = (t = r.target).x - n.position.x, t = t.z - n.position.z, .001 < (n = Math.sqrt(e * e + t * t)) && (n = new i(e / n, -t / n).divide(o), Math.abs(n.r) < 1 && (NaN != (o = Math.acos(n.r)) && (0 < n.i ? C(o) : C(-o))), r.update()))) }, 100)) }), window.addEventListener("keydown", I, !1), this.update() }, THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype), THREE.OrbitControls.prototype.constructor = THREE.OrbitControls, Object.defineProperties(THREE.OrbitControls.prototype, { center: { get: function () { return console.warn("THREE.OrbitControls: .center has been renamed to .target"), this.target } }, noZoom: { get: function () { return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), !this.enableZoom }, set: function (e) { console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), this.enableZoom = !e } }, noRotate: { get: function () { return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), !this.enableRotate }, set: function (e) { console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), this.enableRotate = !e } }, noPan: { get: function () { return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), !this.enablePan }, set: function (e) { console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), this.enablePan = !e } }, noKeys: { get: function () { return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), !this.enableKeys }, set: function (e) { console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), this.enableKeys = !e } }, staticMoving: { get: function () { return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), !this.enableDamping }, set: function (e) { console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), this.enableDamping = !e } }, dynamicDampingFactor: { get: function () { return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor }, set: function (e) { console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor = e } } });