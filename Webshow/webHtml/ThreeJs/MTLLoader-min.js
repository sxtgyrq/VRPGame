THREE.MTLLoader = function (a) { this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager }, THREE.MTLLoader.prototype = { constructor: THREE.MTLLoader, load: function (a, e, t, r) { var s = this, i = void 0 === this.path ? THREE.LoaderUtils.extractUrlBase(a) : this.path, o = new THREE.FileLoader(this.manager); o.setPath(this.path), o.load(a, function (a) { e(s.parse(a, i)) }, t, r) }, loadTextOnly: function (a, e, t) { t(this.parse(a, e)) }, loadTextWithMulImg: function (a, e, t) { t(this.parseWithName(a, e)) }, setPath: function (a) { return this.path = a, this }, setResourcePath: function (a) { return this.resourcePath = a, this }, setTexturePath: function (a) { return console.warn("THREE.MTLLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(a) }, setCrossOrigin: function (a) { return this.crossOrigin = a, this }, setMaterialOptions: function (a) { return this.materialOptions = a, this }, parse: function (a, e) { for (var t = a.split("\n"), r = {}, s = /\s+/, i = {}, o = 0; o < t.length; o++) { var n, p, l = (l = t[o]).trim(); 0 !== l.length && "#" !== l.charAt(0) && (n = (n = 0 <= (p = l.indexOf(" ")) ? l.substring(0, p) : l).toLowerCase(), l = (l = 0 <= p ? l.substring(p + 1) : "").trim(), "newmtl" === n ? (r = { name: l }, i[l] = r) : "ka" === n || "kd" === n || "ks" === n || "ke" === n ? (p = l.split(s, 3), r[n] = [parseFloat(p[0]), parseFloat(p[1]), parseFloat(p[2])]) : r[n] = l) } e = new THREE.MTLLoader.MaterialCreator(e, this.materialOptions); return e.setCrossOrigin(this.crossOrigin), e.setManager(this.manager), e.setMaterials(i), e }, parseWithName: function (a, e) { for (var t = a.split("\n"), r = {}, s = /\s+/, i = {}, o = 0; o < t.length; o++) { var n, p, l = (l = t[o]).trim(); 0 !== l.length && "#" !== l.charAt(0) && (n = (n = 0 <= (p = l.indexOf(" ")) ? l.substring(0, p) : l).toLowerCase(), l = (l = 0 <= p ? l.substring(p + 1) : "").trim(), "newmtl" === n ? (r = { name: l }, i[l] = r) : "ka" === n || "kd" === n || "ks" === n || "ke" === n ? (p = l.split(s, 3), r[n] = [parseFloat(p[0]), parseFloat(p[1]), parseFloat(p[2])]) : r[n] = l) } e = new THREE.MTLLoader.MaterialCreator2(e, this.materialOptions); return e.setCrossOrigin(this.crossOrigin), e.setManager(this.manager), e.setMaterials(i), e } }, THREE.MTLLoader.MaterialCreator = function (a, e) { this.imageBase64 = a, this.options = e, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.side = this.options && this.options.side ? this.options.side : THREE.FrontSide, this.wrap = this.options && this.options.wrap ? this.options.wrap : THREE.RepeatWrapping }, THREE.MTLLoader.MaterialCreator.prototype = { constructor: THREE.MTLLoader.MaterialCreator, crossOrigin: "anonymous", setCrossOrigin: function (a) { return this.crossOrigin = a, this }, setManager: function (a) { this.manager = a }, setMaterials: function (a) { this.materialsInfo = this.convert(a), this.materials = {}, this.materialsArray = [], this.nameLookup = {} }, convert: function (a) { if (!this.options) return a; var e, t = {}; for (e in a) { var r, s = a[e], i = {}; for (r in t[e] = i, s) { var o = !0, n = s[r], p = r.toLowerCase(); switch (p) { case "kd": case "ka": case "ks": this.options && this.options.normalizeRGB && (n = [n[0] / 255, n[1] / 255, n[2] / 255]), this.options && this.options.ignoreZeroRGBs && 0 === n[0] && 0 === n[1] && 0 === n[2] && (o = !1) }o && (i[p] = n) } } return t }, preload: function () { for (var a in this.materialsInfo) this.create(a) }, getIndex: function (a) { return this.nameLookup[a] }, getAsArray: function () { var a, e = 0; for (a in this.materialsInfo) this.materialsArray[e] = this.create(a), this.nameLookup[a] = e, e++; return this.materialsArray }, create: function (a) { return void 0 === this.materials[a] && this.createMaterial_(a), this.materials[a] }, createMaterial_: function (a) { var e, r = this, t = this.materialsInfo[a], s = { name: a, side: this.side }; function i(a, e) { var t; s[a] || (t = r.getTextureParams(e, s), (e = r.loadTexture(r.imageBase64)).repeat.copy(t.scale), e.offset.copy(t.offset), e.wrapS = r.wrap, e.wrapT = r.wrap, s[a] = e) } for (e in t) { var o, n = t[e]; if ("" !== n) switch (e.toLowerCase()) { case "kd": s.color = (new THREE.Color).fromArray(n); break; case "ks": s.specular = (new THREE.Color).fromArray(n); break; case "ke": s.emissive = (new THREE.Color).fromArray(n); break; case "map_kd": i("map", n); break; case "map_ks": i("specularMap", n); break; case "map_ke": i("emissiveMap", n); break; case "norm": i("normalMap", n); break; case "map_bump": case "bump": i("bumpMap", n); break; case "map_d": i("alphaMap", n), s.transparent = !0; break; case "ns": s.shininess = parseFloat(n); break; case "d": (o = parseFloat(n)) < 1 && (s.opacity = o, s.transparent = !0); break; case "tr": o = parseFloat(n), this.options && this.options.invertTrProperty && (o = 1 - o), 0 < o && (s.opacity = 1 - o, s.transparent = !0) } } return this.materials[a] = new THREE.MeshPhongMaterial(s), this.materials[a] }, getTextureParams: function (a, e) { var t = { scale: new THREE.Vector2(1, 1), offset: new THREE.Vector2(0, 0) }, r = a.split(/\s+/), a = r.indexOf("-bm"); return 0 <= a && (e.bumpScale = parseFloat(r[a + 1]), r.splice(a, 2)), 0 <= (a = r.indexOf("-s")) && (t.scale.set(parseFloat(r[a + 1]), parseFloat(r[a + 2])), r.splice(a, 4)), 0 <= (a = r.indexOf("-o")) && (t.offset.set(parseFloat(r[a + 1]), parseFloat(r[a + 2])), r.splice(a, 4)), t.url = r.join(" ").trim(), t }, loadTexture: function (a, e, t, r, s) { var i = THREE.Loader.Handlers.get(a), o = void 0 !== this.manager ? this.manager : THREE.DefaultLoadingManager; return null === i && (i = new THREE.TextureLoader(o)), i.setCrossOrigin && i.setCrossOrigin(this.crossOrigin), s = i.load(a, t, r, s), void 0 !== e && (s.mapping = e), s } }, THREE.MTLLoader.MaterialCreator2 = function (a, e) { this.imageBase64s = a, this.options = e, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.side = this.options && this.options.side ? this.options.side : THREE.FrontSide, this.wrap = this.options && this.options.wrap ? this.options.wrap : THREE.RepeatWrapping }, THREE.MTLLoader.MaterialCreator2.prototype = { constructor: THREE.MTLLoader.MaterialCreator2, crossOrigin: "anonymous", setCrossOrigin: function (a) { return this.crossOrigin = a, this }, setManager: function (a) { this.manager = a }, setMaterials: function (a) { this.materialsInfo = this.convert(a), this.materials = {}, this.materialsArray = [], this.nameLookup = {} }, convert: function (a) { if (!this.options) return a; var e, t = {}; for (e in a) { var r, s = a[e], i = {}; for (r in t[e] = i, s) { var o = !0, n = s[r], p = r.toLowerCase(); switch (p) { case "kd": case "ka": case "ks": this.options && this.options.normalizeRGB && (n = [n[0] / 255, n[1] / 255, n[2] / 255]), this.options && this.options.ignoreZeroRGBs && 0 === n[0] && 0 === n[1] && 0 === n[2] && (o = !1) }o && (i[p] = n) } } return t }, preload: function () { for (var a in this.materialsInfo) this.create(a) }, getIndex: function (a) { return this.nameLookup[a] }, getAsArray: function () { var a, e = 0; for (a in this.materialsInfo) this.materialsArray[e] = this.create(a), this.nameLookup[a] = e, e++; return this.materialsArray }, create: function (a) { return void 0 === this.materials[a] && this.createMaterial_(a), this.materials[a] }, createMaterial_: function (a) { var e, s = this, t = this.materialsInfo[a], i = { name: a, side: this.side }, r = this; function o(a, e, t) { var r; i[a] || (r = s.getTextureParams(e, i), (t = s.loadTexture(s.imageBase64s[e], void 0, t)).repeat.copy(r.scale), t.offset.copy(r.offset), t.wrapS = s.wrap, t.wrapT = s.wrap, i[a] = t) } for (e in t) { var n, p = t[e]; if ("" !== p) switch (e.toLowerCase()) { case "kd": i.color = (new THREE.Color).fromArray(p); break; case "ks": i.specular = (new THREE.Color).fromArray(p); break; case "ke": i.emissive = (new THREE.Color).fromArray(p); break; case "map_kd": o("map", p, function () { r.materials[a].needsUpdate = !0 }); break; case "map_ks": o("specularMap", p, function () { r.materials[a].needsUpdate = !0 }); break; case "map_ke": o("emissiveMap", p, function () { r.materials[a].needsUpdate = !0 }); break; case "norm": o("normalMap", p, function () { r.materials[a].needsUpdate = !0 }); break; case "map_bump": case "bump": o("bumpMap", p, function () { r.materials[a].needsUpdate = !0 }); break; case "map_d": o("alphaMap", p, function () { r.materials[a].needsUpdate = !0 }), i.transparent = !0; break; case "ns": i.shininess = parseFloat(p); break; case "d": (n = parseFloat(p)) < 1 && (i.opacity = n, i.transparent = !0); break; case "tr": n = parseFloat(p), this.options && this.options.invertTrProperty && (n = 1 - n), 0 < n && (i.opacity = 1 - n, i.transparent = !0) } } return this.materials[a] = new THREE.MeshPhongMaterial(i), this.materials[a] }, getTextureParams: function (a, e) { var t = { scale: new THREE.Vector2(1, 1), offset: new THREE.Vector2(0, 0) }, r = a.split(/\s+/), a = r.indexOf("-bm"); return 0 <= a && (e.bumpScale = parseFloat(r[a + 1]), r.splice(a, 2)), 0 <= (a = r.indexOf("-s")) && (t.scale.set(parseFloat(r[a + 1]), parseFloat(r[a + 2])), r.splice(a, 4)), 0 <= (a = r.indexOf("-o")) && (t.offset.set(parseFloat(r[a + 1]), parseFloat(r[a + 2])), r.splice(a, 4)), t.url = r.join(" ").trim(), t }, loadTexture: function (a, e, t, r, s) { var i = THREE.Loader.Handlers.get(a), o = void 0 !== this.manager ? this.manager : THREE.DefaultLoadingManager; return null === i && (i = new THREE.TextureLoader(o)), i.setCrossOrigin && i.setCrossOrigin(this.crossOrigin), s = i.load(a, t, r, s), null == t && console.log("aaa", s), void 0 !== e && (s.mapping = e), s } };