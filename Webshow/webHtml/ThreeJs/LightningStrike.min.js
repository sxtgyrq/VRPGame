THREE.LightningStrike = function (t) { THREE.BufferGeometry.call(this), this.type = "LightningStrike", t = t || {}, this.init(THREE.LightningStrike.copyParameters(t, t)), this.createMesh() }, THREE.LightningStrike.prototype = Object.create(THREE.BufferGeometry.prototype), THREE.LightningStrike.prototype.constructor = THREE.LightningStrike, THREE.LightningStrike.prototype.isLightningStrike = !0, THREE.LightningStrike.RAY_INITIALIZED = 0, THREE.LightningStrike.RAY_UNBORN = 1, THREE.LightningStrike.RAY_PROPAGATING = 2, THREE.LightningStrike.RAY_STEADY = 3, THREE.LightningStrike.RAY_VANISHING = 4, THREE.LightningStrike.RAY_EXTINGUISHED = 5, THREE.LightningStrike.COS30DEG = Math.cos(30 * Math.PI / 180), THREE.LightningStrike.SIN30DEG = Math.sin(30 * Math.PI / 180), THREE.LightningStrike.createRandomGenerator = function () { for (var i = 2053, e = [], t = 0; t < i; t++)e.push(Math.random()); var r = { currentSeed: 0, random: function () { var t = e[r.currentSeed]; return r.currentSeed = (r.currentSeed + 1) % i, t }, getSeed: function () { return r.currentSeed / i }, setSeed: function (t) { r.currentSeed = Math.floor(t * i) % i } }; return r }, THREE.LightningStrike.copyParameters = function (i, e) { function t(t) { return e === i ? t : t.clone() } return (i = i || {}).sourceOffset = void 0 !== (e = e || {}).sourceOffset ? t(e.sourceOffset) : new THREE.Vector3(0, 100, 0), i.destOffset = void 0 !== e.destOffset ? t(e.destOffset) : new THREE.Vector3(0, 0, 0), i.timeScale = void 0 !== e.timeScale ? e.timeScale : 1, i.roughness = void 0 !== e.roughness ? e.roughness : .9, i.straightness = void 0 !== e.straightness ? e.straightness : .7, i.up0 = void 0 !== e.up0 ? t(e.up0) : new THREE.Vector3(0, 0, 1), i.up1 = void 0 !== e.up1 ? t(e.up1) : new THREE.Vector3(0, 0, 1), i.radius0 = void 0 !== e.radius0 ? e.radius0 : 1, i.radius1 = void 0 !== e.radius1 ? e.radius1 : 1, i.radius0Factor = void 0 !== e.radius0Factor ? e.radius0Factor : .5, i.radius1Factor = void 0 !== e.radius1Factor ? e.radius1Factor : .2, i.minRadius = void 0 !== e.minRadius ? e.minRadius : .2, i.isEternal = void 0 !== e.isEternal ? e.isEternal : void 0 === e.birthTime || void 0 === e.deathTime, i.birthTime = e.birthTime, i.deathTime = e.deathTime, i.propagationTimeFactor = void 0 !== e.propagationTimeFactor ? e.propagationTimeFactor : .1, i.vanishingTimeFactor = void 0 !== e.vanishingTimeFactor ? e.vanishingTimeFactor : .9, i.subrayPeriod = void 0 !== e.subrayPeriod ? e.subrayPeriod : 4, i.subrayDutyCycle = void 0 !== e.subrayDutyCycle ? e.subrayDutyCycle : .6, i.maxIterations = void 0 !== e.maxIterations ? e.maxIterations : 9, i.isStatic = void 0 !== e.isStatic && e.isStatic, i.ramification = void 0 !== e.ramification ? e.ramification : 5, i.maxSubrayRecursion = void 0 !== e.maxSubrayRecursion ? e.maxSubrayRecursion : 3, i.recursionProbability = void 0 !== e.recursionProbability ? e.recursionProbability : .6, i.generateUVs = void 0 !== e.generateUVs && e.generateUVs, i.randomGenerator = e.randomGenerator, i.noiseSeed = e.noiseSeed, i.onDecideSubrayCreation = e.onDecideSubrayCreation, i.onSubrayCreation = e.onSubrayCreation, i }, THREE.LightningStrike.prototype.update = function (t) { this.isStatic || (this.rayParameters.isEternal || this.rayParameters.birthTime <= t && t <= this.rayParameters.deathTime ? (this.updateMesh(t), t < this.subrays[0].endPropagationTime ? this.state = THREE.LightningStrike.RAY_PROPAGATING : t > this.subrays[0].beginVanishingTime ? this.state = THREE.LightningStrike.RAY_VANISHING : this.state = THREE.LightningStrike.RAY_STEADY, this.visible = !0) : (this.visible = !1, t < this.rayParameters.birthTime ? this.state = THREE.LightningStrike.RAY_UNBORN : this.state = THREE.LightningStrike.RAY_EXTINGUISHED)) }, THREE.LightningStrike.prototype.init = function (t) { this.rayParameters = t, this.maxIterations = void 0 !== t.maxIterations ? Math.floor(t.maxIterations) : 9, t.maxIterations = this.maxIterations, this.isStatic = void 0 !== t.isStatic && t.isStatic, t.isStatic = this.isStatic, this.ramification = void 0 !== t.ramification ? Math.floor(t.ramification) : 5, t.ramification = this.ramification, this.maxSubrayRecursion = void 0 !== t.maxSubrayRecursion ? Math.floor(t.maxSubrayRecursion) : 3, t.maxSubrayRecursion = this.maxSubrayRecursion, this.recursionProbability = void 0 !== t.recursionProbability ? t.recursionProbability : .6, t.recursionProbability = this.recursionProbability, this.generateUVs = void 0 !== t.generateUVs && t.generateUVs, t.generateUVs = this.generateUVs, void 0 !== t.randomGenerator ? (this.randomGenerator = t.randomGenerator, this.seedGenerator = t.randomGenerator, void 0 !== t.noiseSeed && this.seedGenerator.setSeed(t.noiseSeed)) : (this.randomGenerator = THREE.LightningStrike.createRandomGenerator(), this.seedGenerator = Math), void 0 !== t.onDecideSubrayCreation ? this.onDecideSubrayCreation = t.onDecideSubrayCreation : (this.createDefaultSubrayCreationCallbacks(), void 0 !== t.onSubrayCreation && (this.onSubrayCreation = t.onSubrayCreation)), this.state = THREE.LightningStrike.RAY_INITIALIZED, this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1))), t.maxSubrays = this.maxSubrays, this.maxRaySegments = 2 * (1 << this.maxIterations), this.subrays = []; for (var i = 0; i < this.maxSubrays; i++)this.subrays.push(this.createSubray()); this.raySegments = []; for (i = 0; i < this.maxRaySegments; i++)this.raySegments.push(this.createSegment()); this.time = 0, this.timeFraction = 0, this.currentSegmentCallback = null, this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs, this.numSubrays = 0, this.currentSubray = null, this.currentSegmentIndex = 0, this.isInitialSegment = !1, this.subrayProbability = 0, this.currentVertex = 0, this.currentIndex = 0, this.currentCoordinate = 0, this.currentUVCoordinate = 0, this.vertices = null, this.uvs = null, this.indices = null, this.positionAttribute = null, this.uvsAttribute = null, this.simplexX = new SimplexNoise(this.seedGenerator), this.simplexY = new SimplexNoise(this.seedGenerator), this.simplexZ = new SimplexNoise(this.seedGenerator), this.forwards = new THREE.Vector3, this.forwardsFill = new THREE.Vector3, this.side = new THREE.Vector3, this.down = new THREE.Vector3, this.middlePos = new THREE.Vector3, this.middleLinPos = new THREE.Vector3, this.newPos = new THREE.Vector3, this.vPos = new THREE.Vector3, this.cross1 = new THREE.Vector3 }, THREE.LightningStrike.prototype.createMesh = function () { var t = 1 << this.maxIterations, i = 3 * (1 + t) * this.maxSubrays, t = 18 * t * this.maxSubrays; this.vertices = new Float32Array(3 * i), this.indices = new Uint32Array(t), this.generateUVs && (this.uvs = new Float32Array(2 * i)), this.fillMesh(0), this.setIndex(new THREE.Uint32BufferAttribute(this.indices, 1)), this.positionAttribute = new THREE.Float32BufferAttribute(this.vertices, 3), this.addAttribute("position", this.positionAttribute), this.generateUVs && (this.uvsAttribute = new THREE.Float32BufferAttribute(new Float32Array(this.uvs), 2), this.addAttribute("uv", this.uvsAttribute)), this.isStatic || (this.index.dynamic = !0, this.positionAttribute.dynamic = !0, this.generateUVs && (this.uvsAttribute.dynamic = !0)), this.vertices = this.positionAttribute.array, this.indices = this.index.array, this.generateUVs && (this.uvs = this.uvsAttribute.array) }, THREE.LightningStrike.prototype.updateMesh = function (t) { this.fillMesh(t), this.drawRange.count = this.currentIndex, this.index.needsUpdate = !0, this.positionAttribute.needsUpdate = !0, this.generateUVs && (this.uvsAttribute.needsUpdate = !0) }, THREE.LightningStrike.prototype.fillMesh = function (e) { var r = this; this.currentVertex = 0, this.currentIndex = 0, this.currentCoordinate = 0, this.currentUVCoordinate = 0, this.fractalRay(e, function (t) { var i = r.currentSubray; e < i.birthTime || (this.rayParameters.isEternal && 0 == r.currentSubray.recursion ? (r.createPrism(t), r.onDecideSubrayCreation(t, r)) : e < i.endPropagationTime ? r.timeFraction >= t.fraction0 * i.propagationTimeFactor && (r.createPrism(t), r.onDecideSubrayCreation(t, r)) : ((e < i.beginVanishingTime || r.timeFraction <= i.vanishingTimeFactor + t.fraction1 * (1 - i.vanishingTimeFactor)) && r.createPrism(t), r.onDecideSubrayCreation(t, r))) }) }, THREE.LightningStrike.prototype.addNewSubray = function (t) { return this.subrays[this.numSubrays++] }, THREE.LightningStrike.prototype.initSubray = function (t, i) { t.pos0.copy(i.sourceOffset), t.pos1.copy(i.destOffset), t.up0.copy(i.up0), t.up1.copy(i.up1), t.radius0 = i.radius0, t.radius1 = i.radius1, t.birthTime = i.birthTime, t.deathTime = i.deathTime, t.timeScale = i.timeScale, t.roughness = i.roughness, t.straightness = i.straightness, t.propagationTimeFactor = i.propagationTimeFactor, t.vanishingTimeFactor = i.vanishingTimeFactor, t.maxIterations = this.maxIterations, t.seed = void 0 !== i.noiseSeed ? i.noiseSeed : 0, t.recursion = 0 }, THREE.LightningStrike.prototype.fractalRay = function (t, i) { this.time = t, this.currentSegmentCallback = i, this.numSubrays = 0, this.initSubray(this.addNewSubray(), this.rayParameters); for (var e = 0; e < this.numSubrays; e++) { var r = this.subrays[e]; this.currentSubray = r, this.randomGenerator.setSeed(r.seed), r.endPropagationTime = THREE.Math.lerp(r.birthTime, r.deathTime, r.propagationTimeFactor), r.beginVanishingTime = THREE.Math.lerp(r.deathTime, r.birthTime, 1 - r.vanishingTimeFactor); var s = this.randomGenerator.random; r.linPos0.set(s(), s(), s()).multiplyScalar(1e3), r.linPos1.set(s(), s(), s()).multiplyScalar(1e3), this.timeFraction = (t - r.birthTime) / (r.deathTime - r.birthTime), this.currentSegmentIndex = 0, this.isInitialSegment = !0; s = this.getNewSegment(); s.iteration = 0, s.pos0.copy(r.pos0), s.pos1.copy(r.pos1), s.linPos0.copy(r.linPos0), s.linPos1.copy(r.linPos1), s.up0.copy(r.up0), s.up1.copy(r.up1), s.radius0 = r.radius0, s.radius1 = r.radius1, s.fraction0 = 0, s.fraction1 = 1, s.positionVariationFactor = 1 - r.straightness, this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, r.recursion) / (1 << r.maxIterations), this.fractalRayRecursive(s) } this.currentSegmentCallback = null, this.currentSubray = null }, THREE.LightningStrike.prototype.fractalRayRecursive = function (t) { var i, e, r, s, a; t.iteration >= this.currentSubray.maxIterations ? this.currentSegmentCallback(t) : (this.forwards.subVectors(t.pos1, t.pos0), (a = this.forwards.length()) < 1e-6 && (this.forwards.set(0, 0, .01), a = this.forwards.length()), i = .5 * (t.radius0 + t.radius1), e = .5 * (t.fraction0 + t.fraction1), s = this.time * this.currentSubray.timeScale * Math.pow(2, t.iteration), this.middlePos.lerpVectors(t.pos0, t.pos1, .5), this.middleLinPos.lerpVectors(t.linPos0, t.linPos1, .5), r = this.middleLinPos, this.newPos.set(this.simplexX.noise4d(r.x, r.y, r.z, s), this.simplexY.noise4d(r.x, r.y, r.z, s), this.simplexZ.noise4d(r.x, r.y, r.z, s)), this.newPos.multiplyScalar(t.positionVariationFactor * a), this.newPos.add(this.middlePos), (s = this.getNewSegment()).pos0.copy(t.pos0), s.pos1.copy(this.newPos), s.linPos0.copy(t.linPos0), s.linPos1.copy(this.middleLinPos), s.up0.copy(t.up0), s.up1.copy(t.up1), s.radius0 = t.radius0, s.radius1 = i, s.fraction0 = t.fraction0, s.fraction1 = e, s.positionVariationFactor = t.positionVariationFactor * this.currentSubray.roughness, s.iteration = t.iteration + 1, (a = this.getNewSegment()).pos0.copy(this.newPos), a.pos1.copy(t.pos1), a.linPos0.copy(this.middleLinPos), a.linPos1.copy(t.linPos1), this.cross1.crossVectors(t.up0, this.forwards.normalize()), a.up0.crossVectors(this.forwards, this.cross1).normalize(), a.up1.copy(t.up1), a.radius0 = i, a.radius1 = t.radius1, a.fraction0 = e, a.fraction1 = t.fraction1, a.positionVariationFactor = t.positionVariationFactor * this.currentSubray.roughness, a.iteration = t.iteration + 1, this.fractalRayRecursive(s), this.fractalRayRecursive(a)) }, THREE.LightningStrike.prototype.createPrism = function (t) { this.forwardsFill.subVectors(t.pos1, t.pos0).normalize(), this.isInitialSegment && (this.currentCreateTriangleVertices(t.pos0, t.up0, this.forwardsFill, t.radius0, 0), this.isInitialSegment = !1), this.currentCreateTriangleVertices(t.pos1, t.up0, this.forwardsFill, t.radius1, t.fraction1), this.createPrismFaces() }, THREE.LightningStrike.prototype.createTriangleVerticesWithoutUVs = function (t, i, e, r) { this.side.crossVectors(i, e).multiplyScalar(r * THREE.LightningStrike.COS30DEG), this.down.copy(i).multiplyScalar(-r * THREE.LightningStrike.SIN30DEG); var s = this.vPos, e = this.vertices; s.copy(t).sub(this.side).add(this.down), e[this.currentCoordinate++] = s.x, e[this.currentCoordinate++] = s.y, e[this.currentCoordinate++] = s.z, s.copy(t).add(this.side).add(this.down), e[this.currentCoordinate++] = s.x, e[this.currentCoordinate++] = s.y, e[this.currentCoordinate++] = s.z, s.copy(i).multiplyScalar(r).add(t), e[this.currentCoordinate++] = s.x, e[this.currentCoordinate++] = s.y, e[this.currentCoordinate++] = s.z, this.currentVertex += 3 }, THREE.LightningStrike.prototype.createTriangleVerticesWithUVs = function (t, i, e, r, s) { this.side.crossVectors(i, e).multiplyScalar(r * THREE.LightningStrike.COS30DEG), this.down.copy(i).multiplyScalar(-r * THREE.LightningStrike.SIN30DEG); var a = this.vPos, n = this.vertices, e = this.uvs; a.copy(t).sub(this.side).add(this.down), n[this.currentCoordinate++] = a.x, n[this.currentCoordinate++] = a.y, n[this.currentCoordinate++] = a.z, e[this.currentUVCoordinate++] = s, e[this.currentUVCoordinate++] = 0, a.copy(t).add(this.side).add(this.down), n[this.currentCoordinate++] = a.x, n[this.currentCoordinate++] = a.y, n[this.currentCoordinate++] = a.z, e[this.currentUVCoordinate++] = s, e[this.currentUVCoordinate++] = .5, a.copy(i).multiplyScalar(r).add(t), n[this.currentCoordinate++] = a.x, n[this.currentCoordinate++] = a.y, n[this.currentCoordinate++] = a.z, e[this.currentUVCoordinate++] = s, e[this.currentUVCoordinate++] = 1, this.currentVertex += 3 }, THREE.LightningStrike.prototype.createPrismFaces = function (t, i) { var e = this.indices, t = this.currentVertex - 6; e[this.currentIndex++] = 1 + t, e[this.currentIndex++] = 2 + t, e[this.currentIndex++] = 5 + t, e[this.currentIndex++] = 1 + t, e[this.currentIndex++] = 5 + t, e[this.currentIndex++] = 4 + t, e[this.currentIndex++] = t, e[this.currentIndex++] = 1 + t, e[this.currentIndex++] = 4 + t, e[this.currentIndex++] = t, e[this.currentIndex++] = 4 + t, e[this.currentIndex++] = 3 + t, e[this.currentIndex++] = 2 + t, e[this.currentIndex++] = t, e[this.currentIndex++] = 3 + t, e[this.currentIndex++] = 2 + t, e[this.currentIndex++] = 3 + t, e[this.currentIndex++] = 5 + t }, THREE.LightningStrike.prototype.createDefaultSubrayCreationCallbacks = function () { var u = this.randomGenerator.random; this.onDecideSubrayCreation = function (t, i) { var e = i.currentSubray, r = i.rayParameters.subrayPeriod, s = i.rayParameters.subrayDutyCycle, a = i.rayParameters.isEternal && 0 == e.recursion ? -u() * r : THREE.Math.lerp(e.birthTime, e.endPropagationTime, t.fraction0) - u() * r, n = i.time - a, o = Math.floor(n / r), h = u() * (o + 1), c = n % r <= s * r, n = i.subrayProbability, n = 0; c && (n = i.subrayProbability), e.recursion < i.maxSubrayRecursion && i.numSubrays < i.maxSubrays && u() < n && (c = i.addNewSubray(), n = i.randomGenerator.getSeed(), c.seed = h, i.randomGenerator.setSeed(h), c.recursion = e.recursion + 1, c.maxIterations = Math.max(1, e.maxIterations - 1), c.linPos0.set(u(), u(), u()).multiplyScalar(1e3), c.linPos1.set(u(), u(), u()).multiplyScalar(1e3), c.up0.copy(e.up0), c.up1.copy(e.up1), c.radius0 = t.radius0 * i.rayParameters.radius0Factor, c.radius1 = Math.min(i.rayParameters.minRadius, t.radius1 * i.rayParameters.radius1Factor), c.birthTime = a + o * r, c.deathTime = c.birthTime + r * s, i.rayParameters.isEternal || 0 != e.recursion || (c.birthTime = Math.max(c.birthTime, e.birthTime), c.deathTime = Math.min(c.deathTime, e.deathTime)), c.timeScale = 2 * e.timeScale, c.roughness = e.roughness, c.straightness = e.straightness, c.propagationTimeFactor = e.propagationTimeFactor, c.vanishingTimeFactor = e.vanishingTimeFactor, i.onSubrayCreation(t, e, c, i), i.randomGenerator.setSeed(n)) }; var n = new THREE.Vector3, o = new THREE.Vector3, h = new THREE.Vector3, c = new THREE.Vector3; this.onSubrayCreation = function (t, i, e, r) { r.subrayCylinderPosition(t, i, e, .5, .6, .2) }, this.subrayConePosition = function (t, i, e, r, s, a) { e.pos0.copy(t.pos0), n.subVectors(i.pos1, i.pos0), o.copy(n).normalize(), n.multiplyScalar(t.fraction0 + (1 - t.fraction0) * (u() * r)); t = n.length(); h.crossVectors(i.up0, o); r = 2 * Math.PI * u(); h.multiplyScalar(Math.cos(r)), c.copy(i.up0).multiplyScalar(Math.sin(r)), e.pos1.copy(h).add(c).multiplyScalar(t * s * (a + u() * (1 - a))).add(n).add(i.pos0) }, this.subrayCylinderPosition = function (t, i, e, r, s, a) { e.pos0.copy(t.pos0), n.subVectors(i.pos1, i.pos0), o.copy(n).normalize(), n.multiplyScalar(t.fraction0 + (1 - t.fraction0) * ((2 * u() - 1) * r)); t = n.length(); h.crossVectors(i.up0, o); r = 2 * Math.PI * u(); h.multiplyScalar(Math.cos(r)), c.copy(i.up0).multiplyScalar(Math.sin(r)), e.pos1.copy(h).add(c).multiplyScalar(t * s * (a + u() * (1 - a))).add(n).add(i.pos0) } }, THREE.LightningStrike.prototype.createSubray = function () { return { seed: 0, maxIterations: 0, recursion: 0, pos0: new THREE.Vector3, pos1: new THREE.Vector3, linPos0: new THREE.Vector3, linPos1: new THREE.Vector3, up0: new THREE.Vector3, up1: new THREE.Vector3, radius0: 0, radius1: 0, birthTime: 0, deathTime: 0, timeScale: 0, roughness: 0, straightness: 0, propagationTimeFactor: 0, vanishingTimeFactor: 0, endPropagationTime: 0, beginVanishingTime: 0 } }, THREE.LightningStrike.prototype.createSegment = function () { return { iteration: 0, pos0: new THREE.Vector3, pos1: new THREE.Vector3, linPos0: new THREE.Vector3, linPos1: new THREE.Vector3, up0: new THREE.Vector3, up1: new THREE.Vector3, radius0: 0, radius1: 0, fraction0: 0, fraction1: 0, positionVariationFactor: 0 } }, THREE.LightningStrike.prototype.getNewSegment = function () { return this.raySegments[this.currentSegmentIndex++] }, THREE.LightningStrike.prototype.copy = function (t) { return BufferGeometry.prototype.copy.call(this, t), this.init(THREE.LightningStrike.copyParameters({}, t.rayParameters)), this }, THREE.LightningStrike.prototype.clone = function () { return new this.constructor(THREE.LightningStrike.copyParameters({}, this.rayParameters)) };