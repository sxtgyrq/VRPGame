THREE.OBJLoader = function () { var _ = /^[og]\s*(.+)?/, D = /^mtllib /, k = /^usemtl /; function J() { var t = { objects: [], object: {}, vertices: [], normals: [], colors: [], uvs: [], materialLibraries: [], startObject: function (t, e) { if (this.object && !1 === this.object.fromDeclaration) return this.object.name = t, void (this.object.fromDeclaration = !1 !== e); var r = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0; this.object && "function" == typeof this.object._finalize && this.object._finalize(!0), this.object = { name: t || "", fromDeclaration: !1 !== e, geometry: { vertices: [], normals: [], colors: [], uvs: [] }, materials: [], smooth: !0, startMaterial: function (t, e) { var r = this._finalize(!1); r && (r.inherited || r.groupCount <= 0) && this.materials.splice(r.index, 1); r = { index: this.materials.length, name: t || "", mtllib: Array.isArray(e) && 0 < e.length ? e[e.length - 1] : "", smooth: (void 0 !== r ? r : this).smooth, groupStart: void 0 !== r ? r.groupEnd : 0, groupEnd: -1, groupCount: -1, inherited: !1, clone: function (t) { t = { index: "number" == typeof t ? t : this.index, name: this.name, mtllib: this.mtllib, smooth: this.smooth, groupStart: 0, groupEnd: -1, groupCount: -1, inherited: !1 }; return t.clone = this.clone.bind(t), t } }; return this.materials.push(r), r }, currentMaterial: function () { if (0 < this.materials.length) return this.materials[this.materials.length - 1] }, _finalize: function (t) { var e = this.currentMaterial(); if (e && -1 === e.groupEnd && (e.groupEnd = this.geometry.vertices.length / 3, e.groupCount = e.groupEnd - e.groupStart, e.inherited = !1), t && 1 < this.materials.length) for (var r = this.materials.length - 1; 0 <= r; r--)this.materials[r].groupCount <= 0 && this.materials.splice(r, 1); return t && 0 === this.materials.length && this.materials.push({ name: "", smooth: this.smooth }), e } }, r && r.name && "function" == typeof r.clone && ((r = r.clone(0)).inherited = !0, this.object.materials.push(r)), this.objects.push(this.object) }, finalize: function () { this.object && "function" == typeof this.object._finalize && this.object._finalize(!0) }, parseVertexIndex: function (t, e) { t = parseInt(t, 10); return 3 * (0 <= t ? t - 1 : t + e / 3) }, parseNormalIndex: function (t, e) { t = parseInt(t, 10); return 3 * (0 <= t ? t - 1 : t + e / 3) }, parseUVIndex: function (t, e) { t = parseInt(t, 10); return 2 * (0 <= t ? t - 1 : t + e / 2) }, addVertex: function (t, e, r) { var i = this.vertices, s = this.object.geometry.vertices; s.push(i[t + 0], i[t + 1], i[t + 2]), s.push(i[e + 0], i[e + 1], i[e + 2]), s.push(i[r + 0], i[r + 1], i[r + 2]) }, addVertexPoint: function (t) { var e = this.vertices; this.object.geometry.vertices.push(e[t + 0], e[t + 1], e[t + 2]) }, addVertexLine: function (t) { var e = this.vertices; this.object.geometry.vertices.push(e[t + 0], e[t + 1], e[t + 2]) }, addNormal: function (t, e, r) { var i = this.normals, s = this.object.geometry.normals; s.push(i[t + 0], i[t + 1], i[t + 2]), s.push(i[e + 0], i[e + 1], i[e + 2]), s.push(i[r + 0], i[r + 1], i[r + 2]) }, addColor: function (t, e, r) { var i = this.colors, s = this.object.geometry.colors; s.push(i[t + 0], i[t + 1], i[t + 2]), s.push(i[e + 0], i[e + 1], i[e + 2]), s.push(i[r + 0], i[r + 1], i[r + 2]) }, addUV: function (t, e, r) { var i = this.uvs, s = this.object.geometry.uvs; s.push(i[t + 0], i[t + 1]), s.push(i[e + 0], i[e + 1]), s.push(i[r + 0], i[r + 1]) }, addUVLine: function (t) { var e = this.uvs; this.object.geometry.uvs.push(e[t + 0], e[t + 1]) }, addFace: function (t, e, r, i, s, a, o, n, l) { var h, u = this.vertices.length, t = this.parseVertexIndex(t, u), e = this.parseVertexIndex(e, u), u = this.parseVertexIndex(r, u); this.addVertex(t, e, u), void 0 !== i && "" !== i && (h = this.uvs.length, t = this.parseUVIndex(i, h), e = this.parseUVIndex(s, h), u = this.parseUVIndex(a, h), this.addUV(t, e, u)), void 0 !== o && "" !== o && (h = this.normals.length, t = this.parseNormalIndex(o, h), e = o === n ? t : this.parseNormalIndex(n, h), u = o === l ? t : this.parseNormalIndex(l, h), this.addNormal(t, e, u)), 0 < this.colors.length && this.addColor(t, e, u) }, addPointGeometry: function (t) { this.object.geometry.type = "Points"; for (var e = this.vertices.length, r = 0, i = t.length; r < i; r++)this.addVertexPoint(this.parseVertexIndex(t[r], e)) }, addLineGeometry: function (t, e) { this.object.geometry.type = "Line"; for (var r = this.vertices.length, i = this.uvs.length, s = 0, a = t.length; s < a; s++)this.addVertexLine(this.parseVertexIndex(t[s], r)); for (var o = 0, a = e.length; o < a; o++)this.addUVLine(this.parseUVIndex(e[o], i)) } }; return t.startObject("", !1), t } function t(t) { this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager, this.materials = null } return t.prototype = { constructor: t, load: function (t, e, r, i) { var s = this, a = new THREE.FileLoader(s.manager); a.setPath(this.path), a.load(t, function (t) { e(s.parse(t)) }, r, i) }, loadTextOnly: function (t, e) { e(this.parse(t)) }, setPath: function (t) { return this.path = t, this }, setMaterials: function (t) { return this.materials = t, this }, parse: function (t) { var e = new J; -1 !== t.indexOf("\r\n") && (t = t.replace(/\r\n/g, "\n")), -1 !== t.indexOf("\\\n") && (t = t.replace(/\\\n/g, "")); for (var r, i, s = t.split("\n"), a = "", o = [], n = "function" == typeof "".trimLeft, l = 0, h = s.length; l < h; l++)if (a = s[l], a = n ? a.trimLeft() : a.trim(), i = a.length, 0 !== i && "#" !== (r = a.charAt(0))) if ("v" === r) { var u = a.split(/\s+/); switch (u[0]) { case "v": e.vertices.push(parseFloat(u[1]), parseFloat(u[2]), parseFloat(u[3])), 8 === u.length && e.colors.push(parseFloat(u[4]), parseFloat(u[5]), parseFloat(u[6])); break; case "vn": e.normals.push(parseFloat(u[1]), parseFloat(u[2]), parseFloat(u[3])); break; case "vt": e.uvs.push(parseFloat(Math.abs(u[1])), parseFloat(Math.abs(u[2]))) } } else if ("f" === r) { for (var c = a.substr(1).trim().split(/\s+/), p = [], m = 0, d = c.length; m < d; m++) { var f = c[m]; 0 < f.length && (f = f.split("/"), p.push(f)) } for (var g = p[0], m = 1, d = p.length - 1; m < d; m++) { var v = p[m], b = p[m + 1]; e.addFace(g[0], v[0], b[0], g[1], v[1], b[1], g[2], v[2], b[2]) } } else if ("l" === r) { var E = a.substring(1).trim().split(" "), x = [], j = []; if (-1 === a.indexOf("/")) x = E; else for (var y = 0, T = E.length; y < T; y++) { var H = E[y].split("/"); "" !== H[0] && x.push(H[0]), "" !== H[1] && j.push(H[1]) } e.addLineGeometry(x, j) } else if ("p" === r) { var R = a.substr(1).trim().split(" "); e.addPointGeometry(R) } else if (null !== (o = _.exec(a))) { var L = (" " + o[0].substr(1).trim()).substr(1); e.startObject(L) } else if (k.test(a)) e.object.startMaterial(a.substring(7).trim(), e.materialLibraries); else if (D.test(a)) e.materialLibraries.push(a.substring(7).trim()); else if ("s" === r) 1 < (o = a.split(" ")).length ? (L = o[1].trim().toLowerCase(), e.object.smooth = "0" !== L && "off" !== L) : e.object.smooth = !0, (S = e.object.currentMaterial()) && (S.smooth = e.object.smooth); else if ("\0" !== a) throw new Error('THREE.OBJLoader: Unexpected line: "' + a + '"'); e.finalize(); var M = new THREE.Group; M.materialLibraries = [].concat(e.materialLibraries); for (l = 0, h = e.objects.length; l < h; l++) { var V = e.objects[l], w = V.geometry, F = V.materials, I = "Line" === w.type, P = "Points" === w.type, A = !1; if (0 !== w.vertices.length) { var z = new THREE.BufferGeometry; z.addAttribute("position", new THREE.Float32BufferAttribute(w.vertices, 3)), 0 < w.normals.length ? z.addAttribute("normal", new THREE.Float32BufferAttribute(w.normals, 3)) : z.computeVertexNormals(), 0 < w.colors.length && (A = !0, z.addAttribute("color", new THREE.Float32BufferAttribute(w.colors, 3))), 0 < w.uvs.length && z.addAttribute("uv", new THREE.Float32BufferAttribute(w.uvs, 2)); for (var C, B = [], U = 0, O = F.length; U < O; U++) { var N, G = F[U], S = void 0; null !== this.materials && (S = this.materials.create(G.name), !I || !S || S instanceof THREE.LineBasicMaterial ? !P || !S || S instanceof THREE.PointsMaterial || (N = new THREE.PointsMaterial({ size: 10, sizeAttenuation: !1 }), THREE.Material.prototype.copy.call(N, S), N.color.copy(S.color), N.map = S.map, N.lights = !1, S = N) : (N = new THREE.LineBasicMaterial, THREE.Material.prototype.copy.call(N, S), N.color.copy(S.color), N.lights = !1, S = N)), S || ((S = I ? new THREE.LineBasicMaterial : P ? new THREE.PointsMaterial({ size: 1, sizeAttenuation: !1 }) : new THREE.MeshPhongMaterial).name = G.name), S.flatShading = !G.smooth, S.vertexColors = A ? THREE.VertexColors : THREE.NoColors, B.push(S) } if (1 < B.length) { for (U = 0, O = F.length; U < O; U++) { G = F[U]; z.addGroup(G.groupStart, G.groupCount, U) } C = new (I ? THREE.LineSegments : P ? THREE.Points : THREE.Mesh)(z, B) } else C = new (I ? THREE.LineSegments : P ? THREE.Points : THREE.Mesh)(z, B[0]); C.name = V.name, M.add(C) } } return M } }, t }();