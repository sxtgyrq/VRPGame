!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = t || self).THREE = {}) }(this, function (t) { "use strict"; function e() { } void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function (t) { return "number" == typeof t && isFinite(t) && Math.floor(t) === t }), void 0 === Math.sign && (Math.sign = function (t) { return t < 0 ? -1 : 0 < t ? 1 : +t }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", { get: function () { return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1] } }), void 0 === Object.assign && (Object.assign = function (t) { if (null == t) throw new TypeError("Cannot convert undefined or null to object"); for (var e = Object(t), n = 1; n < arguments.length; n++) { var i = arguments[n]; if (null != i) for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r]) } return e }), Object.assign(e.prototype, { addEventListener: function (t, e) { void 0 === this._listeners && (this._listeners = {}); var n = this._listeners; void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e) }, hasEventListener: function (t, e) { if (void 0 === this._listeners) return !1; var n = this._listeners; return void 0 !== n[t] && -1 !== n[t].indexOf(e) }, removeEventListener: function (t, e) { void 0 !== this._listeners && (void 0 === (t = this._listeners[t]) || -1 !== (e = t.indexOf(e)) && t.splice(e, 1)) }, dispatchEvent: function (t) { if (void 0 !== this._listeners) { var e = this._listeners[t.type]; if (void 0 !== e) { t.target = this; for (var n = e.slice(0), i = 0, r = n.length; i < r; i++)n[i].call(this, t) } } } }); var n, i, c, h, r, a, o, s, l, u, p, d, f, m, g, v, y, x, b, w, _, M, W = 0, q = 1, X = 2, C = 1, A = 2, O = 0, _t = 1, Y = 2, E = 0, S = 2, J = 0, Z = 1, Q = 2, K = 3, $ = 4, tt = 5, et = 100, T = 101, L = 102, R = 103, P = 104, I = 200, D = 201, N = 202, B = 203, z = 204, U = 205, G = 206, F = 207, H = 208, V = 209, k = 210, nt = 0, it = 1, rt = 2, at = 3, ot = 4, st = 5, ct = 6, ht = 7, j = 0, lt = 1, ut = 2, pt = 0, Mt = 1, dt = 2, ft = 3, mt = 4, gt = 5, vt = 301, yt = 302, xt = 303, bt = 304, wt = 305, Et = 306, St = 307, Tt = 1e3, At = 1001, Lt = 1002, Rt = 1003, Pt = 1004, Ct = 1005, Ot = 1006, It = 1007, Dt = 1008, Nt = 1009, Bt = 1010, zt = 1011, Ut = 1012, Gt = 1013, Ft = 1014, Ht = 1015, Vt = 1016, kt = 1017, jt = 1018, Wt = 1019, qt = 1020, Xt = 1021, Yt = 1022, Jt = 1023, Zt = 1024, Qt = 1025, Kt = Jt, $t = 1026, te = 1027, ee = 1028, ne = 33776, ie = 33777, re = 33778, ae = 33779, oe = 35840, se = 35841, ce = 35842, he = 35843, le = 36196, ue = 37808, pe = 37809, de = 37810, fe = 37811, me = 37812, ge = 37813, ve = 37814, ye = 37815, xe = 37816, be = 37817, we = 37818, _e = 37819, Me = 37820, Ee = 37821, Se = 2300, Te = 2301, Ae = 2400, Le = 2401, Re = 2402, Pe = 0, Ce = 3e3, Oe = 3001, Ie = 3007, De = 3002, Ne = 3004, Be = 3005, ze = 3006, Ue = 3200, Ge = 3201, Fe = 0, He = 1, Ve = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function () { for (var r = [], t = 0; t < 256; t++)r[t] = (t < 16 ? "0" : "") + t.toString(16); return function () { var t = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0; return (r[255 & t] + r[t >> 8 & 255] + r[t >> 16 & 255] + r[t >> 24 & 255] + "-" + r[255 & e] + r[e >> 8 & 255] + "-" + r[e >> 16 & 15 | 64] + r[e >> 24 & 255] + "-" + r[63 & n | 128] + r[n >> 8 & 255] + "-" + r[n >> 16 & 255] + r[n >> 24 & 255] + r[255 & i] + r[i >> 8 & 255] + r[i >> 16 & 255] + r[i >> 24 & 255]).toUpperCase() } }(), clamp: function (t, e, n) { return Math.max(e, Math.min(n, t)) }, euclideanModulo: function (t, e) { return (t % e + e) % e }, mapLinear: function (t, e, n, i, r) { return i + (t - e) * (r - i) / (n - e) }, lerp: function (t, e, n) { return (1 - n) * t + n * e }, smoothstep: function (t, e, n) { return t <= e ? 0 : n <= t ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t) }, smootherstep: function (t, e, n) { return t <= e ? 0 : n <= t ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10) }, randInt: function (t, e) { return t + Math.floor(Math.random() * (e - t + 1)) }, randFloat: function (t, e) { return t + Math.random() * (e - t) }, randFloatSpread: function (t) { return t * (.5 - Math.random()) }, degToRad: function (t) { return t * Ve.DEG2RAD }, radToDeg: function (t) { return t * Ve.RAD2DEG }, isPowerOfTwo: function (t) { return 0 == (t & t - 1) && 0 !== t }, ceilPowerOfTwo: function (t) { return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2)) }, floorPowerOfTwo: function (t) { return Math.pow(2, Math.floor(Math.log(t) / Math.LN2)) } }; function ke(t, e) { this.x = t || 0, this.y = e || 0 } function je() { this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") } function We(t, e, n, i) { this._x = t || 0, this._y = e || 0, this._z = n || 0, this._w = void 0 !== i ? i : 1 } function qe(t, e, n) { this.x = t || 0, this.y = e || 0, this.z = n || 0 } function Xe() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") } Object.defineProperties(ke.prototype, { width: { get: function () { return this.x }, set: function (t) { this.x = t } }, height: { get: function () { return this.y }, set: function (t) { this.y = t } } }), Object.assign(ke.prototype, { isVector2: !0, set: function (t, e) { return this.x = t, this.y = e, this }, setScalar: function (t) { return this.x = t, this.y = t, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setComponent: function (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; default: throw new Error("index is out of range: " + t) }return this }, getComponent: function (t) { switch (t) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + t) } }, clone: function () { return new this.constructor(this.x, this.y) }, copy: function (t) { return this.x = t.x, this.y = t.y, this }, add: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this) }, addScalar: function (t) { return this.x += t, this.y += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this }, addScaledVector: function (t, e) { return this.x += t.x * e, this.y += t.y * e, this }, sub: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this }, multiply: function (t) { return this.x *= t.x, this.y *= t.y, this }, multiplyScalar: function (t) { return this.x *= t, this.y *= t, this }, divide: function (t) { return this.x /= t.x, this.y /= t.y, this }, divideScalar: function (t) { return this.multiplyScalar(1 / t) }, applyMatrix3: function (t) { var e = this.x, n = this.y, t = t.elements; return this.x = t[0] * e + t[3] * n + t[6], this.y = t[1] * e + t[4] * n + t[7], this }, min: function (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this }, max: function (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this }, clamp: function (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this }, clampScalar: (n = new ke, i = new ke, function (t, e) { return n.set(t, t), i.set(e, e), this.clamp(n, i) }), clampLength: function (t, e) { var n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) }, floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this }, dot: function (t) { return this.x * t.x + this.y * t.y }, cross: function (t) { return this.x * t.y - this.y * t.x }, lengthSq: function () { return this.x * this.x + this.y * this.y }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) }, normalize: function () { return this.divideScalar(this.length() || 1) }, angle: function () { var t = Math.atan2(this.y, this.x); return t < 0 && (t += 2 * Math.PI), t }, distanceTo: function (t) { return Math.sqrt(this.distanceToSquared(t)) }, distanceToSquared: function (t) { var e = this.x - t.x, t = this.y - t.y; return e * e + t * t }, manhattanDistanceTo: function (t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) }, setLength: function (t) { return this.normalize().multiplyScalar(t) }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this }, lerpVectors: function (t, e, n) { return this.subVectors(e, t).multiplyScalar(n).add(t) }, equals: function (t) { return t.x === this.x && t.y === this.y }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t }, fromBufferAttribute: function (t, e, n) { return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this }, rotateAround: function (t, e) { var n = Math.cos(e), i = Math.sin(e), r = this.x - t.x, e = this.y - t.y; return this.x = r * n - e * i + t.x, this.y = r * i + e * n + t.y, this } }), Object.assign(je.prototype, { isMatrix4: !0, set: function (t, e, n, i, r, a, o, s, c, h, l, u, p, d, f, m) { var g = this.elements; return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = a, g[9] = o, g[13] = s, g[2] = c, g[6] = h, g[10] = l, g[14] = u, g[3] = p, g[7] = d, g[11] = f, g[15] = m, this }, identity: function () { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }, clone: function () { return (new je).fromArray(this.elements) }, copy: function (t) { var e = this.elements, t = t.elements; return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this }, copyPosition: function (t) { var e = this.elements, t = t.elements; return e[12] = t[12], e[13] = t[13], e[14] = t[14], this }, extractBasis: function (t, e, n) { return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this }, makeBasis: function (t, e, n) { return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this }, extractRotation: (p = new qe, function (t) { var e = this.elements, n = t.elements, i = 1 / p.setFromMatrixColumn(t, 0).length(), r = 1 / p.setFromMatrixColumn(t, 1).length(), t = 1 / p.setFromMatrixColumn(t, 2).length(); return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * t, e[9] = n[9] * t, e[10] = n[10] * t, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this }), makeRotationFromEuler: function (t) { t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."); var e, n, i, r, a, o, s, c, h, l, u, p, d = this.elements, f = t.x, m = t.y, g = t.z, v = Math.cos(f), y = Math.sin(f), x = Math.cos(m), f = Math.sin(m), m = Math.cos(g), g = Math.sin(g); return "XYZ" === t.order ? (a = v * m, o = v * g, s = y * m, c = y * g, d[0] = x * m, d[4] = -x * g, d[8] = f, d[1] = o + s * f, d[5] = a - c * f, d[9] = -y * x, d[2] = c - a * f, d[6] = s + o * f, d[10] = v * x) : "YXZ" === t.order ? (e = x * m, n = x * g, i = f * m, r = f * g, d[0] = e + r * y, d[4] = i * y - n, d[8] = v * f, d[1] = v * g, d[5] = v * m, d[9] = -y, d[2] = n * y - i, d[6] = r + e * y, d[10] = v * x) : "ZXY" === t.order ? (e = x * m, n = x * g, i = f * m, r = f * g, d[0] = e - r * y, d[4] = -v * g, d[8] = i + n * y, d[1] = n + i * y, d[5] = v * m, d[9] = r - e * y, d[2] = -v * f, d[6] = y, d[10] = v * x) : "ZYX" === t.order ? (a = v * m, o = v * g, s = y * m, c = y * g, d[0] = x * m, d[4] = s * f - o, d[8] = a * f + c, d[1] = x * g, d[5] = c * f + a, d[9] = o * f - s, d[2] = -f, d[6] = y * x, d[10] = v * x) : "YZX" === t.order ? (h = v * x, l = v * f, u = y * x, p = y * f, d[0] = x * m, d[4] = p - h * g, d[8] = u * g + l, d[1] = g, d[5] = v * m, d[9] = -y * m, d[2] = -f * m, d[6] = l * g + u, d[10] = h - p * g) : "XZY" === t.order && (h = v * x, l = v * f, u = y * x, p = y * f, d[0] = x * m, d[4] = -g, d[8] = f * m, d[1] = h * g + p, d[5] = v * m, d[9] = l * g - u, d[2] = u * g - l, d[6] = y * m, d[10] = p * g + h), d[3] = 0, d[7] = 0, d[11] = 0, d[12] = 0, d[13] = 0, d[14] = 0, d[15] = 1, this }, makeRotationFromQuaternion: (l = new qe(0, 0, 0), u = new qe(1, 1, 1), function (t) { return this.compose(l, t, u) }), lookAt: (a = new qe, o = new qe, s = new qe, function (t, e, n) { var i = this.elements; return s.subVectors(t, e), 0 === s.lengthSq() && (s.z = 1), s.normalize(), a.crossVectors(n, s), 0 === a.lengthSq() && (1 === Math.abs(n.z) ? s.x += 1e-4 : s.z += 1e-4, s.normalize(), a.crossVectors(n, s)), a.normalize(), o.crossVectors(s, a), i[0] = a.x, i[4] = o.x, i[8] = s.x, i[1] = a.y, i[5] = o.y, i[9] = s.y, i[2] = a.z, i[6] = o.z, i[10] = s.z, this }), multiply: function (t, e) { return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t) }, premultiply: function (t) { return this.multiplyMatrices(t, this) }, multiplyMatrices: function (t, e) { var n = t.elements, i = e.elements, r = this.elements, a = n[0], o = n[4], s = n[8], c = n[12], h = n[1], l = n[5], u = n[9], p = n[13], d = n[2], f = n[6], m = n[10], g = n[14], v = n[3], y = n[7], x = n[11], b = n[15], w = i[0], _ = i[4], M = i[8], E = i[12], S = i[1], T = i[5], A = i[9], L = i[13], R = i[2], P = i[6], C = i[10], O = i[14], t = i[3], e = i[7], n = i[11], i = i[15]; return r[0] = a * w + o * S + s * R + c * t, r[4] = a * _ + o * T + s * P + c * e, r[8] = a * M + o * A + s * C + c * n, r[12] = a * E + o * L + s * O + c * i, r[1] = h * w + l * S + u * R + p * t, r[5] = h * _ + l * T + u * P + p * e, r[9] = h * M + l * A + u * C + p * n, r[13] = h * E + l * L + u * O + p * i, r[2] = d * w + f * S + m * R + g * t, r[6] = d * _ + f * T + m * P + g * e, r[10] = d * M + f * A + m * C + g * n, r[14] = d * E + f * L + m * O + g * i, r[3] = v * w + y * S + x * R + b * t, r[7] = v * _ + y * T + x * P + b * e, r[11] = v * M + y * A + x * C + b * n, r[15] = v * E + y * L + x * O + b * i, this }, multiplyScalar: function (t) { var e = this.elements; return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this }, applyToBufferAttribute: (r = new qe, function (t) { for (var e = 0, n = t.count; e < n; e++)r.x = t.getX(e), r.y = t.getY(e), r.z = t.getZ(e), r.applyMatrix4(this), t.setXYZ(e, r.x, r.y, r.z); return t }), determinant: function () { var t = this.elements, e = t[0], n = t[4], i = t[8], r = t[12], a = t[1], o = t[5], s = t[9], c = t[13], h = t[2], l = t[6], u = t[10], p = t[14]; return t[3] * (+r * s * l - i * c * l - r * o * u + n * c * u + i * o * p - n * s * p) + t[7] * (+e * s * p - e * c * u + r * a * u - i * a * p + i * c * h - r * s * h) + t[11] * (+e * c * l - e * o * p - r * a * l + n * a * p + r * o * h - n * c * h) + t[15] * (-i * o * h - e * s * l + e * o * u + i * a * l - n * a * u + n * s * h) }, transpose: function () { var t = this.elements, e = t[1]; return t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this }, setPosition: function (t) { var e = this.elements; return e[12] = t.x, e[13] = t.y, e[14] = t.z, this }, getInverse: function (t, e) { var n = this.elements, i = t.elements, r = i[0], a = i[1], o = i[2], s = i[3], c = i[4], h = i[5], l = i[6], u = i[7], p = i[8], d = i[9], f = i[10], m = i[11], g = i[12], v = i[13], y = i[14], x = i[15], b = d * y * u - v * f * u + v * l * m - h * y * m - d * l * x + h * f * x, w = g * f * u - p * y * u - g * l * m + c * y * m + p * l * x - c * f * x, _ = p * v * u - g * d * u + g * h * m - c * v * m - p * h * x + c * d * x, M = g * d * l - p * v * l - g * h * f + c * v * f + p * h * y - c * d * y, t = r * b + a * w + o * _ + s * M; if (0 == t) { i = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"; if (!0 === e) throw new Error(i); return console.warn(i), this.identity() } t = 1 / t; return n[0] = b * t, n[1] = (v * f * s - d * y * s - v * o * m + a * y * m + d * o * x - a * f * x) * t, n[2] = (h * y * s - v * l * s + v * o * u - a * y * u - h * o * x + a * l * x) * t, n[3] = (d * l * s - h * f * s - d * o * u + a * f * u + h * o * m - a * l * m) * t, n[4] = w * t, n[5] = (p * y * s - g * f * s + g * o * m - r * y * m - p * o * x + r * f * x) * t, n[6] = (g * l * s - c * y * s - g * o * u + r * y * u + c * o * x - r * l * x) * t, n[7] = (c * f * s - p * l * s + p * o * u - r * f * u - c * o * m + r * l * m) * t, n[8] = _ * t, n[9] = (g * d * s - p * v * s - g * a * m + r * v * m + p * a * x - r * d * x) * t, n[10] = (c * v * s - g * h * s + g * a * u - r * v * u - c * a * x + r * h * x) * t, n[11] = (p * h * s - c * d * s - p * a * u + r * d * u + c * a * m - r * h * m) * t, n[12] = M * t, n[13] = (p * v * o - g * d * o + g * a * f - r * v * f - p * a * y + r * d * y) * t, n[14] = (g * h * o - c * v * o - g * a * l + r * v * l + c * a * y - r * h * y) * t, n[15] = (c * d * o - p * h * o + p * a * l - r * d * l - c * a * f + r * h * f) * t, this }, scale: function (t) { var e = this.elements, n = t.x, i = t.y, t = t.z; return e[0] *= n, e[4] *= i, e[8] *= t, e[1] *= n, e[5] *= i, e[9] *= t, e[2] *= n, e[6] *= i, e[10] *= t, e[3] *= n, e[7] *= i, e[11] *= t, this }, getMaxScaleOnAxis: function () { var t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], t = t[8] * t[8] + t[9] * t[9] + t[10] * t[10]; return Math.sqrt(Math.max(e, n, t)) }, makeTranslation: function (t, e, n) { return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this }, makeRotationX: function (t) { var e = Math.cos(t), t = Math.sin(t); return this.set(1, 0, 0, 0, 0, e, -t, 0, 0, t, e, 0, 0, 0, 0, 1), this }, makeRotationY: function (t) { var e = Math.cos(t), t = Math.sin(t); return this.set(e, 0, t, 0, 0, 1, 0, 0, -t, 0, e, 0, 0, 0, 0, 1), this }, makeRotationZ: function (t) { var e = Math.cos(t), t = Math.sin(t); return this.set(e, -t, 0, 0, t, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }, makeRotationAxis: function (t, e) { var n = Math.cos(e), i = Math.sin(e), r = 1 - n, a = t.x, o = t.y, s = t.z, e = r * a, t = r * o; return this.set(e * a + n, e * o - i * s, e * s + i * o, 0, e * o + i * s, t * o + n, t * s - i * a, 0, e * s - i * o, t * s + i * a, r * s * s + n, 0, 0, 0, 0, 1), this }, makeScale: function (t, e, n) { return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this }, makeShear: function (t, e, n) { return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this }, compose: function (t, e, n) { var i = this.elements, r = e._x, a = e._y, o = e._z, s = e._w, c = r + r, h = a + a, l = o + o, u = r * c, p = r * h, d = r * l, e = a * h, r = a * l, a = o * l, o = s * c, c = s * h, h = s * l, s = n.x, l = n.y, n = n.z; return i[0] = (1 - (e + a)) * s, i[1] = (p + h) * s, i[2] = (d - c) * s, i[3] = 0, i[4] = (p - h) * l, i[5] = (1 - (u + a)) * l, i[6] = (r + o) * l, i[7] = 0, i[8] = (d + c) * n, i[9] = (r - o) * n, i[10] = (1 - (u + e)) * n, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this }, decompose: (c = new qe, h = new je, function (t, e, n) { var i = this.elements, r = c.set(i[0], i[1], i[2]).length(), a = c.set(i[4], i[5], i[6]).length(), o = c.set(i[8], i[9], i[10]).length(); this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], h.copy(this); var s = 1 / r, t = 1 / a, i = 1 / o; return h.elements[0] *= s, h.elements[1] *= s, h.elements[2] *= s, h.elements[4] *= t, h.elements[5] *= t, h.elements[6] *= t, h.elements[8] *= i, h.elements[9] *= i, h.elements[10] *= i, e.setFromRotationMatrix(h), n.x = r, n.y = a, n.z = o, this }), makePerspective: function (t, e, n, i, r, a) { void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."); var o = this.elements, s = 2 * r / (e - t), c = 2 * r / (n - i), t = (e + t) / (e - t), n = (n + i) / (n - i), i = -(a + r) / (a - r), r = -2 * a * r / (a - r); return o[0] = s, o[4] = 0, o[8] = t, o[12] = 0, o[1] = 0, o[5] = c, o[9] = n, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = i, o[14] = r, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this }, makeOrthographic: function (t, e, n, i, r, a) { var o = this.elements, s = 1 / (e - t), c = 1 / (n - i), h = 1 / (a - r), t = (e + t) * s, i = (n + i) * c, r = (a + r) * h; return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -t, o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -i, o[2] = 0, o[6] = 0, o[10] = -2 * h, o[14] = -r, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this }, equals: function (t) { for (var e = this.elements, n = t.elements, i = 0; i < 16; i++)if (e[i] !== n[i]) return !1; return !0 }, fromArray: function (t, e) { void 0 === e && (e = 0); for (var n = 0; n < 16; n++)this.elements[n] = t[n + e]; return this }, toArray: function (t, e) { void 0 === t && (t = []), void 0 === e && (e = 0); var n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t } }), Object.assign(We, { slerp: function (t, e, n, i) { return n.copy(t).slerp(e, i) }, slerpFlat: function (t, e, n, i, r, a, o) { var s = n[i + 0], c = n[i + 1], h = n[i + 2], l = n[i + 3], u = r[a + 0], p = r[a + 1], d = r[a + 2], f = r[a + 3]; l === f && s === u && c === p && h === d || (n = 1 - o, r = 0 <= (i = s * u + c * p + h * d + l * f) ? 1 : -1, (a = 1 - i * i) > Number.EPSILON && (a = Math.sqrt(a), i = Math.atan2(a, i * r), n = Math.sin(n * i) / a, o = Math.sin(o * i) / a), s = s * n + u * (r = o * r), c = c * n + p * r, h = h * n + d * r, l = l * n + f * r, n === 1 - o && (s *= o = 1 / Math.sqrt(s * s + c * c + h * h + l * l), c *= o, h *= o, l *= o)), t[e] = s, t[e + 1] = c, t[e + 2] = h, t[e + 3] = l } }), Object.defineProperties(We.prototype, { x: { get: function () { return this._x }, set: function (t) { this._x = t, this.onChangeCallback() } }, y: { get: function () { return this._y }, set: function (t) { this._y = t, this.onChangeCallback() } }, z: { get: function () { return this._z }, set: function (t) { this._z = t, this.onChangeCallback() } }, w: { get: function () { return this._w }, set: function (t) { this._w = t, this.onChangeCallback() } } }), Object.assign(We.prototype, { isQuaternion: !0, set: function (t, e, n, i) { return this._x = t, this._y = e, this._z = n, this._w = i, this.onChangeCallback(), this }, clone: function () { return new this.constructor(this._x, this._y, this._z, this._w) }, copy: function (t) { return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this }, setFromEuler: function (t, e) { if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."); var n = t._x, i = t._y, r = t._z, a = t.order, o = Math.cos, s = Math.sin, c = o(n / 2), t = o(i / 2), o = o(r / 2), n = s(n / 2), i = s(i / 2), r = s(r / 2); return "XYZ" === a ? (this._x = n * t * o + c * i * r, this._y = c * i * o - n * t * r, this._z = c * t * r + n * i * o, this._w = c * t * o - n * i * r) : "YXZ" === a ? (this._x = n * t * o + c * i * r, this._y = c * i * o - n * t * r, this._z = c * t * r - n * i * o, this._w = c * t * o + n * i * r) : "ZXY" === a ? (this._x = n * t * o - c * i * r, this._y = c * i * o + n * t * r, this._z = c * t * r + n * i * o, this._w = c * t * o - n * i * r) : "ZYX" === a ? (this._x = n * t * o - c * i * r, this._y = c * i * o + n * t * r, this._z = c * t * r - n * i * o, this._w = c * t * o + n * i * r) : "YZX" === a ? (this._x = n * t * o + c * i * r, this._y = c * i * o + n * t * r, this._z = c * t * r - n * i * o, this._w = c * t * o - n * i * r) : "XZY" === a && (this._x = n * t * o - c * i * r, this._y = c * i * o - n * t * r, this._z = c * t * r + n * i * o, this._w = c * t * o + n * i * r), !1 !== e && this.onChangeCallback(), this }, setFromAxisAngle: function (t, e) { var n = e / 2, e = Math.sin(n); return this._x = t.x * e, this._y = t.y * e, this._z = t.z * e, this._w = Math.cos(n), this.onChangeCallback(), this }, setFromRotationMatrix: function (t) { var e, n = t.elements, i = n[0], r = n[4], a = n[8], o = n[1], s = n[5], c = n[9], h = n[2], l = n[6], t = n[10], n = i + s + t; return 0 < n ? (e = .5 / Math.sqrt(n + 1), this._w = .25 / e, this._x = (l - c) * e, this._y = (a - h) * e, this._z = (o - r) * e) : s < i && t < i ? (e = 2 * Math.sqrt(1 + i - s - t), this._w = (l - c) / e, this._x = .25 * e, this._y = (r + o) / e, this._z = (a + h) / e) : t < s ? (e = 2 * Math.sqrt(1 + s - i - t), this._w = (a - h) / e, this._x = (r + o) / e, this._y = .25 * e, this._z = (c + l) / e) : (e = 2 * Math.sqrt(1 + t - i - s), this._w = (o - r) / e, this._x = (a + h) / e, this._y = (c + l) / e, this._z = .25 * e), this.onChangeCallback(), this }, setFromUnitVectors: (f = new qe, function (t, e) { return void 0 === f && (f = new qe), (d = t.dot(e) + 1) < 1e-6 ? (d = 0, Math.abs(t.x) > Math.abs(t.z) ? f.set(-t.y, t.x, 0) : f.set(0, -t.z, t.y)) : f.crossVectors(t, e), this._x = f.x, this._y = f.y, this._z = f.z, this._w = d, this.normalize() }), angleTo: function (t) { return 2 * Math.acos(Math.abs(Ve.clamp(this.dot(t), -1, 1))) }, rotateTowards: function (t, e) { var n = this.angleTo(t); if (0 === n) return this; n = Math.min(1, e / n); return this.slerp(t, n), this }, inverse: function () { return this.conjugate() }, conjugate: function () { return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this }, dot: function (t) { return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w }, lengthSq: function () { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w }, length: function () { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) }, normalize: function () { var t = this.length(); return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this.onChangeCallback(), this }, multiply: function (t, e) { return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t) }, premultiply: function (t) { return this.multiplyQuaternions(t, this) }, multiplyQuaternions: function (t, e) { var n = t._x, i = t._y, r = t._z, a = t._w, o = e._x, s = e._y, t = e._z, e = e._w; return this._x = n * e + a * o + i * t - r * s, this._y = i * e + a * s + r * o - n * t, this._z = r * e + a * t + n * s - i * o, this._w = a * e - n * o - i * s - r * t, this.onChangeCallback(), this }, slerp: function (t, e) { if (0 === e) return this; if (1 === e) return this.copy(t); var n = this._x, i = this._y, r = this._z, a = this._w, o = a * t._w + n * t._x + i * t._y + r * t._z; if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), 1 <= o) return this._w = a, this._x = n, this._y = i, this._z = r, this; t = 1 - o * o; if (t <= Number.EPSILON) { var s = 1 - e; return this._w = s * a + e * this._w, this._x = s * n + e * this._x, this._y = s * i + e * this._y, this._z = s * r + e * this._z, this.normalize() } s = Math.sqrt(t), t = Math.atan2(s, o), o = Math.sin((1 - e) * t) / s, s = Math.sin(e * t) / s; return this._w = a * o + this._w * s, this._x = n * o + this._x * s, this._y = i * o + this._y * s, this._z = r * o + this._z * s, this.onChangeCallback(), this }, equals: function (t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w }, fromArray: function (t, e) { return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t }, onChange: function (t) { return this.onChangeCallback = t, this }, onChangeCallback: function () { } }), Object.assign(qe.prototype, { isVector3: !0, set: function (t, e, n) { return this.x = t, this.y = e, this.z = n, this }, setScalar: function (t) { return this.x = t, this.y = t, this.z = t, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setZ: function (t) { return this.z = t, this }, setComponent: function (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; default: throw new Error("index is out of range: " + t) }return this }, getComponent: function (t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + t) } }, clone: function () { return new this.constructor(this.x, this.y, this.z) }, copy: function (t) { return this.x = t.x, this.y = t.y, this.z = t.z, this }, add: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this) }, addScalar: function (t) { return this.x += t, this.y += t, this.z += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this }, addScaledVector: function (t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this }, sub: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this.z -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this }, multiply: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this) }, multiplyScalar: function (t) { return this.x *= t, this.y *= t, this.z *= t, this }, multiplyVectors: function (t, e) { return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this }, applyEuler: (w = new We, function (t) { return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(w.setFromEuler(t)) }), applyAxisAngle: (b = new We, function (t, e) { return this.applyQuaternion(b.setFromAxisAngle(t, e)) }), applyMatrix3: function (t) { var e = this.x, n = this.y, i = this.z, t = t.elements; return this.x = t[0] * e + t[3] * n + t[6] * i, this.y = t[1] * e + t[4] * n + t[7] * i, this.z = t[2] * e + t[5] * n + t[8] * i, this }, applyMatrix4: function (t) { var e = this.x, n = this.y, i = this.z, r = t.elements, t = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]); return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * t, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * t, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * t, this }, applyQuaternion: function (t) { var e = this.x, n = this.y, i = this.z, r = t.x, a = t.y, o = t.z, s = t.w, c = s * e + a * i - o * n, h = s * n + o * e - r * i, t = s * i + r * n - a * e, i = -r * e - a * n - o * i; return this.x = c * s + i * -r + h * -o - t * -a, this.y = h * s + i * -a + t * -r - c * -o, this.z = t * s + i * -o + c * -a - h * -r, this }, project: function (t) { return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix) }, unproject: (x = new je, function (t) { return this.applyMatrix4(x.getInverse(t.projectionMatrix)).applyMatrix4(t.matrixWorld) }), transformDirection: function (t) { var e = this.x, n = this.y, i = this.z, t = t.elements; return this.x = t[0] * e + t[4] * n + t[8] * i, this.y = t[1] * e + t[5] * n + t[9] * i, this.z = t[2] * e + t[6] * n + t[10] * i, this.normalize() }, divide: function (t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z, this }, divideScalar: function (t) { return this.multiplyScalar(1 / t) }, min: function (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this }, max: function (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this }, clamp: function (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this }, clampScalar: (v = new qe, y = new qe, function (t, e) { return v.set(t, t, t), y.set(e, e, e), this.clamp(v, y) }), clampLength: function (t, e) { var n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) }, floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this }, dot: function (t) { return this.x * t.x + this.y * t.y + this.z * t.z }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) }, normalize: function () { return this.divideScalar(this.length() || 1) }, setLength: function (t) { return this.normalize().multiplyScalar(t) }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this }, lerpVectors: function (t, e, n) { return this.subVectors(e, t).multiplyScalar(n).add(t) }, cross: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t) }, crossVectors: function (t, e) { var n = t.x, i = t.y, r = t.z, a = e.x, t = e.y, e = e.z; return this.x = i * e - r * t, this.y = r * a - n * e, this.z = n * t - i * a, this }, projectOnVector: function (t) { var e = t.dot(this) / t.lengthSq(); return this.copy(t).multiplyScalar(e) }, projectOnPlane: (g = new qe, function (t) { return g.copy(this).projectOnVector(t), this.sub(g) }), reflect: (m = new qe, function (t) { return this.sub(m.copy(t).multiplyScalar(2 * this.dot(t))) }), angleTo: function (t) { t = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq()); return Math.acos(Ve.clamp(t, -1, 1)) }, distanceTo: function (t) { return Math.sqrt(this.distanceToSquared(t)) }, distanceToSquared: function (t) { var e = this.x - t.x, n = this.y - t.y, t = this.z - t.z; return e * e + n * n + t * t }, manhattanDistanceTo: function (t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z) }, setFromSpherical: function (t) { return this.setFromSphericalCoords(t.radius, t.phi, t.theta) }, setFromSphericalCoords: function (t, e, n) { var i = Math.sin(e) * t; return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this }, setFromCylindrical: function (t) { return this.setFromCylindricalCoords(t.radius, t.theta, t.y) }, setFromCylindricalCoords: function (t, e, n) { return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this }, setFromMatrixPosition: function (t) { t = t.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this }, setFromMatrixScale: function (t) { var e = this.setFromMatrixColumn(t, 0).length(), n = this.setFromMatrixColumn(t, 1).length(), t = this.setFromMatrixColumn(t, 2).length(); return this.x = e, this.y = n, this.z = t, this }, setFromMatrixColumn: function (t, e) { return this.fromArray(t.elements, 4 * e) }, equals: function (t) { return t.x === this.x && t.y === this.y && t.z === this.z }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t }, fromBufferAttribute: function (t, e, n) { return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this } }), Object.assign(Xe.prototype, { isMatrix3: !0, set: function (t, e, n, i, r, a, o, s, c) { var h = this.elements; return h[0] = t, h[1] = i, h[2] = o, h[3] = e, h[4] = r, h[5] = s, h[6] = n, h[7] = a, h[8] = c, this }, identity: function () { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this }, clone: function () { return (new this.constructor).fromArray(this.elements) }, copy: function (t) { var e = this.elements, t = t.elements; return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], this }, setFromMatrix4: function (t) { t = t.elements; return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this }, applyToBufferAttribute: (_ = new qe, function (t) { for (var e = 0, n = t.count; e < n; e++)_.x = t.getX(e), _.y = t.getY(e), _.z = t.getZ(e), _.applyMatrix3(this), t.setXYZ(e, _.x, _.y, _.z); return t }), multiply: function (t) { return this.multiplyMatrices(this, t) }, premultiply: function (t) { return this.multiplyMatrices(t, this) }, multiplyMatrices: function (t, e) { var n = t.elements, i = e.elements, r = this.elements, a = n[0], o = n[3], s = n[6], c = n[1], h = n[4], l = n[7], u = n[2], p = n[5], d = n[8], f = i[0], m = i[3], g = i[6], v = i[1], y = i[4], t = i[7], e = i[2], n = i[5], i = i[8]; return r[0] = a * f + o * v + s * e, r[3] = a * m + o * y + s * n, r[6] = a * g + o * t + s * i, r[1] = c * f + h * v + l * e, r[4] = c * m + h * y + l * n, r[7] = c * g + h * t + l * i, r[2] = u * f + p * v + d * e, r[5] = u * m + p * y + d * n, r[8] = u * g + p * t + d * i, this }, multiplyScalar: function (t) { var e = this.elements; return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this }, determinant: function () { var t = this.elements, e = t[0], n = t[1], i = t[2], r = t[3], a = t[4], o = t[5], s = t[6], c = t[7], t = t[8]; return e * a * t - e * o * c - n * r * t + n * o * s + i * r * c - i * a * s }, getInverse: function (t, e) { t && t.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument."); var n = t.elements, i = this.elements, r = n[0], a = n[1], o = n[2], s = n[3], c = n[4], h = n[5], l = n[6], u = n[7], p = n[8], d = p * c - h * u, f = h * l - p * s, m = u * s - c * l, t = r * d + a * f + o * m; if (0 == t) { n = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"; if (!0 === e) throw new Error(n); return console.warn(n), this.identity() } t = 1 / t; return i[0] = d * t, i[1] = (o * u - p * a) * t, i[2] = (h * a - o * c) * t, i[3] = f * t, i[4] = (p * r - o * l) * t, i[5] = (o * s - h * r) * t, i[6] = m * t, i[7] = (a * l - u * r) * t, i[8] = (c * r - a * s) * t, this }, transpose: function () { var t = this.elements, e = t[1]; return t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this }, getNormalMatrix: function (t) { return this.setFromMatrix4(t).getInverse(this).transpose() }, transposeIntoArray: function (t) { var e = this.elements; return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this }, setUvTransform: function (t, e, n, i, r, a, o) { var s = Math.cos(r), r = Math.sin(r); this.set(n * s, n * r, -n * (s * a + r * o) + a + t, -i * r, i * s, -i * (-r * a + s * o) + o + e, 0, 0, 1) }, scale: function (t, e) { var n = this.elements; return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this }, rotate: function (t) { var e = Math.cos(t), n = Math.sin(t), i = this.elements, r = i[0], a = i[3], o = i[6], s = i[1], c = i[4], t = i[7]; return i[0] = e * r + n * s, i[3] = e * a + n * c, i[6] = e * o + n * t, i[1] = -n * r + e * s, i[4] = -n * a + e * c, i[7] = -n * o + e * t, this }, translate: function (t, e) { var n = this.elements; return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this }, equals: function (t) { for (var e = this.elements, n = t.elements, i = 0; i < 9; i++)if (e[i] !== n[i]) return !1; return !0 }, fromArray: function (t, e) { void 0 === e && (e = 0); for (var n = 0; n < 9; n++)this.elements[n] = t[n + e]; return this }, toArray: function (t, e) { void 0 === t && (t = []), void 0 === e && (e = 0); var n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t } }); var Ye, Je, Ze, Qe, Ke, $e, tn, en, nn, rn, an, on, sn, cn, hn, ln, un, pn, dn, fn, mn, gn, vn, yn, xn, bn, wn, _n, Mn, En, Sn = { getDataURL: function (t) { var e; return "undefined" == typeof HTMLCanvasElement ? t.src : 2048 < (t = t instanceof HTMLCanvasElement ? t : (void 0 === M && (M = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), M.width = t.width, M.height = t.height, e = M.getContext("2d"), t instanceof ImageData ? e.putImageData(t, 0, 0) : e.drawImage(t, 0, 0, t.width, t.height), M)).width || 2048 < t.height ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png") } }, Tn = 0; function An(t, e, n, i, r, a, o, s, c, h) { Object.defineProperty(this, "id", { value: Tn++ }), this.uuid = Ve.generateUUID(), this.name = "", this.image = void 0 !== t ? t : An.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : An.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : At, this.wrapT = void 0 !== i ? i : At, this.magFilter = void 0 !== r ? r : Ot, this.minFilter = void 0 !== a ? a : Dt, this.anisotropy = void 0 !== c ? c : 1, this.format = void 0 !== o ? o : Jt, this.type = void 0 !== s ? s : Nt, this.offset = new ke(0, 0), this.repeat = new ke(1, 1), this.center = new ke(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Xe, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== h ? h : Ce, this.version = 0, this.onUpdate = null } function Ln(t, e, n, i) { this.x = t || 0, this.y = e || 0, this.z = n || 0, this.w = void 0 !== i ? i : 1 } function Rn(t, e, n) { this.width = t, this.height = e, this.scissor = new Ln(0, 0, t, e), this.scissorTest = !1, this.viewport = new Ln(0, 0, t, e), n = n || {}, this.texture = new An(void 0, void 0, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : Ot, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null } function Pn(t, e, n) { Rn.call(this, t, e, n), this.samples = 4 } function Cn(t, e, n) { Rn.call(this, t, e, n) } function On(t, e, n, i, r, a, o, s, c, h, l, u) { An.call(this, null, a, o, s, c, h, i, r, l, u), this.image = { data: t, width: e, height: n }, this.magFilter = void 0 !== c ? c : Rt, this.minFilter = void 0 !== h ? h : Rt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } function In(t, e) { this.min = void 0 !== t ? t : new qe(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new qe(-1 / 0, -1 / 0, -1 / 0) } function Dn(t) { for (var e = 0, n = t.length - 3; e <= n; e += 3) { on.fromArray(t, e); var i = cn.x * Math.abs(on.x) + cn.y * Math.abs(on.y) + cn.z * Math.abs(on.z), r = $e.dot(on), a = tn.dot(on), o = en.dot(on); if (Math.max(-Math.max(r, a, o), Math.min(r, a, o)) > i) return !1 } return !0 } function Nn(t) { var e = t.geometry; if (void 0 !== e) if (e.isGeometry) { var n = e.vertices; for (pn = 0, dn = n.length; pn < dn; pn++)fn.copy(n[pn]), fn.applyMatrix4(t.matrixWorld), un.expandByPoint(fn) } else if (e.isBufferGeometry) { var i = e.attributes.position; if (void 0 !== i) for (pn = 0, dn = i.count; pn < dn; pn++)fn.fromBufferAttribute(i, pn).applyMatrix4(t.matrixWorld), un.expandByPoint(fn) } } function Bn(t, e) { this.center = void 0 !== t ? t : new qe, this.radius = void 0 !== e ? e : 0 } function zn(t, e) { this.normal = void 0 !== t ? t : new qe(1, 0, 0), this.constant = void 0 !== e ? e : 0 } function Un(t, e, n, i, r, a) { this.planes = [void 0 !== t ? t : new zn, void 0 !== e ? e : new zn, void 0 !== n ? n : new zn, void 0 !== i ? i : new zn, void 0 !== r ? r : new zn, void 0 !== a ? a : new zn] } An.DEFAULT_IMAGE = void 0, An.DEFAULT_MAPPING = 300, An.prototype = Object.assign(Object.create(e.prototype), { constructor: An, isTexture: !0, updateMatrix: function () { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this }, toJSON: function (t) { var e = void 0 === t || "string" == typeof t; if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid]; var n = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if (void 0 !== this.image) { var i, r = this.image; if (void 0 === r.uuid && (r.uuid = Ve.generateUUID()), !e && void 0 === t.images[r.uuid]) { if (Array.isArray(r)) { i = []; for (var a = 0, o = r.length; a < o; a++)i.push(Sn.getDataURL(r[a])) } else i = Sn.getDataURL(r); t.images[r.uuid] = { uuid: r.uuid, url: i } } n.image = r.uuid } return e || (t.textures[this.uuid] = n), n }, dispose: function () { this.dispatchEvent({ type: "dispose" }) }, transformUv: function (t) { if (300 !== this.mapping) return t; if (t.applyMatrix3(this.matrix), t.x < 0 || 1 < t.x) switch (this.wrapS) { case Tt: t.x = t.x - Math.floor(t.x); break; case At: t.x = t.x < 0 ? 0 : 1; break; case Lt: 1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x) }if (t.y < 0 || 1 < t.y) switch (this.wrapT) { case Tt: t.y = t.y - Math.floor(t.y); break; case At: t.y = t.y < 0 ? 0 : 1; break; case Lt: 1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y) }return this.flipY && (t.y = 1 - t.y), t } }), Object.defineProperty(An.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), Object.assign(Ln.prototype, { isVector4: !0, set: function (t, e, n, i) { return this.x = t, this.y = e, this.z = n, this.w = i, this }, setScalar: function (t) { return this.x = t, this.y = t, this.z = t, this.w = t, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setZ: function (t) { return this.z = t, this }, setW: function (t) { return this.w = t, this }, setComponent: function (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; case 3: this.w = e; break; default: throw new Error("index is out of range: " + t) }return this }, getComponent: function (t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + t) } }, clone: function () { return new this.constructor(this.x, this.y, this.z, this.w) }, copy: function (t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this }, add: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this) }, addScalar: function (t) { return this.x += t, this.y += t, this.z += t, this.w += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this }, addScaledVector: function (t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this }, sub: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this }, multiplyScalar: function (t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this }, applyMatrix4: function (t) { var e = this.x, n = this.y, i = this.z, r = this.w, t = t.elements; return this.x = t[0] * e + t[4] * n + t[8] * i + t[12] * r, this.y = t[1] * e + t[5] * n + t[9] * i + t[13] * r, this.z = t[2] * e + t[6] * n + t[10] * i + t[14] * r, this.w = t[3] * e + t[7] * n + t[11] * i + t[15] * r, this }, divideScalar: function (t) { return this.multiplyScalar(1 / t) }, setAxisAngleFromQuaternion: function (t) { this.w = 2 * Math.acos(t.w); var e = Math.sqrt(1 - t.w * t.w); return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this }, setAxisAngleFromRotationMatrix: function (t) { var e, n, i, r = t.elements, a = r[0], o = r[4], s = r[8], c = r[1], h = r[5], l = r[9], u = r[2], p = r[6], d = r[10]; if (Math.abs(o - c) < .01 && Math.abs(s - u) < .01 && Math.abs(l - p) < .01) { if (Math.abs(o + c) < .1 && Math.abs(s + u) < .1 && Math.abs(l + p) < .1 && Math.abs(a + h + d - 3) < .1) return this.set(1, 0, 0, 0), this; y = Math.PI; var f = (a + 1) / 2, m = (h + 1) / 2, g = (d + 1) / 2, v = (o + c) / 4, t = (s + u) / 4, r = (l + p) / 4; return m < f && g < f ? i = f < .01 ? (e = 0, n = .707106781) : (n = v / (e = Math.sqrt(f)), t / e) : g < m ? i = m < .01 ? (n = 0, e = .707106781) : (e = v / (n = Math.sqrt(m)), r / n) : g < .01 ? (n = e = .707106781, i = 0) : (e = t / (i = Math.sqrt(g)), n = r / i), this.set(e, n, i, y), this } var y = Math.sqrt((p - l) * (p - l) + (s - u) * (s - u) + (c - o) * (c - o)); return Math.abs(y) < .001 && (y = 1), this.x = (p - l) / y, this.y = (s - u) / y, this.z = (c - o) / y, this.w = Math.acos((a + h + d - 1) / 2), this }, min: function (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this }, max: function (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this }, clamp: function (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this }, clampScalar: function (t, e) { return void 0 === Ye && (Ye = new Ln, Je = new Ln), Ye.set(t, t, t, t), Je.set(e, e, e, e), this.clamp(Ye, Je) }, clampLength: function (t, e) { var n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) }, floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this }, dot: function (t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) }, normalize: function () { return this.divideScalar(this.length() || 1) }, setLength: function (t) { return this.normalize().multiplyScalar(t) }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this }, lerpVectors: function (t, e, n) { return this.subVectors(e, t).multiplyScalar(n).add(t) }, equals: function (t) { return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t }, fromBufferAttribute: function (t, e, n) { return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this } }), Rn.prototype = Object.assign(Object.create(e.prototype), { constructor: Rn, isWebGLRenderTarget: !0, setSize: function (t, e) { this.width === t && this.height === e || (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), Pn.prototype = Object.assign(Object.create(Rn.prototype), { constructor: Pn, isWebGLMultisampleRenderTarget: !0, copy: function (t) { return Rn.prototype.copy.call(this, t), this.samples = t.samples, this } }), ((Cn.prototype = Object.create(Rn.prototype)).constructor = Cn).prototype.isWebGLRenderTargetCube = !0, ((On.prototype = Object.create(An.prototype)).constructor = On).prototype.isDataTexture = !0, Object.assign(In.prototype, { isBox3: !0, set: function (t, e) { return this.min.copy(t), this.max.copy(e), this }, setFromArray: function (t) { for (var e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = t.length; s < c; s += 3) { var h = t[s], l = t[s + 1], u = t[s + 2]; h < e && (e = h), l < n && (n = l), u < i && (i = u), r < h && (r = h), a < l && (a = l), o < u && (o = u) } return this.min.set(e, n, i), this.max.set(r, a, o), this }, setFromBufferAttribute: function (t) { for (var e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = t.count; s < c; s++) { var h = t.getX(s), l = t.getY(s), u = t.getZ(s); h < e && (e = h), l < n && (n = l), u < i && (i = u), r < h && (r = h), a < l && (a = l), o < u && (o = u) } return this.min.set(e, n, i), this.max.set(r, a, o), this }, setFromPoints: function (t) { this.makeEmpty(); for (var e = 0, n = t.length; e < n; e++)this.expandByPoint(t[e]); return this }, setFromCenterAndSize: (mn = new qe, function (t, e) { e = mn.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(e), this.max.copy(t).add(e), this }), setFromObject: function (t) { return this.makeEmpty(), this.expandByObject(t) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.min.copy(t.min), this.max.copy(t.max), this }, makeEmpty: function () { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z }, getCenter: function (t) { return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new qe), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) }, getSize: function (t) { return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new qe), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min) }, expandByPoint: function (t) { return this.min.min(t), this.max.max(t), this }, expandByVector: function (t) { return this.min.sub(t), this.max.add(t), this }, expandByScalar: function (t) { return this.min.addScalar(-t), this.max.addScalar(t), this }, expandByObject: (fn = new qe, function (t) { return un = this, t.updateMatrixWorld(!0), t.traverse(Nn), this }), containsPoint: function (t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z) }, containsBox: function (t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z }, getParameter: function (t, e) { return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new qe), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z)) }, intersectsBox: function (t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z) }, intersectsSphere: (ln = new qe, function (t) { return this.clampPoint(t.center, ln), ln.distanceToSquared(t.center) <= t.radius * t.radius }), intersectsPlane: function (t) { var e, n = 0 < t.normal.x ? (e = t.normal.x * this.min.x, t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, t.normal.x * this.min.x); return 0 < t.normal.y ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), 0 < t.normal.z ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant }, intersectsTriangle: ($e = new qe, tn = new qe, en = new qe, nn = new qe, rn = new qe, an = new qe, on = new qe, sn = new qe, cn = new qe, hn = new qe, function (t) { if (this.isEmpty()) return !1; this.getCenter(sn), cn.subVectors(this.max, sn), $e.subVectors(t.a, sn), tn.subVectors(t.b, sn), en.subVectors(t.c, sn), nn.subVectors(tn, $e), rn.subVectors(en, tn), an.subVectors($e, en); t = [0, -nn.z, nn.y, 0, -rn.z, rn.y, 0, -an.z, an.y, nn.z, 0, -nn.x, rn.z, 0, -rn.x, an.z, 0, -an.x, -nn.y, nn.x, 0, -rn.y, rn.x, 0, -an.y, an.x, 0]; return !!Dn(t) && (!!Dn(t = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (hn.crossVectors(nn, rn), Dn(t = [hn.x, hn.y, hn.z]))) }), clampPoint: function (t, e) { return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new qe), e.copy(t).clamp(this.min, this.max) }, distanceToPoint: (Ke = new qe, function (t) { return Ke.copy(t).clamp(this.min, this.max).sub(t).length() }), getBoundingSphere: (Qe = new qe, function (t) { return void 0 === t && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"), t = new Bn), this.getCenter(t.center), t.radius = .5 * this.getSize(Qe).length(), t }), intersect: function (t) { return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this }, union: function (t) { return this.min.min(t.min), this.max.max(t.max), this }, applyMatrix4: (Ze = [new qe, new qe, new qe, new qe, new qe, new qe, new qe, new qe], function (t) { return this.isEmpty() || (Ze[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Ze[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Ze[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Ze[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Ze[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Ze[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Ze[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Ze[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Ze)), this }), translate: function (t) { return this.min.add(t), this.max.add(t), this }, equals: function (t) { return t.min.equals(this.min) && t.max.equals(this.max) } }), Object.assign(Bn.prototype, { set: function (t, e) { return this.center.copy(t), this.radius = e, this }, setFromPoints: (gn = new In, function (t, e) { var n = this.center; void 0 !== e ? n.copy(e) : gn.setFromPoints(t).getCenter(n); for (var i = 0, r = 0, a = t.length; r < a; r++)i = Math.max(i, n.distanceToSquared(t[r])); return this.radius = Math.sqrt(i), this }), clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.center.copy(t.center), this.radius = t.radius, this }, empty: function () { return this.radius <= 0 }, containsPoint: function (t) { return t.distanceToSquared(this.center) <= this.radius * this.radius }, distanceToPoint: function (t) { return t.distanceTo(this.center) - this.radius }, intersectsSphere: function (t) { var e = this.radius + t.radius; return t.center.distanceToSquared(this.center) <= e * e }, intersectsBox: function (t) { return t.intersectsSphere(this) }, intersectsPlane: function (t) { return Math.abs(t.distanceToPoint(this.center)) <= this.radius }, clampPoint: function (t, e) { var n = this.center.distanceToSquared(t); return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new qe), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e }, getBoundingBox: function (t) { return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new In), t.set(this.center, this.center), t.expandByScalar(this.radius), t }, applyMatrix4: function (t) { return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this }, translate: function (t) { return this.center.add(t), this }, equals: function (t) { return t.center.equals(this.center) && t.radius === this.radius } }), Object.assign(zn.prototype, { set: function (t, e) { return this.normal.copy(t), this.constant = e, this }, setComponents: function (t, e, n, i) { return this.normal.set(t, e, n), this.constant = i, this }, setFromNormalAndCoplanarPoint: function (t, e) { return this.normal.copy(t), this.constant = -e.dot(this.normal), this }, setFromCoplanarPoints: (bn = new qe, wn = new qe, function (t, e, n) { e = bn.subVectors(n, e).cross(wn.subVectors(t, e)).normalize(); return this.setFromNormalAndCoplanarPoint(e, t), this }), clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.normal.copy(t.normal), this.constant = t.constant, this }, normalize: function () { var t = 1 / this.normal.length(); return this.normal.multiplyScalar(t), this.constant *= t, this }, negate: function () { return this.constant *= -1, this.normal.negate(), this }, distanceToPoint: function (t) { return this.normal.dot(t) + this.constant }, distanceToSphere: function (t) { return this.distanceToPoint(t.center) - t.radius }, projectPoint: function (t, e) { return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new qe), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t) }, intersectLine: (xn = new qe, function (t, e) { void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new qe); var n = t.delta(xn), i = this.normal.dot(n); if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0; i = -(t.start.dot(this.normal) + this.constant) / i; return i < 0 || 1 < i ? void 0 : e.copy(n).multiplyScalar(i).add(t.start) }), intersectsLine: function (t) { var e = this.distanceToPoint(t.start), t = this.distanceToPoint(t.end); return e < 0 && 0 < t || t < 0 && 0 < e }, intersectsBox: function (t) { return t.intersectsPlane(this) }, intersectsSphere: function (t) { return t.intersectsPlane(this) }, coplanarPoint: function (t) { return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new qe), t.copy(this.normal).multiplyScalar(-this.constant) }, applyMatrix4: (vn = new qe, yn = new Xe, function (t, e) { e = e || yn.getNormalMatrix(t), t = this.coplanarPoint(vn).applyMatrix4(t), e = this.normal.applyMatrix3(e).normalize(); return this.constant = -t.dot(e), this }), translate: function (t) { return this.constant -= t.dot(this.normal), this }, equals: function (t) { return t.normal.equals(this.normal) && t.constant === this.constant } }), Object.assign(Un.prototype, { set: function (t, e, n, i, r, a) { var o = this.planes; return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(a), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { for (var e = this.planes, n = 0; n < 6; n++)e[n].copy(t.planes[n]); return this }, setFromMatrix: function (t) { var e = this.planes, n = t.elements, i = n[0], r = n[1], a = n[2], o = n[3], s = n[4], c = n[5], h = n[6], l = n[7], u = n[8], p = n[9], d = n[10], f = n[11], m = n[12], g = n[13], t = n[14], n = n[15]; return e[0].setComponents(o - i, l - s, f - u, n - m).normalize(), e[1].setComponents(o + i, l + s, f + u, n + m).normalize(), e[2].setComponents(o + r, l + c, f + p, n + g).normalize(), e[3].setComponents(o - r, l - c, f - p, n - g).normalize(), e[4].setComponents(o - a, l - h, f - d, n - t).normalize(), e[5].setComponents(o + a, l + h, f + d, n + t).normalize(), this }, intersectsObject: (En = new Bn, function (t) { var e = t.geometry; return null === e.boundingSphere && e.computeBoundingSphere(), En.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(En) }), intersectsSprite: (Mn = new Bn, function (t) { return Mn.center.set(0, 0, 0), Mn.radius = .7071067811865476, Mn.applyMatrix4(t.matrixWorld), this.intersectsSphere(Mn) }), intersectsSphere: function (t) { for (var e = this.planes, n = t.center, i = -t.radius, r = 0; r < 6; r++)if (e[r].distanceToPoint(n) < i) return !1; return !0 }, intersectsBox: (_n = new qe, function (t) { for (var e = this.planes, n = 0; n < 6; n++) { var i = e[n]; if (_n.x = (0 < i.normal.x ? t.max : t.min).x, _n.y = (0 < i.normal.y ? t.max : t.min).y, _n.z = (0 < i.normal.z ? t.max : t.min).z, i.distanceToPoint(_n) < 0) return !1 } return !0 }), containsPoint: function (t) { for (var e = this.planes, n = 0; n < 6; n++)if (e[n].distanceToPoint(t) < 0) return !1; return !0 } }); var Gn = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick( specularColor, dotNV );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif", color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif", common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif", lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor;\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif", map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif", normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif", normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}", uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}", shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}" }; function Fn(t) { var e, n = {}; for (e in t) for (var i in n[e] = {}, t[e]) { var r = t[e][i]; r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? n[e][i] = r.clone() : Array.isArray(r) ? n[e][i] = r.slice() : n[e][i] = r } return n } function Hn(t) { for (var e = {}, n = 0; n < t.length; n++) { var i, r = Fn(t[n]); for (i in r) e[i] = r[i] } return e } var Vn, kn, jn, Wn = { clone: Fn, merge: Hn }, qn = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }; function Xn(t, e, n) { return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n) } function Yn(t) { return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055 } function Jn(t) { return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4) } function Zn(t, e, n) { return n < 0 && (n += 1), 1 < n && --n, n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t } Object.assign(Xn.prototype, { isColor: !0, r: 1, g: 1, b: 1, set: function (t) { return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this }, setScalar: function (t) { return this.r = t, this.g = t, this.b = t, this }, setHex: function (t) { return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this }, setRGB: function (t, e, n) { return this.r = t, this.g = e, this.b = n, this }, setHSL: function (t, e, n) { return t = Ve.euclideanModulo(t, 1), e = Ve.clamp(e, 0, 1), n = Ve.clamp(n, 0, 1), 0 === e ? this.r = this.g = this.b = n : (e = 2 * n - (n = n <= .5 ? n * (1 + e) : n + e - n * e), this.r = Zn(e, n, t + 1 / 3), this.g = Zn(e, n, t), this.b = Zn(e, n, t - 1 / 3)), this }, setStyle: function (e) { function t(t) { void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.") } if (h = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) { var n, i = h[1], r = h[2]; switch (i) { case "rgb": case "rgba": if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, t(n[5]), this; if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, t(n[5]), this; break; case "hsl": case "hsla": if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) { var a = parseFloat(n[1]) / 360, o = parseInt(n[2], 10) / 100, s = parseInt(n[3], 10) / 100; return t(n[5]), this.setHSL(a, o, s) } } } else if (h = /^\#([A-Fa-f0-9]+)$/.exec(e)) { var c, h = (c = h[1]).length; if (3 === h) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this; if (6 === h) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this } return e && 0 < e.length && (void 0 !== (c = qn[e]) ? this.setHex(c) : console.warn("THREE.Color: Unknown color " + e)), this }, clone: function () { return new this.constructor(this.r, this.g, this.b) }, copy: function (t) { return this.r = t.r, this.g = t.g, this.b = t.b, this }, copyGammaToLinear: function (t, e) { return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this }, copyLinearToGamma: function (t, e) { void 0 === e && (e = 2); e = 0 < e ? 1 / e : 1; return this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this }, convertGammaToLinear: function (t) { return this.copyGammaToLinear(this, t), this }, convertLinearToGamma: function (t) { return this.copyLinearToGamma(this, t), this }, copySRGBToLinear: function (t) { return this.r = Jn(t.r), this.g = Jn(t.g), this.b = Jn(t.b), this }, copyLinearToSRGB: function (t) { return this.r = Yn(t.r), this.g = Yn(t.g), this.b = Yn(t.b), this }, convertSRGBToLinear: function () { return this.copySRGBToLinear(this), this }, convertLinearToSRGB: function () { return this.copyLinearToSRGB(this), this }, getHex: function () { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 }, getHexString: function () { return ("000000" + this.getHex().toString(16)).slice(-6) }, getHSL: function (t) { void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = { h: 0, s: 0, l: 0 }); var e, n = this.r, i = this.g, r = this.b, a = Math.max(n, i, r), o = Math.min(n, i, r), s = (o + a) / 2; if (o === a) h = e = 0; else { var c = a - o, h = s <= .5 ? c / (a + o) : c / (2 - a - o); switch (a) { case n: e = (i - r) / c + (i < r ? 6 : 0); break; case i: e = (r - n) / c + 2; break; case r: e = (n - i) / c + 4 }e /= 6 } return t.h = e, t.s = h, t.l = s, t }, getStyle: function () { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" }, offsetHSL: (jn = {}, function (t, e, n) { return this.getHSL(jn), jn.h += t, jn.s += e, jn.l += n, this.setHSL(jn.h, jn.s, jn.l), this }), add: function (t) { return this.r += t.r, this.g += t.g, this.b += t.b, this }, addColors: function (t, e) { return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this }, addScalar: function (t) { return this.r += t, this.g += t, this.b += t, this }, sub: function (t) { return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this }, multiply: function (t) { return this.r *= t.r, this.g *= t.g, this.b *= t.b, this }, multiplyScalar: function (t) { return this.r *= t, this.g *= t, this.b *= t, this }, lerp: function (t, e) { return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this }, lerpHSL: (Vn = { h: 0, s: 0, l: 0 }, kn = { h: 0, s: 0, l: 0 }, function (t, e) { this.getHSL(Vn), t.getHSL(kn); var n = Ve.lerp(Vn.h, kn.h, e), t = Ve.lerp(Vn.s, kn.s, e), e = Ve.lerp(Vn.l, kn.l, e); return this.setHSL(n, t, e), this }), equals: function (t) { return t.r === this.r && t.g === this.g && t.b === this.b }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t }, toJSON: function () { return this.getHex() } }); var Qn, Kn, $n = { common: { diffuse: { value: new Xn(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new Xe }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new ke(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Xn(16777215) } }, lights: { ambientLightColor: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } } }, points: { diffuse: { value: new Xn(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, uvTransform: { value: new Xe } }, sprite: { diffuse: { value: new Xn(15658734) }, opacity: { value: 1 }, center: { value: new ke(.5, .5) }, rotation: { value: 0 }, map: { value: null }, uvTransform: { value: new Xe } } }, ti = { basic: { uniforms: Hn([$n.common, $n.specularmap, $n.envmap, $n.aomap, $n.lightmap, $n.fog]), vertexShader: Gn.meshbasic_vert, fragmentShader: Gn.meshbasic_frag }, lambert: { uniforms: Hn([$n.common, $n.specularmap, $n.envmap, $n.aomap, $n.lightmap, $n.emissivemap, $n.fog, $n.lights, { emissive: { value: new Xn(0) } }]), vertexShader: Gn.meshlambert_vert, fragmentShader: Gn.meshlambert_frag }, phong: { uniforms: Hn([$n.common, $n.specularmap, $n.envmap, $n.aomap, $n.lightmap, $n.emissivemap, $n.bumpmap, $n.normalmap, $n.displacementmap, $n.gradientmap, $n.fog, $n.lights, { emissive: { value: new Xn(0) }, specular: { value: new Xn(1118481) }, shininess: { value: 30 } }]), vertexShader: Gn.meshphong_vert, fragmentShader: Gn.meshphong_frag }, standard: { uniforms: Hn([$n.common, $n.envmap, $n.aomap, $n.lightmap, $n.emissivemap, $n.bumpmap, $n.normalmap, $n.displacementmap, $n.roughnessmap, $n.metalnessmap, $n.fog, $n.lights, { emissive: { value: new Xn(0) }, roughness: { value: .5 }, metalness: { value: .5 }, envMapIntensity: { value: 1 } }]), vertexShader: Gn.meshphysical_vert, fragmentShader: Gn.meshphysical_frag }, matcap: { uniforms: Hn([$n.common, $n.bumpmap, $n.normalmap, $n.displacementmap, $n.fog, { matcap: { value: null } }]), vertexShader: Gn.meshmatcap_vert, fragmentShader: Gn.meshmatcap_frag }, points: { uniforms: Hn([$n.points, $n.fog]), vertexShader: Gn.points_vert, fragmentShader: Gn.points_frag }, dashed: { uniforms: Hn([$n.common, $n.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Gn.linedashed_vert, fragmentShader: Gn.linedashed_frag }, depth: { uniforms: Hn([$n.common, $n.displacementmap]), vertexShader: Gn.depth_vert, fragmentShader: Gn.depth_frag }, normal: { uniforms: Hn([$n.common, $n.bumpmap, $n.normalmap, $n.displacementmap, { opacity: { value: 1 } }]), vertexShader: Gn.normal_vert, fragmentShader: Gn.normal_frag }, sprite: { uniforms: Hn([$n.sprite, $n.fog]), vertexShader: Gn.sprite_vert, fragmentShader: Gn.sprite_frag }, background: { uniforms: { uvTransform: { value: new Xe }, t2D: { value: null } }, vertexShader: Gn.background_vert, fragmentShader: Gn.background_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: Gn.cube_vert, fragmentShader: Gn.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Gn.equirect_vert, fragmentShader: Gn.equirect_frag }, distanceRGBA: { uniforms: Hn([$n.common, $n.displacementmap, { referencePosition: { value: new qe }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Gn.distanceRGBA_vert, fragmentShader: Gn.distanceRGBA_frag }, shadow: { uniforms: Hn([$n.lights, $n.fog, { color: { value: new Xn(0) }, opacity: { value: 1 } }]), vertexShader: Gn.shadow_vert, fragmentShader: Gn.shadow_frag } }; function ei() { var n = null, i = !1, r = null; function a(t, e) { !1 !== i && (r(t, e), n.requestAnimationFrame(a)) } return { start: function () { !0 !== i && null !== r && (n.requestAnimationFrame(a), i = !0) }, stop: function () { i = !1 }, setAnimationLoop: function (t) { r = t }, setContext: function (t) { n = t } } } function ni(c) { var h = new WeakMap; return { get: function (t) { return t.isInterleavedBufferAttribute && (t = t.data), h.get(t) }, remove: function (t) { t.isInterleavedBufferAttribute && (t = t.data); var e = h.get(t); e && (c.deleteBuffer(e.buffer), h.delete(t)) }, update: function (t, e) { t.isInterleavedBufferAttribute && (t = t.data); var n, i, r, a, o, s = h.get(t); void 0 === s ? h.set(t, (i = e, r = (n = t).array, a = n.dynamic ? 35048 : 35044, o = c.createBuffer(), c.bindBuffer(i, o), c.bufferData(i, r, a), n.onUploadCallback(), a = 5126, r instanceof Float32Array ? a = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? a = 5123 : r instanceof Int16Array ? a = 5122 : r instanceof Uint32Array ? a = 5125 : r instanceof Int32Array ? a = 5124 : r instanceof Int8Array ? a = 5120 : r instanceof Uint8Array && (a = 5121), { buffer: o, type: a, bytesPerElement: r.BYTES_PER_ELEMENT, version: n.version })) : s.version < t.version && (o = s.buffer, a = e, n = (r = t).array, e = r.updateRange, c.bindBuffer(a, o), !1 === r.dynamic ? c.bufferData(a, n, 35044) : -1 === e.count ? c.bufferSubData(a, 0, n) : 0 === e.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (c.bufferSubData(a, e.offset * n.BYTES_PER_ELEMENT, n.subarray(e.offset, e.offset + e.count)), e.count = -1), s.version = t.version) } } } function ii(t, e, n, i, r, a) { this.a = t, this.b = e, this.c = n, this.normal = i && i.isVector3 ? i : new qe, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new Xn, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== a ? a : 0 } function ri(t, e, n, i) { this._x = t || 0, this._y = e || 0, this._z = n || 0, this._order = i || ri.DefaultOrder } function ai() { this.mask = 1 } ti.physical = { uniforms: Hn([ti.standard.uniforms, { clearCoat: { value: 0 }, clearCoatRoughness: { value: 0 } }]), vertexShader: Gn.meshphysical_vert, fragmentShader: Gn.meshphysical_frag }, Object.assign(ii.prototype, { clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex; for (var e = 0, n = t.vertexNormals.length; e < n; e++)this.vertexNormals[e] = t.vertexNormals[e].clone(); for (e = 0, n = t.vertexColors.length; e < n; e++)this.vertexColors[e] = t.vertexColors[e].clone(); return this } }), ri.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], ri.DefaultOrder = "XYZ", Object.defineProperties(ri.prototype, { x: { get: function () { return this._x }, set: function (t) { this._x = t, this.onChangeCallback() } }, y: { get: function () { return this._y }, set: function (t) { this._y = t, this.onChangeCallback() } }, z: { get: function () { return this._z }, set: function (t) { this._z = t, this.onChangeCallback() } }, order: { get: function () { return this._order }, set: function (t) { this._order = t, this.onChangeCallback() } } }), Object.assign(ri.prototype, { isEuler: !0, set: function (t, e, n, i) { return this._x = t, this._y = e, this._z = n, this._order = i || this._order, this.onChangeCallback(), this }, clone: function () { return new this.constructor(this._x, this._y, this._z, this._order) }, copy: function (t) { return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this }, setFromRotationMatrix: function (t, e, n) { var i = Ve.clamp, r = t.elements, a = r[0], o = r[4], s = r[8], c = r[1], h = r[5], l = r[9], u = r[2], t = r[6], r = r[10]; return "XYZ" === (e = e || this._order) ? (this._y = Math.asin(i(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-l, r), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(t, h), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-i(l, -1, 1)), Math.abs(l) < .99999 ? (this._y = Math.atan2(s, r), this._z = Math.atan2(c, h)) : (this._y = Math.atan2(-u, a), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(i(t, -1, 1)), Math.abs(t) < .99999 ? (this._y = Math.atan2(-u, r), this._z = Math.atan2(-o, h)) : (this._y = 0, this._z = Math.atan2(c, a))) : "ZYX" === e ? (this._y = Math.asin(-i(u, -1, 1)), Math.abs(u) < .99999 ? (this._x = Math.atan2(t, r), this._z = Math.atan2(c, a)) : (this._x = 0, this._z = Math.atan2(-o, h))) : "YZX" === e ? (this._z = Math.asin(i(c, -1, 1)), Math.abs(c) < .99999 ? (this._x = Math.atan2(-l, h), this._y = Math.atan2(-u, a)) : (this._x = 0, this._y = Math.atan2(s, r))) : "XZY" === e ? (this._z = Math.asin(-i(o, -1, 1)), Math.abs(o) < .99999 ? (this._x = Math.atan2(t, h), this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-l, r), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, !1 !== n && this.onChangeCallback(), this }, setFromQuaternion: (Kn = new je, function (t, e, n) { return Kn.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Kn, e, n) }), setFromVector3: function (t, e) { return this.set(t.x, t.y, t.z, e || this._order) }, reorder: (Qn = new We, function (t) { return Qn.setFromEuler(this), this.setFromQuaternion(Qn, t) }), equals: function (t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order }, fromArray: function (t) { return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t }, toVector3: function (t) { return t ? t.set(this._x, this._y, this._z) : new qe(this._x, this._y, this._z) }, onChange: function (t) { return this.onChangeCallback = t, this }, onChangeCallback: function () { } }), Object.assign(ai.prototype, { set: function (t) { this.mask = 1 << t | 0 }, enable: function (t) { this.mask |= 1 << t | 0 }, toggle: function (t) { this.mask ^= 1 << t | 0 }, disable: function (t) { this.mask &= ~(1 << t | 0) }, test: function (t) { return 0 != (this.mask & t.mask) } }); var oi, si, ci, hi, li, ui, pi, di, fi, mi, gi, vi, yi, xi, bi, wi, _i, Mi, Ei = 0; function Si() { Object.defineProperty(this, "id", { value: Ei++ }), this.uuid = Ve.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Si.DefaultUp.clone(); var t = new qe, e = new ri, n = new We, i = new qe(1, 1, 1); e.onChange(function () { n.setFromEuler(e, !1) }), n.onChange(function () { e.setFromQuaternion(n, void 0, !1) }), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: t }, rotation: { configurable: !0, enumerable: !0, value: e }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: i }, modelViewMatrix: { value: new je }, normalMatrix: { value: new Xe } }), this.matrix = new je, this.matrixWorld = new je, this.matrixAutoUpdate = Si.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new ai, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {} } Si.DefaultUp = new qe(0, 1, 0), Si.DefaultMatrixAutoUpdate = !0, Si.prototype = Object.assign(Object.create(e.prototype), { constructor: Si, isObject3D: !0, onBeforeRender: function () { }, onAfterRender: function () { }, applyMatrix: function (t) { this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale) }, applyQuaternion: function (t) { return this.quaternion.premultiply(t), this }, setRotationFromAxisAngle: function (t, e) { this.quaternion.setFromAxisAngle(t, e) }, setRotationFromEuler: function (t) { this.quaternion.setFromEuler(t, !0) }, setRotationFromMatrix: function (t) { this.quaternion.setFromRotationMatrix(t) }, setRotationFromQuaternion: function (t) { this.quaternion.copy(t) }, rotateOnAxis: (Mi = new We, function (t, e) { return Mi.setFromAxisAngle(t, e), this.quaternion.multiply(Mi), this }), rotateOnWorldAxis: (_i = new We, function (t, e) { return _i.setFromAxisAngle(t, e), this.quaternion.premultiply(_i), this }), rotateX: (wi = new qe(1, 0, 0), function (t) { return this.rotateOnAxis(wi, t) }), rotateY: (bi = new qe(0, 1, 0), function (t) { return this.rotateOnAxis(bi, t) }), rotateZ: (xi = new qe(0, 0, 1), function (t) { return this.rotateOnAxis(xi, t) }), translateOnAxis: (yi = new qe, function (t, e) { return yi.copy(t).applyQuaternion(this.quaternion), this.position.add(yi.multiplyScalar(e)), this }), translateX: (vi = new qe(1, 0, 0), function (t) { return this.translateOnAxis(vi, t) }), translateY: (gi = new qe(0, 1, 0), function (t) { return this.translateOnAxis(gi, t) }), translateZ: (mi = new qe(0, 0, 1), function (t) { return this.translateOnAxis(mi, t) }), localToWorld: function (t) { return t.applyMatrix4(this.matrixWorld) }, worldToLocal: (fi = new je, function (t) { return t.applyMatrix4(fi.getInverse(this.matrixWorld)) }), lookAt: (li = new We, ui = new je, pi = new qe, di = new qe, function (t, e, n) { t.isVector3 ? pi.copy(t) : pi.set(t, e, n); n = this.parent; this.updateWorldMatrix(!0, !1), di.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ui.lookAt(di, pi, this.up) : ui.lookAt(pi, di, this.up), this.quaternion.setFromRotationMatrix(ui), n && (ui.extractRotation(n.matrixWorld), li.setFromRotationMatrix(ui), this.quaternion.premultiply(li.inverse())) }), add: function (t) { if (1 < arguments.length) { for (var e = 0; e < arguments.length; e++)this.add(arguments[e]); return this } return t === this ? console.error("THREE.Object3D.add: object can't be added as a child of itself.", t) : t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({ type: "added" }), this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this }, remove: function (t) { if (1 < arguments.length) { for (var e = 0; e < arguments.length; e++)this.remove(arguments[e]); return this } var n = this.children.indexOf(t); return -1 !== n && (t.parent = null, t.dispatchEvent({ type: "removed" }), this.children.splice(n, 1)), this }, getObjectById: function (t) { return this.getObjectByProperty("id", t) }, getObjectByName: function (t) { return this.getObjectByProperty("name", t) }, getObjectByProperty: function (t, e) { if (this[t] === e) return this; for (var n = 0, i = this.children.length; n < i; n++) { var r = this.children[n].getObjectByProperty(t, e); if (void 0 !== r) return r } }, getWorldPosition: function (t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new qe), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld) }, getWorldQuaternion: (ci = new qe, hi = new qe, function (t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new We), this.updateMatrixWorld(!0), this.matrixWorld.decompose(ci, t, hi), t }), getWorldScale: (oi = new qe, si = new We, function (t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new qe), this.updateMatrixWorld(!0), this.matrixWorld.decompose(oi, si, t), t }), getWorldDirection: function (t) { void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new qe), this.updateMatrixWorld(!0); var e = this.matrixWorld.elements; return t.set(e[8], e[9], e[10]).normalize() }, raycast: function () { }, traverse: function (t) { t(this); for (var e = this.children, n = 0, i = e.length; n < i; n++)e[n].traverse(t) }, traverseVisible: function (t) { if (!1 !== this.visible) { t(this); for (var e = this.children, n = 0, i = e.length; n < i; n++)e[n].traverseVisible(t) } }, traverseAncestors: function (t) { var e = this.parent; null !== e && (t(e), e.traverseAncestors(t)) }, updateMatrix: function () { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 }, updateMatrixWorld: function (t) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t = !(this.matrixWorldNeedsUpdate = !1)); for (var e = this.children, n = 0, i = e.length; n < i; n++)e[n].updateMatrixWorld(t) }, updateWorldMatrix: function (t, e) { var n = this.parent; if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) for (var i = this.children, r = 0, a = i.length; r < a; r++)i[r].updateWorldMatrix(!1, !0) }, toJSON: function (n) { var t = void 0 === n || "string" == typeof n, e = {}; t && (n = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }, e.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); var i, r, a = {}; function o(t, e) { return void 0 === t[e.uuid] && (t[e.uuid] = e.toJSON(n)), e.uuid } if (a.uuid = this.uuid, a.type = this.type, "" !== this.name && (a.name = this.name), !0 === this.castShadow && (a.castShadow = !0), !0 === this.receiveShadow && (a.receiveShadow = !0), !1 === this.visible && (a.visible = !1), !1 === this.frustumCulled && (a.frustumCulled = !1), 0 !== this.renderOrder && (a.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (a.userData = this.userData), a.layers = this.layers.mask, a.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (a.matrixAutoUpdate = !1), this.isMesh && this.drawMode !== Pe && (a.drawMode = this.drawMode), this.isMesh || this.isLine || this.isPoints) { a.geometry = o(n.geometries, this.geometry); var s = this.geometry.parameters; if (void 0 !== s && void 0 !== s.shapes) { var c = s.shapes; if (Array.isArray(c)) for (var h = 0, l = c.length; h < l; h++) { var u = c[h]; o(n.shapes, u) } else o(n.shapes, c) } } if (void 0 !== this.material) if (Array.isArray(this.material)) { for (var p = [], h = 0, l = this.material.length; h < l; h++)p.push(o(n.materials, this.material[h])); a.material = p } else a.material = o(n.materials, this.material); if (0 < this.children.length) { a.children = []; for (h = 0; h < this.children.length; h++)a.children.push(this.children[h].toJSON(n).object) } return t && (i = d(n.geometries), r = d(n.materials), s = d(n.textures), t = d(n.images), c = d(n.shapes), 0 < i.length && (e.geometries = i), 0 < r.length && (e.materials = r), 0 < s.length && (e.textures = s), 0 < t.length && (e.images = t), 0 < c.length && (e.shapes = c)), e.object = a, e; function d(t) { var e, n = []; for (e in t) { var i = t[e]; delete i.metadata, n.push(i) } return n } }, clone: function (t) { return (new this.constructor).copy(this, t) }, copy: function (t, e) { if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (var n = 0; n < t.children.length; n++) { var i = t.children[n]; this.add(i.clone()) } return this } }); var Ti, Ai, Li, Ri, Pi, Ci, Oi, Ii = 0; function Di() { Object.defineProperty(this, "id", { value: Ii += 2 }), this.uuid = Ve.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1 } function Ni(t, e, n) { if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } function Bi(t, e, n) { Ni.call(this, new Int8Array(t), e, n) } function zi(t, e, n) { Ni.call(this, new Uint8Array(t), e, n) } function Ui(t, e, n) { Ni.call(this, new Uint8ClampedArray(t), e, n) } function Gi(t, e, n) { Ni.call(this, new Int16Array(t), e, n) } function Fi(t, e, n) { Ni.call(this, new Uint16Array(t), e, n) } function Hi(t, e, n) { Ni.call(this, new Int32Array(t), e, n) } function Vi(t, e, n) { Ni.call(this, new Uint32Array(t), e, n) } function ki(t, e, n) { Ni.call(this, new Float32Array(t), e, n) } function ji(t, e, n) { Ni.call(this, new Float64Array(t), e, n) } function Wi() { this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1 } function qi(t) { if (0 === t.length) return -1 / 0; for (var e = t[0], n = 1, i = t.length; n < i; ++n)t[n] > e && (e = t[n]); return e } Di.prototype = Object.assign(Object.create(e.prototype), { constructor: Di, isGeometry: !0, applyMatrix: function (t) { for (var e = (new Xe).getNormalMatrix(t), n = 0, i = this.vertices.length; n < i; n++)this.vertices[n].applyMatrix4(t); for (n = 0, i = this.faces.length; n < i; n++) { var r = this.faces[n]; r.normal.applyMatrix3(e).normalize(); for (var a = 0, o = r.vertexNormals.length; a < o; a++)r.vertexNormals[a].applyMatrix3(e).normalize() } return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this }, rotateX: (Oi = new je, function (t) { return Oi.makeRotationX(t), this.applyMatrix(Oi), this }), rotateY: (Ci = new je, function (t) { return Ci.makeRotationY(t), this.applyMatrix(Ci), this }), rotateZ: (Pi = new je, function (t) { return Pi.makeRotationZ(t), this.applyMatrix(Pi), this }), translate: (Ri = new je, function (t, e, n) { return Ri.makeTranslation(t, e, n), this.applyMatrix(Ri), this }), scale: (Li = new je, function (t, e, n) { return Li.makeScale(t, e, n), this.applyMatrix(Li), this }), lookAt: (Ai = new Si, function (t) { Ai.lookAt(t), Ai.updateMatrix(), this.applyMatrix(Ai.matrix) }), fromBufferGeometry: function (t) { var a = this, e = null !== t.index ? t.index.array : void 0, n = t.attributes, i = n.position.array, o = void 0 !== n.normal ? n.normal.array : void 0, s = void 0 !== n.color ? n.color.array : void 0, c = void 0 !== n.uv ? n.uv.array : void 0, h = void 0 !== n.uv2 ? n.uv2.array : void 0; void 0 !== h && (this.faceVertexUvs[1] = []); for (var r = 0, l = 0; r < i.length; r += 3, l += 2)a.vertices.push((new qe).fromArray(i, r)), void 0 !== s && a.colors.push((new Xn).fromArray(s, r)); function u(t, e, n, i) { var r = void 0 === s ? [] : [a.colors[t].clone(), a.colors[e].clone(), a.colors[n].clone()], i = new ii(t, e, n, void 0 === o ? [] : [(new qe).fromArray(o, 3 * t), (new qe).fromArray(o, 3 * e), (new qe).fromArray(o, 3 * n)], r, i); a.faces.push(i), void 0 !== c && a.faceVertexUvs[0].push([(new ke).fromArray(c, 2 * t), (new ke).fromArray(c, 2 * e), (new ke).fromArray(c, 2 * n)]), void 0 !== h && a.faceVertexUvs[1].push([(new ke).fromArray(h, 2 * t), (new ke).fromArray(h, 2 * e), (new ke).fromArray(h, 2 * n)]) } var p = t.groups; if (0 < p.length) for (r = 0; r < p.length; r++)for (var d = p[r], f = d.start, l = f, m = f + d.count; l < m; l += 3)void 0 !== e ? u(e[l], e[l + 1], e[l + 2], d.materialIndex) : u(l, l + 1, l + 2, d.materialIndex); else if (void 0 !== e) for (r = 0; r < e.length; r += 3)u(e[r], e[r + 1], e[r + 2]); else for (r = 0; r < i.length / 3; r += 3)u(r, r + 1, r + 2); return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this }, center: (Ti = new qe, function () { return this.computeBoundingBox(), this.boundingBox.getCenter(Ti).negate(), this.translate(Ti.x, Ti.y, Ti.z), this }), normalize: function () { this.computeBoundingSphere(); var t = this.boundingSphere.center, e = this.boundingSphere.radius, n = 0 === e ? 1 : 1 / e, e = new je; return e.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix(e), this }, computeFaceNormals: function () { for (var t = new qe, e = new qe, n = 0, i = this.faces.length; n < i; n++) { var r = this.faces[n], a = this.vertices[r.a], o = this.vertices[r.b], s = this.vertices[r.c]; t.subVectors(s, o), e.subVectors(a, o), t.cross(e), t.normalize(), r.normal.copy(t) } }, computeVertexNormals: function (t) { var e, n, i, r; for (void 0 === t && (t = !0), r = new Array(this.vertices.length), e = 0, n = this.vertices.length; e < n; e++)r[e] = new qe; if (t) for (var a, o, s, c = new qe, h = new qe, l = 0, u = this.faces.length; l < u; l++)i = this.faces[l], a = this.vertices[i.a], o = this.vertices[i.b], s = this.vertices[i.c], c.subVectors(s, o), h.subVectors(a, o), c.cross(h), r[i.a].add(c), r[i.b].add(c), r[i.c].add(c); else for (this.computeFaceNormals(), l = 0, u = this.faces.length; l < u; l++)r[(i = this.faces[l]).a].add(i.normal), r[i.b].add(i.normal), r[i.c].add(i.normal); for (e = 0, n = this.vertices.length; e < n; e++)r[e].normalize(); for (l = 0, u = this.faces.length; l < u; l++) { var p = (i = this.faces[l]).vertexNormals; 3 === p.length ? (p[0].copy(r[i.a]), p[1].copy(r[i.b]), p[2].copy(r[i.c])) : (p[0] = r[i.a].clone(), p[1] = r[i.b].clone(), p[2] = r[i.c].clone()) } 0 < this.faces.length && (this.normalsNeedUpdate = !0) }, computeFlatVertexNormals: function () { var t, e, n; for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) { var i = (n = this.faces[t]).vertexNormals; 3 === i.length ? (i[0].copy(n.normal), i[1].copy(n.normal), i[2].copy(n.normal)) : (i[0] = n.normal.clone(), i[1] = n.normal.clone(), i[2] = n.normal.clone()) } 0 < this.faces.length && (this.normalsNeedUpdate = !0) }, computeMorphNormals: function () { var t, e, n; for (o = 0, s = this.faces.length; o < s; o++)for ((n = this.faces[o]).__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(), n.__originalVertexNormals || (n.__originalVertexNormals = []), t = 0, e = n.vertexNormals.length; t < e; t++)n.__originalVertexNormals[t] ? n.__originalVertexNormals[t].copy(n.vertexNormals[t]) : n.__originalVertexNormals[t] = n.vertexNormals[t].clone(); var i = new Di; for (i.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) { if (!this.morphNormals[t]) { this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = []; for (var r = this.morphNormals[t].faceNormals, a = this.morphNormals[t].vertexNormals, o = 0, s = this.faces.length; o < s; o++)c = new qe, h = { a: new qe, b: new qe, c: new qe }, r.push(c), a.push(h) } var c, h, l = this.morphNormals[t]; for (i.vertices = this.morphTargets[t].vertices, i.computeFaceNormals(), i.computeVertexNormals(), o = 0, s = this.faces.length; o < s; o++)n = this.faces[o], c = l.faceNormals[o], h = l.vertexNormals[o], c.copy(n.normal), h.a.copy(n.vertexNormals[0]), h.b.copy(n.vertexNormals[1]), h.c.copy(n.vertexNormals[2]) } for (o = 0, s = this.faces.length; o < s; o++)(n = this.faces[o]).normal = n.__originalFaceNormal, n.vertexNormals = n.__originalVertexNormals }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new In), this.boundingBox.setFromPoints(this.vertices) }, computeBoundingSphere: function () { null === this.boundingSphere && (this.boundingSphere = new Bn), this.boundingSphere.setFromPoints(this.vertices) }, merge: function (t, e, n) { if (t && t.isGeometry) { var i, r = this.vertices.length, a = this.vertices, o = t.vertices, s = this.faces, c = t.faces, h = this.faceVertexUvs[0], l = t.faceVertexUvs[0], u = this.colors, p = t.colors; void 0 === n && (n = 0), void 0 !== e && (i = (new Xe).getNormalMatrix(e)); for (var d = 0, f = o.length; d < f; d++) { var m = o[d].clone(); void 0 !== e && m.applyMatrix4(e), a.push(m) } for (d = 0, f = p.length; d < f; d++)u.push(p[d].clone()); for (d = 0, f = c.length; d < f; d++) { var g, v, y = c[d], x = y.vertexNormals, b = y.vertexColors, w = new ii(y.a + r, y.b + r, y.c + r); w.normal.copy(y.normal), void 0 !== i && w.normal.applyMatrix3(i).normalize(); for (var _ = 0, M = x.length; _ < M; _++)g = x[_].clone(), void 0 !== i && g.applyMatrix3(i).normalize(), w.vertexNormals.push(g); w.color.copy(y.color); for (_ = 0, M = b.length; _ < M; _++)v = b[_], w.vertexColors.push(v.clone()); w.materialIndex = y.materialIndex + n, s.push(w) } for (d = 0, f = l.length; d < f; d++) { var E = l[d], S = []; if (void 0 !== E) { for (_ = 0, M = E.length; _ < M; _++)S.push(E[_].clone()); h.push(S) } } } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t) }, mergeMesh: function (t) { t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t) }, mergeVertices: function () { for (var t, e, n, i, r, a = {}, o = [], s = [], c = Math.pow(10, 4), h = 0, l = this.vertices.length; h < l; h++)t = this.vertices[h], void 0 === a[t = Math.round(t.x * c) + "_" + Math.round(t.y * c) + "_" + Math.round(t.z * c)] ? (a[t] = h, o.push(this.vertices[h]), s[h] = o.length - 1) : s[h] = s[a[t]]; var u = []; for (h = 0, l = this.faces.length; h < l; h++) { (e = this.faces[h]).a = s[e.a], e.b = s[e.b], e.c = s[e.c], n = [e.a, e.b, e.c]; for (var p = 0; p < 3; p++)if (n[p] === n[(p + 1) % 3]) { u.push(h); break } } for (h = u.length - 1; 0 <= h; h--) { var d = u[h]; for (this.faces.splice(d, 1), i = 0, r = this.faceVertexUvs.length; i < r; i++)this.faceVertexUvs[i].splice(d, 1) } var f = this.vertices.length - o.length; return this.vertices = o, f }, setFromPoints: function (t) { this.vertices = []; for (var e = 0, n = t.length; e < n; e++) { var i = t[e]; this.vertices.push(new qe(i.x, i.y, i.z || 0)) } return this }, sortFacesByMaterialIndex: function () { for (var t = this.faces, e = t.length, n = 0; n < e; n++)t[n]._id = n; t.sort(function (t, e) { return t.materialIndex - e.materialIndex }); var i, r, a = this.faceVertexUvs[0], o = this.faceVertexUvs[1]; a && a.length === e && (i = []), o && o.length === e && (r = []); for (n = 0; n < e; n++) { var s = t[n]._id; i && i.push(a[s]), r && r.push(o[s]) } i && (this.faceVertexUvs[0] = i), r && (this.faceVertexUvs[1] = r) }, toJSON: function () { var t = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } }; if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) { var e, n = this.parameters; for (e in n) void 0 !== n[e] && (t[e] = n[e]); return t } for (var i = [], r = 0; r < this.vertices.length; r++) { var a = this.vertices[r]; i.push(a.x, a.y, a.z) } for (var o = [], s = [], c = {}, h = [], l = {}, u = [], p = {}, r = 0; r < this.faces.length; r++) { var d, f = this.faces[r], m = void 0 !== this.faceVertexUvs[0][r], g = 0 < f.normal.length(), v = 0 < f.vertexNormals.length, y = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b, x = 0 < f.vertexColors.length; d = b(2, 3, m), d = b(d, 4, g), d = b(d, 5, v), d = b(d, 6, y), d = b(d, 7, x), o.push(d), o.push(f.a, f.b, f.c), o.push(f.materialIndex), m && (m = this.faceVertexUvs[0][r], o.push(M(m[0]), M(m[1]), M(m[2]))), g && o.push(w(f.normal)), v && (v = f.vertexNormals, o.push(w(v[0]), w(v[1]), w(v[2]))), y && o.push(_(f.color)), x && (f = f.vertexColors, o.push(_(f[0]), _(f[1]), _(f[2]))) } function b(t, e, n) { return n ? t | 1 << e : t & ~(1 << e) } function w(t) { var e = t.x.toString() + t.y.toString() + t.z.toString(); return void 0 !== c[e] || (c[e] = s.length / 3, s.push(t.x, t.y, t.z)), c[e] } function _(t) { var e = t.r.toString() + t.g.toString() + t.b.toString(); return void 0 !== l[e] || (l[e] = h.length, h.push(t.getHex())), l[e] } function M(t) { var e = t.x.toString() + t.y.toString(); return void 0 !== p[e] || (p[e] = u.length / 2, u.push(t.x, t.y)), p[e] } return t.data = {}, t.data.vertices = i, t.data.normals = s, 0 < h.length && (t.data.colors = h), 0 < u.length && (t.data.uvs = [u]), t.data.faces = o, t }, clone: function () { return (new Di).copy(this) }, copy: function (t) { var e, n; this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name; for (var i = t.vertices, r = 0, a = i.length; r < a; r++)this.vertices.push(i[r].clone()); var o = t.colors; for (r = 0, a = o.length; r < a; r++)this.colors.push(o[r].clone()); var s = t.faces; for (r = 0, a = s.length; r < a; r++)this.faces.push(s[r].clone()); for (r = 0, a = t.faceVertexUvs.length; r < a; r++) { var c = t.faceVertexUvs[r]; for (void 0 === this.faceVertexUvs[r] && (this.faceVertexUvs[r] = []), e = 0, n = c.length; e < n; e++) { for (var h = c[e], l = [], u = 0, p = h.length; u < p; u++) { var d = h[u]; l.push(d.clone()) } this.faceVertexUvs[r].push(l) } } var f = t.morphTargets; for (r = 0, a = f.length; r < a; r++) { var m = {}; if (m.name = f[r].name, void 0 !== f[r].vertices) for (m.vertices = [], e = 0, n = f[r].vertices.length; e < n; e++)m.vertices.push(f[r].vertices[e].clone()); if (void 0 !== f[r].normals) for (m.normals = [], e = 0, n = f[r].normals.length; e < n; e++)m.normals.push(f[r].normals[e].clone()); this.morphTargets.push(m) } var g = t.morphNormals; for (r = 0, a = g.length; r < a; r++) { var v = {}; if (void 0 !== g[r].vertexNormals) for (v.vertexNormals = [], e = 0, n = g[r].vertexNormals.length; e < n; e++) { var y = g[r].vertexNormals[e], x = {}; x.a = y.a.clone(), x.b = y.b.clone(), x.c = y.c.clone(), v.vertexNormals.push(x) } if (void 0 !== g[r].faceNormals) for (v.faceNormals = [], e = 0, n = g[r].faceNormals.length; e < n; e++)v.faceNormals.push(g[r].faceNormals[e].clone()); this.morphNormals.push(v) } var b = t.skinWeights; for (r = 0, a = b.length; r < a; r++)this.skinWeights.push(b[r].clone()); var w = t.skinIndices; for (r = 0, a = w.length; r < a; r++)this.skinIndices.push(w[r].clone()); var _ = t.lineDistances; for (r = 0, a = _.length; r < a; r++)this.lineDistances.push(_[r]); var M = t.boundingBox; null !== M && (this.boundingBox = M.clone()); M = t.boundingSphere; return null !== M && (this.boundingSphere = M.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), Object.defineProperty(Ni.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), Object.assign(Ni.prototype, { isBufferAttribute: !0, onUploadCallback: function () { }, setArray: function (t) { if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); return this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t, this }, setDynamic: function (t) { return this.dynamic = t, this }, copy: function (t) { return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this }, copyAt: function (t, e, n) { t *= this.itemSize, n *= e.itemSize; for (var i = 0, r = this.itemSize; i < r; i++)this.array[t + i] = e.array[n + i]; return this }, copyArray: function (t) { return this.array.set(t), this }, copyColorsArray: function (t) { for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) { var a = t[i]; void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), a = new Xn), e[n++] = a.r, e[n++] = a.g, e[n++] = a.b } return this }, copyVector2sArray: function (t) { for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) { var a = t[i]; void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), a = new ke), e[n++] = a.x, e[n++] = a.y } return this }, copyVector3sArray: function (t) { for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) { var a = t[i]; void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), a = new qe), e[n++] = a.x, e[n++] = a.y, e[n++] = a.z } return this }, copyVector4sArray: function (t) { for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) { var a = t[i]; void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), a = new Ln), e[n++] = a.x, e[n++] = a.y, e[n++] = a.z, e[n++] = a.w } return this }, set: function (t, e) { return void 0 === e && (e = 0), this.array.set(t, e), this }, getX: function (t) { return this.array[t * this.itemSize] }, setX: function (t, e) { return this.array[t * this.itemSize] = e, this }, getY: function (t) { return this.array[t * this.itemSize + 1] }, setY: function (t, e) { return this.array[t * this.itemSize + 1] = e, this }, getZ: function (t) { return this.array[t * this.itemSize + 2] }, setZ: function (t, e) { return this.array[t * this.itemSize + 2] = e, this }, getW: function (t) { return this.array[t * this.itemSize + 3] }, setW: function (t, e) { return this.array[t * this.itemSize + 3] = e, this }, setXY: function (t, e, n) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this }, setXYZ: function (t, e, n, i) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this }, setXYZW: function (t, e, n, i, r) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this }, onUpload: function (t) { return this.onUploadCallback = t, this }, clone: function () { return new this.constructor(this.array, this.itemSize).copy(this) } }), (Bi.prototype = Object.create(Ni.prototype)).constructor = Bi, (zi.prototype = Object.create(Ni.prototype)).constructor = zi, (Ui.prototype = Object.create(Ni.prototype)).constructor = Ui, (Gi.prototype = Object.create(Ni.prototype)).constructor = Gi, (Fi.prototype = Object.create(Ni.prototype)).constructor = Fi, (Hi.prototype = Object.create(Ni.prototype)).constructor = Hi, (Vi.prototype = Object.create(Ni.prototype)).constructor = Vi, (ki.prototype = Object.create(Ni.prototype)).constructor = ki, (ji.prototype = Object.create(Ni.prototype)).constructor = ji, Object.assign(Wi.prototype, { computeGroups: function (t) { for (var e, n = [], i = void 0, r = t.faces, a = 0; a < r.length; a++) { var o = r[a]; o.materialIndex !== i && (i = o.materialIndex, void 0 !== e && (e.count = 3 * a - e.start, n.push(e)), e = { start: 3 * a, materialIndex: i }) } void 0 !== e && (e.count = 3 * a - e.start, n.push(e)), this.groups = n }, fromGeometry: function (t) { var e, n = t.faces, i = t.vertices, r = t.faceVertexUvs, a = r[0] && 0 < r[0].length, o = r[1] && 0 < r[1].length, s = t.morphTargets, c = s.length; if (0 < c) { e = []; for (var h = 0; h < c; h++)e[h] = { name: s[h].name, data: [] }; this.morphTargets.position = e } var l, u = t.morphNormals, p = u.length; if (0 < p) { l = []; for (h = 0; h < p; h++)l[h] = { name: u[h].name, data: [] }; this.morphTargets.normal = l } var d = t.skinIndices, f = t.skinWeights, m = d.length === i.length, g = f.length === i.length; 0 < i.length && 0 === n.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."); for (h = 0; h < n.length; h++) { var v = n[h]; this.vertices.push(i[v.a], i[v.b], i[v.c]); var y = v.vertexNormals; 3 === y.length ? this.normals.push(y[0], y[1], y[2]) : (b = v.normal, this.normals.push(b, b, b)); var x, b = v.vertexColors; 3 === b.length ? this.colors.push(b[0], b[1], b[2]) : (b = v.color, this.colors.push(b, b, b)), !0 === a && (void 0 !== (x = r[0][h]) ? this.uvs.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h), this.uvs.push(new ke, new ke, new ke))), !0 === o && (void 0 !== (x = r[1][h]) ? this.uvs2.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h), this.uvs2.push(new ke, new ke, new ke))); for (var w = 0; w < c; w++) { var _ = s[w].vertices; e[w].data.push(_[v.a], _[v.b], _[v.c]) } for (w = 0; w < p; w++) { var M = u[w].vertexNormals[h]; l[w].data.push(M.a, M.b, M.c) } m && this.skinIndices.push(d[v.a], d[v.b], d[v.c]), g && this.skinWeights.push(f[v.a], f[v.b], f[v.c]) } return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this } }); var Xi, Yi, Ji, Zi, Qi, Ki, $i, tr, er, nr, ir = 1; function rr() { Object.defineProperty(this, "id", { value: ir += 2 }), this.uuid = Ve.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } function ar(t, e, n, i, r, a) { Di.call(this), this.type = "BoxGeometry", this.parameters = { width: t, height: e, depth: n, widthSegments: i, heightSegments: r, depthSegments: a }, this.fromBufferGeometry(new or(t, e, n, i, r, a)), this.mergeVertices() } function or(t, e, n, i, r, a) { rr.call(this), this.type = "BoxBufferGeometry", this.parameters = { width: t, height: e, depth: n, widthSegments: i, heightSegments: r, depthSegments: a }; var R = this; t = t || 1, e = e || 1, n = n || 1, i = Math.floor(i) || 1, r = Math.floor(r) || 1, a = Math.floor(a) || 1; var P = [], C = [], O = [], I = [], D = 0, N = 0; function o(t, e, n, i, r, a, o, s, c, h, l) { for (var u = a / c, p = o / h, d = a / 2, f = o / 2, m = s / 2, g = c + 1, v = h + 1, y = 0, x = 0, b = new qe, w = 0; w < v; w++)for (var _ = w * p - f, M = 0; M < g; M++) { var E = M * u - d; b[t] = E * i, b[e] = _ * r, b[n] = m, C.push(b.x, b.y, b.z), b[t] = 0, b[e] = 0, b[n] = 0 < s ? 1 : -1, O.push(b.x, b.y, b.z), I.push(M / c), I.push(1 - w / h), y += 1 } for (w = 0; w < h; w++)for (M = 0; M < c; M++) { var S = D + M + g * w, T = D + M + g * (w + 1), A = D + (M + 1) + g * (w + 1), L = D + (M + 1) + g * w; P.push(S, T, L), P.push(T, A, L), x += 6 } R.addGroup(N, x, l), N += x, D += y } o("z", "y", "x", -1, -1, n, e, t, a, r, 0), o("z", "y", "x", 1, -1, n, e, -t, a, r, 1), o("x", "z", "y", 1, 1, t, n, e, i, a, 2), o("x", "z", "y", 1, -1, t, n, -e, i, a, 3), o("x", "y", "z", 1, -1, t, e, n, i, r, 4), o("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(P), this.addAttribute("position", new ki(C, 3)), this.addAttribute("normal", new ki(O, 3)), this.addAttribute("uv", new ki(I, 2)) } function sr(t, e, n, i) { Di.call(this), this.type = "PlaneGeometry", this.parameters = { width: t, height: e, widthSegments: n, heightSegments: i }, this.fromBufferGeometry(new cr(t, e, n, i)), this.mergeVertices() } function cr(t, e, n, i) { rr.call(this), this.type = "PlaneBufferGeometry", this.parameters = { width: t, height: e, widthSegments: n, heightSegments: i }; for (var r = (t = t || 1) / 2, a = (e = e || 1) / 2, o = Math.floor(n) || 1, s = Math.floor(i) || 1, c = o + 1, h = s + 1, l = t / o, u = e / s, p = [], d = [], f = [], m = [], g = 0; g < h; g++)for (var v = g * u - a, y = 0; y < c; y++) { var x = y * l - r; d.push(x, -v, 0), f.push(0, 0, 1), m.push(y / o), m.push(1 - g / s) } for (g = 0; g < s; g++)for (y = 0; y < o; y++) { var b = y + c * g, w = y + c * (g + 1), _ = y + 1 + c * (g + 1), M = y + 1 + c * g; p.push(b, w, M), p.push(w, _, M) } this.setIndex(p), this.addAttribute("position", new ki(d, 3)), this.addAttribute("normal", new ki(f, 3)), this.addAttribute("uv", new ki(m, 2)) } rr.prototype = Object.assign(Object.create(e.prototype), { constructor: rr, isBufferGeometry: !0, getIndex: function () { return this.index }, setIndex: function (t) { Array.isArray(t) ? this.index = new (65535 < qi(t) ? Vi : Fi)(t, 1) : this.index = t }, addAttribute: function (t, e) { return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? ("index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e)) : this.attributes[t] = e, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(t, new Ni(e, arguments[2]))) }, getAttribute: function (t) { return this.attributes[t] }, removeAttribute: function (t) { return delete this.attributes[t], this }, addGroup: function (t, e, n) { this.groups.push({ start: t, count: e, materialIndex: void 0 !== n ? n : 0 }) }, clearGroups: function () { this.groups = [] }, setDrawRange: function (t, e) { this.drawRange.start = t, this.drawRange.count = e }, applyMatrix: function (t) { var e = this.attributes.position; void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0); e = this.attributes.normal; void 0 !== e && ((new Xe).getNormalMatrix(t).applyToBufferAttribute(e), e.needsUpdate = !0); e = this.attributes.tangent; return void 0 !== e && ((new Xe).getNormalMatrix(t).applyToBufferAttribute(e), e.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this }, rotateX: (nr = new je, function (t) { return nr.makeRotationX(t), this.applyMatrix(nr), this }), rotateY: (er = new je, function (t) { return er.makeRotationY(t), this.applyMatrix(er), this }), rotateZ: (tr = new je, function (t) { return tr.makeRotationZ(t), this.applyMatrix(tr), this }), translate: ($i = new je, function (t, e, n) { return $i.makeTranslation(t, e, n), this.applyMatrix($i), this }), scale: (Ki = new je, function (t, e, n) { return Ki.makeScale(t, e, n), this.applyMatrix(Ki), this }), lookAt: (Qi = new Si, function (t) { Qi.lookAt(t), Qi.updateMatrix(), this.applyMatrix(Qi.matrix) }), center: (Zi = new qe, function () { return this.computeBoundingBox(), this.boundingBox.getCenter(Zi).negate(), this.translate(Zi.x, Zi.y, Zi.z), this }), setFromObject: function (t) { var e, n, i = t.geometry; return t.isPoints || t.isLine ? (e = new ki(3 * i.vertices.length, 3), n = new ki(3 * i.colors.length, 3), this.addAttribute("position", e.copyVector3sArray(i.vertices)), this.addAttribute("color", n.copyColorsArray(i.colors)), i.lineDistances && i.lineDistances.length === i.vertices.length && (n = new ki(i.lineDistances.length, 1), this.addAttribute("lineDistance", n.copyArray(i.lineDistances))), null !== i.boundingSphere && (this.boundingSphere = i.boundingSphere.clone()), null !== i.boundingBox && (this.boundingBox = i.boundingBox.clone())) : t.isMesh && i && i.isGeometry && this.fromGeometry(i), this }, setFromPoints: function (t) { for (var e = [], n = 0, i = t.length; n < i; n++) { var r = t[n]; e.push(r.x, r.y, r.z || 0) } return this.addAttribute("position", new ki(e, 3)), this }, updateFromObject: function (t) { var e, n = t.geometry; if (t.isMesh) { var i = n.__directGeometry; if (!0 === n.elementsNeedUpdate && (i = void 0, n.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(n); i.verticesNeedUpdate = n.verticesNeedUpdate, i.normalsNeedUpdate = n.normalsNeedUpdate, i.colorsNeedUpdate = n.colorsNeedUpdate, i.uvsNeedUpdate = n.uvsNeedUpdate, i.groupsNeedUpdate = n.groupsNeedUpdate, n.verticesNeedUpdate = !1, n.normalsNeedUpdate = !1, n.colorsNeedUpdate = !1, n.uvsNeedUpdate = !1, n.groupsNeedUpdate = !1, n = i } return !0 === n.verticesNeedUpdate && (void 0 !== (e = this.attributes.position) && (e.copyVector3sArray(n.vertices), e.needsUpdate = !0), n.verticesNeedUpdate = !1), !0 === n.normalsNeedUpdate && (void 0 !== (e = this.attributes.normal) && (e.copyVector3sArray(n.normals), e.needsUpdate = !0), n.normalsNeedUpdate = !1), !0 === n.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e.copyColorsArray(n.colors), e.needsUpdate = !0), n.colorsNeedUpdate = !1), n.uvsNeedUpdate && (void 0 !== (e = this.attributes.uv) && (e.copyVector2sArray(n.uvs), e.needsUpdate = !0), n.uvsNeedUpdate = !1), n.lineDistancesNeedUpdate && (void 0 !== (e = this.attributes.lineDistance) && (e.copyArray(n.lineDistances), e.needsUpdate = !0), n.lineDistancesNeedUpdate = !1), n.groupsNeedUpdate && (n.computeGroups(t.geometry), this.groups = n.groups, n.groupsNeedUpdate = !1), this }, fromGeometry: function (t) { return t.__directGeometry = (new Wi).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry) }, fromDirectGeometry: function (t) { var e, n, i, r, a = new Float32Array(3 * t.vertices.length); for (i in this.addAttribute("position", new Ni(a, 3).copyVector3sArray(t.vertices)), 0 < t.normals.length && (e = new Float32Array(3 * t.normals.length), this.addAttribute("normal", new Ni(e, 3).copyVector3sArray(t.normals))), 0 < t.colors.length && (e = new Float32Array(3 * t.colors.length), this.addAttribute("color", new Ni(e, 3).copyColorsArray(t.colors))), 0 < t.uvs.length && (n = new Float32Array(2 * t.uvs.length), this.addAttribute("uv", new Ni(n, 2).copyVector2sArray(t.uvs))), 0 < t.uvs2.length && (n = new Float32Array(2 * t.uvs2.length), this.addAttribute("uv2", new Ni(n, 2).copyVector2sArray(t.uvs2))), this.groups = t.groups, t.morphTargets) { for (var o = [], s = t.morphTargets[i], c = 0, h = s.length; c < h; c++) { var l = s[c], u = new ki(3 * l.data.length, 3); u.name = l.name, o.push(u.copyVector3sArray(l.data)) } this.morphAttributes[i] = o } return 0 < t.skinIndices.length && (r = new ki(4 * t.skinIndices.length, 4), this.addAttribute("skinIndex", r.copyVector4sArray(t.skinIndices))), 0 < t.skinWeights.length && (r = new ki(4 * t.skinWeights.length, 4), this.addAttribute("skinWeight", r.copyVector4sArray(t.skinWeights))), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new In); var t = this.attributes.position; void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) }, computeBoundingSphere: (Yi = new In, Ji = new qe, function () { null === this.boundingSphere && (this.boundingSphere = new Bn); var t = this.attributes.position; if (t) { var e = this.boundingSphere.center; Yi.setFromBufferAttribute(t), Yi.getCenter(e); for (var n = 0, i = 0, r = t.count; i < r; i++)Ji.x = t.getX(i), Ji.y = t.getY(i), Ji.z = t.getZ(i), n = Math.max(n, e.distanceToSquared(Ji)); this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } }), computeFaceNormals: function () { }, computeVertexNormals: function () { var t = this.index, e = this.attributes; if (e.position) { var n = e.position.array; if (void 0 === e.normal) this.addAttribute("normal", new Ni(new Float32Array(n.length), 3)); else for (var i = e.normal.array, r = 0, a = i.length; r < a; r++)i[r] = 0; var o, s, c, h = e.normal.array, l = new qe, u = new qe, p = new qe, d = new qe, f = new qe; if (t) for (var m = t.array, r = 0, a = t.count; r < a; r += 3)o = 3 * m[r + 0], s = 3 * m[r + 1], c = 3 * m[r + 2], l.fromArray(n, o), u.fromArray(n, s), p.fromArray(n, c), d.subVectors(p, u), f.subVectors(l, u), d.cross(f), h[o] += d.x, h[1 + o] += d.y, h[2 + o] += d.z, h[s] += d.x, h[1 + s] += d.y, h[2 + s] += d.z, h[c] += d.x, h[1 + c] += d.y, h[2 + c] += d.z; else for (r = 0, a = n.length; r < a; r += 9)l.fromArray(n, r), u.fromArray(n, r + 3), p.fromArray(n, r + 6), d.subVectors(p, u), f.subVectors(l, u), d.cross(f), h[r] = d.x, h[r + 1] = d.y, h[r + 2] = d.z, h[r + 3] = d.x, h[r + 4] = d.y, h[r + 5] = d.z, h[r + 6] = d.x, h[r + 7] = d.y, h[r + 8] = d.z; this.normalizeNormals(), e.normal.needsUpdate = !0 } }, merge: function (t, e) { if (t && t.isBufferGeometry) { void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.")); var n, i = this.attributes; for (n in i) if (void 0 !== t.attributes[n]) for (var r = i[n].array, a = t.attributes[n], o = a.array, s = 0, c = a.itemSize * e; s < o.length; s++, c++)r[c] = o[s]; return this } console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t) }, normalizeNormals: (Xi = new qe, function () { for (var t = this.attributes.normal, e = 0, n = t.count; e < n; e++)Xi.x = t.getX(e), Xi.y = t.getY(e), Xi.z = t.getZ(e), Xi.normalize(), t.setXYZ(e, Xi.x, Xi.y, Xi.z) }), toNonIndexed: function () { function t(t, e) { for (var n = t.array, i = t.itemSize, r = new n.constructor(e.length * i), a = 0, o = 0, s = 0, c = e.length; s < c; s++) { a = e[s] * i; for (var h = 0; h < i; h++)r[o++] = n[a++] } return new Ni(r, i) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this; var e, n = new rr, i = this.index.array, r = this.attributes; for (e in r) { var a = t(r[e], i); n.addAttribute(e, a) } var o = this.morphAttributes; for (e in o) { for (var s = [], c = o[e], h = 0, l = c.length; h < l; h++) { a = t(c[h], i); s.push(a) } n.morphAttributes[e] = s } for (var u = this.groups, h = 0, p = u.length; h < p; h++) { var d = u[h]; n.addGroup(d.start, d.count, d.materialIndex) } return n }, toJSON: function () { var t = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), 0 < Object.keys(this.userData).length && (t.userData = this.userData), void 0 !== this.parameters) { var e = this.parameters; for (a in e) void 0 !== e[a] && (t[a] = e[a]); return t } t.data = { attributes: {} }; var n = this.index; null !== n && (t.data.index = { type: n.array.constructor.name, array: Array.prototype.slice.call(n.array) }); var i = this.attributes; for (a in i) { var r = { itemSize: (p = i[a]).itemSize, type: p.array.constructor.name, array: Array.prototype.slice.call(p.array), normalized: p.normalized }; "" !== p.name && (r.name = p.name), t.data.attributes[a] = r } var a, o = {}, s = !1; for (a in this.morphAttributes) { for (var c = this.morphAttributes[a], h = [], l = 0, u = c.length; l < u; l++) { var p, r = { itemSize: (p = c[l]).itemSize, type: p.array.constructor.name, array: Array.prototype.slice.call(p.array), normalized: p.normalized }; "" !== p.name && (r.name = p.name), h.push(r) } 0 < h.length && (o[a] = h, s = !0) } s && (t.data.morphAttributes = o); n = this.groups; 0 < n.length && (t.data.groups = JSON.parse(JSON.stringify(n))); n = this.boundingSphere; return null !== n && (t.data.boundingSphere = { center: n.center.toArray(), radius: n.radius }), t }, clone: function () { return (new rr).copy(this) }, copy: function (t) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name; var e = t.index; null !== e && this.setIndex(e.clone()); var n = t.attributes; for (var i in n) { var r = n[i]; this.addAttribute(i, r.clone()) } var a = t.morphAttributes; for (i in a) { for (var o = [], s = a[i], c = 0, h = s.length; c < h; c++)o.push(s[c].clone()); this.morphAttributes[i] = o } var l = t.groups; for (c = 0, h = l.length; c < h; c++) { var u = l[c]; this.addGroup(u.start, u.count, u.materialIndex) } e = t.boundingBox; null !== e && (this.boundingBox = e.clone()); e = t.boundingSphere; return null !== e && (this.boundingSphere = e.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), (ar.prototype = Object.create(Di.prototype)).constructor = ar, (or.prototype = Object.create(rr.prototype)).constructor = or, (sr.prototype = Object.create(Di.prototype)).constructor = sr, (cr.prototype = Object.create(rr.prototype)).constructor = cr; var hr = 0; function lr() { Object.defineProperty(this, "id", { value: hr++ }), this.uuid = Ve.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = Z, this.side = O, this.flatShading = !1, this.vertexTangents = !1, this.vertexColors = E, this.opacity = 1, this.transparent = !1, this.blendSrc = z, this.blendDst = U, this.blendEquation = et, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = at, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0 } lr.prototype = Object.assign(Object.create(e.prototype), { constructor: lr, isMaterial: !0, onBeforeCompile: function () { }, setValues: function (t) { if (void 0 !== t) for (var e in t) { var n, i = t[e]; void 0 !== i ? "shading" !== e ? void 0 !== (n = this[e]) ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.") : (console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === i) : console.warn("THREE.Material: '" + e + "' parameter is undefined.") } }, toJSON: function (t) { var e = void 0 === t || "string" == typeof t; e && (t = { textures: {}, images: {} }); var n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; function i(t) { var e, n = []; for (e in t) { var i = t[e]; delete i.metadata, n.push(i) } return n } return n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Z && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== O && (n.side = this.side), this.vertexColors !== E && (n.vertexColors = this.vertexColors), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), 0 < this.alphaTest && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e && (e = i(t.textures), t = i(t.images), 0 < e.length && (n.textures = e), 0 < t.length && (n.images = t)), n }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection; var e = t.clippingPlanes, n = null; if (null !== e) for (var i = e.length, n = new Array(i), r = 0; r !== i; ++r)n[r] = e[r].clone(); return this.clippingPlanes = n, this.shadowSide = t.shadowSide, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); var ur, pr, dr, fr, mr, gr, vr, yr, xr, br, wr, _r, Mr, Er, Sr, Tr, Ar, Lr, Rr, Pr, Cr, Or, Ir, Dr, Nr, Br, zr, Ur, Gr, Fr, Hr, Vr, kr, jr, Wr, qr, Xr, Yr, Jr, Zr = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", Qr = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"; function Kr(t) { lr.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = Zr, this.fragmentShader = Qr, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t)) } function $r(t, e) { this.origin = void 0 !== t ? t : new qe, this.direction = void 0 !== e ? e : new qe } function ta(t, e, n) { this.a = void 0 !== t ? t : new qe, this.b = void 0 !== e ? e : new qe, this.c = void 0 !== n ? n : new qe } function ea(t) { lr.call(this), this.type = "MeshBasicMaterial", this.color = new Xn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = j, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(t) } function na(t, e) { Si.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new rr, this.material = void 0 !== e ? e : new ea({ color: 16777215 * Math.random() }), this.drawMode = Pe, this.updateMorphTargets() } function ia(t, e, n, i, r, a, o, s) { e = e.side === _t ? i.intersectTriangle(o, a, r, !0, s) : i.intersectTriangle(r, a, o, e.side !== Y, s); if (null === e) return null; Jr.copy(s), Jr.applyMatrix4(t.matrixWorld); s = n.ray.origin.distanceTo(Jr); return s < n.near || s > n.far ? null : { distance: s, point: Jr.clone(), object: t } } function ra(t, e, n, i, r, a, o, s, c) { Gr.fromBufferAttribute(r, o), Fr.fromBufferAttribute(r, s), Hr.fromBufferAttribute(r, c); i = ia(t, e, n, i, Gr, Fr, Hr, Yr); return i && (a && (Wr.fromBufferAttribute(a, o), qr.fromBufferAttribute(a, s), Xr.fromBufferAttribute(a, c), i.uv = ta.getUV(Yr, Gr, Fr, Hr, Wr, qr, Xr, new ke)), c = new ii(o, s, c), ta.getNormal(Gr, Fr, Hr, c.normal), i.face = c), i } function aa(r, n, a, i) { var o, s, c = new Xn(0), h = 0, l = null, u = 0; function p(t, e) { n.buffers.color.setClear(t.r, t.g, t.b, e, i) } return { getClearColor: function () { return c }, setClearColor: function (t, e) { c.set(t), p(c, h = void 0 !== e ? e : 1) }, getClearAlpha: function () { return h }, setClearAlpha: function (t) { p(c, h = t) }, render: function (t, e, n, i) { null === (e = e.background) ? (p(c, h), l = null, u = 0) : e && e.isColor && (p(e, 1), i = !0, l = null, u = 0), (r.autoClear || i) && r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil), e && (e.isCubeTexture || e.isWebGLRenderTargetCube) ? (void 0 === s && ((s = new na(new or(1, 1, 1), new Kr({ type: "BackgroundCubeMaterial", uniforms: Fn(ti.cube.uniforms), vertexShader: ti.cube.vertexShader, fragmentShader: ti.cube.fragmentShader, side: _t, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.removeAttribute("normal"), s.geometry.removeAttribute("uv"), s.onBeforeRender = function (t, e, n) { this.matrixWorld.copyPosition(n.matrixWorld) }, Object.defineProperty(s.material, "map", { get: function () { return this.uniforms.tCube.value } }), a.update(s)), i = e.isWebGLRenderTargetCube ? e.texture : e, s.material.uniforms.tCube.value = i, s.material.uniforms.tFlip.value = e.isWebGLRenderTargetCube ? 1 : -1, l === e && u === i.version || (s.material.needsUpdate = !0, l = e, u = i.version), t.unshift(s, s.geometry, s.material, 0, 0, null)) : e && e.isTexture && (void 0 === o && ((o = new na(new cr(2, 2), new Kr({ type: "BackgroundMaterial", uniforms: Fn(ti.background.uniforms), vertexShader: ti.background.vertexShader, fragmentShader: ti.background.fragmentShader, side: O, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.removeAttribute("normal"), Object.defineProperty(o.material, "map", { get: function () { return this.uniforms.t2D.value } }), a.update(o)), !0 === (o.material.uniforms.t2D.value = e).matrixAutoUpdate && e.updateMatrix(), o.material.uniforms.uvTransform.value.copy(e.matrix), l === e && u === e.version || (o.material.needsUpdate = !0, u = (l = e).version), t.unshift(o, o.geometry, o.material, 0, 0, null)) } } } function oa(r, a, o, s) { var c; this.setMode = function (t) { c = t }, this.render = function (t, e) { r.drawArrays(c, t, e), o.update(e, c) }, this.renderInstances = function (t, e, n) { var i; if (s.isWebGL2) i = r; else if (null === (i = a.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); i[s.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](c, e, n, t.maxInstancedCount), o.update(n, c, t.maxInstancedCount) } } function sa(e, n, t) { var i; function r(t) { if ("highp" === t) { if (0 < e.getShaderPrecisionFormat(35633, 36338).precision && 0 < e.getShaderPrecisionFormat(35632, 36338).precision) return "highp"; t = "mediump" } return "mediump" === t && 0 < e.getShaderPrecisionFormat(35633, 36337).precision && 0 < e.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp" } var a = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext, o = void 0 !== t.precision ? t.precision : "highp", s = r(o); s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."), o = s); var c = !0 === t.logarithmicDepthBuffer, h = e.getParameter(34930), l = e.getParameter(35660), u = e.getParameter(3379), p = e.getParameter(34076), d = e.getParameter(34921), f = e.getParameter(36347), m = e.getParameter(36348), g = e.getParameter(36349), s = 0 < l, t = a || !!n.get("OES_texture_float"); return { isWebGL2: a, getMaxAnisotropy: function () { if (void 0 !== i) return i; var t = n.get("EXT_texture_filter_anisotropic"); return i = null !== t ? e.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0 }, getMaxPrecision: r, precision: o, logarithmicDepthBuffer: c, maxTextures: h, maxVertexTextures: l, maxTextureSize: u, maxCubemapSize: p, maxAttributes: d, maxVertexUniforms: f, maxVaryings: m, maxFragmentUniforms: g, vertexTextures: s, floatFragmentTextures: t, floatVertexTextures: s && t, maxSamples: a ? e.getParameter(36183) : 0 } } function ca() { var h = this, l = null, u = 0, p = !1, d = !1, f = new zn, m = new Xe, g = { value: null, needsUpdate: !1 }; function v() { g.value !== l && (g.value = l, g.needsUpdate = 0 < u), h.numPlanes = u, h.numIntersection = 0 } function y(t, e, n, i) { var r = null !== t ? t.length : 0, a = null; if (0 !== r) { if (a = g.value, !0 !== i || null === a) { var i = n + 4 * r, o = e.matrixWorldInverse; m.getNormalMatrix(o), (null === a || a.length < i) && (a = new Float32Array(i)); for (var s = 0, c = n; s !== r; ++s, c += 4)f.copy(t[s]).applyMatrix4(o, m), f.normal.toArray(a, c), a[c + 3] = f.constant } g.value = a, g.needsUpdate = !0 } return h.numPlanes = r, a } this.uniform = g, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, e, n) { var i = 0 !== t.length || e || 0 !== u || p; return p = e, l = y(t, n, 0), u = t.length, i }, this.beginShadows = function () { d = !0, y(null) }, this.endShadows = function () { d = !1, v() }, this.setState = function (t, e, n, i, r, a) { if (!p || null === t || 0 === t.length || d && !n) d ? y(null) : v(); else { var n = d ? 0 : u, o = 4 * n, s = r.clippingState || null; g.value = s, s = y(t, i, o, a); for (var c = 0; c !== o; ++c)s[c] = l[c]; r.clippingState = s, this.numIntersection = e ? this.numPlanes : 0, this.numPlanes += n } } } function ha(n) { var i = {}; return { get: function (t) { if (void 0 !== i[t]) return i[t]; var e; switch (t) { case "WEBGL_depth_texture": e = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": e = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": e = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": e = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: e = n.getExtension(t) }return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), i[t] = e } } } function la(t, u, i) { var r = {}, p = {}; function a(t) { var e, t = t.target, n = r[t.id]; for (e in null !== n.index && u.remove(n.index), n.attributes) u.remove(n.attributes[e]); t.removeEventListener("dispose", a), delete r[t.id]; t = p[n.id]; t && (u.remove(t), delete p[n.id]), i.memory.geometries-- } return { get: function (t, e) { var n = r[e.id]; return n || (e.addEventListener("dispose", a), e.isBufferGeometry ? n = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new rr).setFromObject(t)), n = e._bufferGeometry), r[e.id] = n, i.memory.geometries++, n) }, update: function (t) { var e = t.index, n = t.attributes; for (i in null !== e && u.update(e, 34963), n) u.update(n[i], 34962); var i, r = t.morphAttributes; for (i in r) for (var a = r[i], o = 0, s = a.length; o < s; o++)u.update(a[o], 34962) }, getWireframeAttribute: function (t) { var e = p[t.id]; if (e) return e; var n = [], i = t.index, r = t.attributes; if (null !== i) for (var a = 0, o = (l = i.array).length; a < o; a += 3) { var s = l[a + 0], c = l[a + 1], h = l[a + 2]; n.push(s, c, c, h, h, s) } else for (var l, a = 0, o = (l = r.position.array).length / 3 - 1; a < o; a += 3) { s = a + 0, c = a + 1, h = a + 2; n.push(s, c, c, h, h, s) } return e = new (65535 < qi(n) ? Vi : Fi)(n, 1), u.update(e, 34963), p[t.id] = e } } } function ua(r, a, o, s) { var c, h, l; this.setMode = function (t) { c = t }, this.setIndex = function (t) { h = t.type, l = t.bytesPerElement }, this.render = function (t, e) { r.drawElements(c, e, h, t * l), o.update(e, c) }, this.renderInstances = function (t, e, n) { var i; if (s.isWebGL2) i = r; else if (null === (i = a.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); i[s.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](c, n, h, e * l, t.maxInstancedCount), o.update(n, c, t.maxInstancedCount) } } function pa(t) { var i = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: i, programs: null, autoReset: !0, reset: function () { i.frame++, i.calls = 0, i.triangles = 0, i.points = 0, i.lines = 0 }, update: function (t, e, n) { switch (n = n || 1, i.calls++, e) { case 4: i.triangles += n * (t / 3); break; case 5: case 6: i.triangles += n * (t - 2); break; case 1: i.lines += n * (t / 2); break; case 3: i.lines += n * (t - 1); break; case 2: i.lines += n * t; break; case 0: i.points += n * t; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", e) } } } } function da(t, e) { return Math.abs(e[1]) - Math.abs(t[1]) } function fa(d) { var f = {}, m = new Float32Array(8); return { update: function (t, e, n, i) { var r = t.morphTargetInfluences, a = r.length, o = f[e.id]; if (void 0 === o) { o = []; for (var s = 0; s < a; s++)o[s] = [s, 0]; f[e.id] = o } for (var c = n.morphTargets && e.morphAttributes.position, h = n.morphNormals && e.morphAttributes.normal, s = 0; s < a; s++)0 !== (l = o[s])[1] && (c && e.removeAttribute("morphTarget" + s), h && e.removeAttribute("morphNormal" + s)); for (s = 0; s < a; s++)(l = o[s])[0] = s, l[1] = r[s]; o.sort(da); for (var l, s = 0; s < 8; s++) { if (l = o[s]) { var u = l[0], p = l[1]; if (p) { c && e.addAttribute("morphTarget" + s, c[u]), h && e.addAttribute("morphNormal" + s, h[u]), m[s] = p; continue } } m[s] = 0 } i.getUniforms().setValue(d, "morphTargetInfluences", m) } } } function ma(r, a) { var o = {}; return { update: function (t) { var e = a.render.frame, n = t.geometry, i = r.get(t, n); return o[i.id] !== e && (n.isGeometry && i.updateFromObject(t), r.update(i), o[i.id] = e), i }, dispose: function () { o = {} } } } function ga(t, e, n, i, r, a, o, s, c, h) { An.call(this, t = void 0 !== t ? t : [], e = void 0 !== e ? e : vt, n, i, r, a, o = void 0 !== o ? o : Yt, s, c, h), this.flipY = !1 } function va(t, e, n, i) { An.call(this, null), this.image = { data: t, width: e, height: n, depth: i }, this.magFilter = Rt, this.minFilter = Rt, this.wrapR = At, this.generateMipmaps = !1, this.flipY = !1 } ((Kr.prototype = Object.create(lr.prototype)).constructor = Kr).prototype.isShaderMaterial = !0, Kr.prototype.copy = function (t) { return lr.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Fn(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this }, Kr.prototype.toJSON = function (t) { var e, n = lr.prototype.toJSON.call(this, t); for (e in n.uniforms = {}, this.uniforms) { var i = this.uniforms[e].value; i && i.isTexture ? n.uniforms[e] = { type: "t", value: i.toJSON(t).uuid } : i && i.isColor ? n.uniforms[e] = { type: "c", value: i.getHex() } : i && i.isVector2 ? n.uniforms[e] = { type: "v2", value: i.toArray() } : i && i.isVector3 ? n.uniforms[e] = { type: "v3", value: i.toArray() } : i && i.isVector4 ? n.uniforms[e] = { type: "v4", value: i.toArray() } : i && i.isMatrix3 ? n.uniforms[e] = { type: "m3", value: i.toArray() } : i && i.isMatrix4 ? n.uniforms[e] = { type: "m4", value: i.toArray() } : n.uniforms[e] = { value: i } } 0 < Object.keys(this.defines).length && (n.defines = this.defines), n.vertexShader = this.vertexShader, n.fragmentShader = this.fragmentShader; var r, a = {}; for (r in this.extensions) !0 === this.extensions[r] && (a[r] = !0); return 0 < Object.keys(a).length && (n.extensions = a), n }, Object.assign($r.prototype, { set: function (t, e) { return this.origin.copy(t), this.direction.copy(e), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.origin.copy(t.origin), this.direction.copy(t.direction), this }, at: function (t, e) { return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new qe), e.copy(this.direction).multiplyScalar(t).add(this.origin) }, lookAt: function (t) { return this.direction.copy(t).sub(this.origin).normalize(), this }, recast: (wr = new qe, function (t) { return this.origin.copy(this.at(t, wr)), this }), closestPointToPoint: function (t, e) { void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new qe), e.subVectors(t, this.origin); t = e.dot(this.direction); return t < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(t).add(this.origin) }, distanceToPoint: function (t) { return Math.sqrt(this.distanceSqToPoint(t)) }, distanceSqToPoint: (br = new qe, function (t) { var e = br.subVectors(t, this.origin).dot(this.direction); return e < 0 ? this.origin.distanceToSquared(t) : (br.copy(this.direction).multiplyScalar(e).add(this.origin), br.distanceToSquared(t)) }), distanceSqToSegment: (vr = new qe, yr = new qe, xr = new qe, function (t, e, n, i) { vr.copy(t).add(e).multiplyScalar(.5), yr.copy(e).sub(t).normalize(), xr.copy(this.origin).sub(vr); var r, a, o = .5 * t.distanceTo(e), s = -this.direction.dot(yr), c = xr.dot(this.direction), h = -xr.dot(yr), l = xr.lengthSq(), t = Math.abs(1 - s * s); return l = 0 < t ? (a = s * c - h, e = o * t, 0 <= (r = s * h - c) ? -e <= a ? a <= e ? (r *= t = 1 / t) * (r + s * (a *= t) + 2 * c) + a * (s * r + a + 2 * h) + l : (a = o, -(r = Math.max(0, -(s * a + c))) * r + a * (a + 2 * h) + l) : (a = -o, -(r = Math.max(0, -(s * a + c))) * r + a * (a + 2 * h) + l) : a <= -e ? -(r = Math.max(0, -(-s * o + c))) * r + (a = 0 < r ? -o : Math.min(Math.max(-o, -h), o)) * (a + 2 * h) + l : a <= e ? (r = 0, (a = Math.min(Math.max(-o, -h), o)) * (a + 2 * h) + l) : -(r = Math.max(0, -(s * o + c))) * r + (a = 0 < r ? o : Math.min(Math.max(-o, -h), o)) * (a + 2 * h) + l) : (a = 0 < s ? -o : o, -(r = Math.max(0, -(s * a + c))) * r + a * (a + 2 * h) + l), n && n.copy(this.direction).multiplyScalar(r).add(this.origin), i && i.copy(yr).multiplyScalar(a).add(vr), l }), intersectSphere: (gr = new qe, function (t, e) { gr.subVectors(t.center, this.origin); var n = gr.dot(this.direction), i = gr.dot(gr) - n * n, t = t.radius * t.radius; if (t < i) return null; t = Math.sqrt(t - i), i = n - t, t = n + t; return i < 0 && t < 0 ? null : i < 0 ? this.at(t, e) : this.at(i, e) }), intersectsSphere: function (t) { return this.distanceSqToPoint(t.center) <= t.radius * t.radius }, distanceToPlane: function (t) { var e = t.normal.dot(this.direction); if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null; e = -(this.origin.dot(t.normal) + t.constant) / e; return 0 <= e ? e : null }, intersectPlane: function (t, e) { t = this.distanceToPlane(t); return null === t ? null : this.at(t, e) }, intersectsPlane: function (t) { var e = t.distanceToPoint(this.origin); return 0 === e || t.normal.dot(this.direction) * e < 0 }, intersectBox: function (t, e) { var n, i, r, a = 1 / this.direction.x, o = 1 / this.direction.y, s = 1 / this.direction.z, c = this.origin, a = 0 <= a ? (n = (t.min.x - c.x) * a, (t.max.x - c.x) * a) : (n = (t.max.x - c.x) * a, (t.min.x - c.x) * a), o = 0 <= o ? (i = (t.min.y - c.y) * o, (t.max.y - c.y) * o) : (i = (t.max.y - c.y) * o, (t.min.y - c.y) * o); return o < n || a < i ? null : ((n < i || n != n) && (n = i), (o < a || a != a) && (a = o), (s = 0 <= s ? (r = (t.min.z - c.z) * s, (t.max.z - c.z) * s) : (r = (t.max.z - c.z) * s, (t.min.z - c.z) * s)) < n || a < r ? null : ((n < r || n != n) && (n = r), (s < a || a != a) && (a = s), a < 0 ? null : this.at(0 <= n ? n : a, e))) }, intersectsBox: (mr = new qe, function (t) { return null !== this.intersectBox(t, mr) }), intersectTriangle: (ur = new qe, pr = new qe, dr = new qe, fr = new qe, function (t, e, n, i, r) { pr.subVectors(e, t), dr.subVectors(n, t), fr.crossVectors(pr, dr); n = this.direction.dot(fr); if (0 < n) { if (i) return null; a = 1 } else { if (!(n < 0)) return null; a = -1, n = -n } ur.subVectors(this.origin, t); i = a * this.direction.dot(dr.crossVectors(ur, dr)); if (i < 0) return null; t = a * this.direction.dot(pr.cross(ur)); if (t < 0) return null; if (n < i + t) return null; var a = -a * ur.dot(fr); return a < 0 ? null : this.at(a / n, r) }), applyMatrix4: function (t) { return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this }, equals: function (t) { return t.origin.equals(this.origin) && t.direction.equals(this.direction) } }), Object.assign(ta, { getNormal: (Ar = new qe, function (t, e, n, i) { void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"), i = new qe), i.subVectors(n, e), Ar.subVectors(t, e), i.cross(Ar); e = i.lengthSq(); return 0 < e ? i.multiplyScalar(1 / Math.sqrt(e)) : i.set(0, 0, 0) }), getBarycoord: (Er = new qe, Sr = new qe, Tr = new qe, function (t, e, n, i, r) { Er.subVectors(i, e), Sr.subVectors(n, e), Tr.subVectors(t, e); var a = Er.dot(Er), o = Er.dot(Sr), i = Er.dot(Tr), n = Sr.dot(Sr), t = Sr.dot(Tr), e = a * n - o * o; if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), r = new qe), 0 == e) return r.set(-2, -1, -1); e = 1 / e, n = (n * i - o * t) * e, e *= a * t - o * i; return r.set(1 - n - e, e, n) }), containsPoint: (Mr = new qe, function (t, e, n, i) { return ta.getBarycoord(t, e, n, i, Mr), 0 <= Mr.x && 0 <= Mr.y && Mr.x + Mr.y <= 1 }), getUV: (_r = new qe, function (t, e, n, i, r, a, o, s) { return this.getBarycoord(t, e, n, i, _r), s.set(0, 0), s.addScaledVector(r, _r.x), s.addScaledVector(a, _r.y), s.addScaledVector(o, _r.z), s }) }), Object.assign(ta.prototype, { set: function (t, e, n) { return this.a.copy(t), this.b.copy(e), this.c.copy(n), this }, setFromPointsAndIndices: function (t, e, n, i) { return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this }, getArea: (Dr = new qe, Nr = new qe, function () { return Dr.subVectors(this.c, this.b), Nr.subVectors(this.a, this.b), .5 * Dr.cross(Nr).length() }), getMidpoint: function (t) { return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new qe), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) }, getNormal: function (t) { return ta.getNormal(this.a, this.b, this.c, t) }, getPlane: function (t) { return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new qe), t.setFromCoplanarPoints(this.a, this.b, this.c) }, getBarycoord: function (t, e) { return ta.getBarycoord(t, this.a, this.b, this.c, e) }, containsPoint: function (t) { return ta.containsPoint(t, this.a, this.b, this.c) }, getUV: function (t, e, n, i, r) { return ta.getUV(t, this.a, this.b, this.c, e, n, i, r) }, intersectsBox: function (t) { return t.intersectsTriangle(this) }, closestPointToPoint: (Lr = new qe, Rr = new qe, Pr = new qe, Cr = new qe, Or = new qe, Ir = new qe, function (t, e) { void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new qe); var n = this.a, i = this.b, r = this.c; Lr.subVectors(i, n), Rr.subVectors(r, n), Cr.subVectors(t, n); var a = Lr.dot(Cr), o = Rr.dot(Cr); if (a <= 0 && o <= 0) return e.copy(n); Or.subVectors(t, i); var s = Lr.dot(Or), c = Rr.dot(Or); if (0 <= s && c <= s) return e.copy(i); var h = a * c - s * o; if (h <= 0 && 0 <= a && s <= 0) return u = a / (a - s), e.copy(n).addScaledVector(Lr, u); Ir.subVectors(t, r); var l = Lr.dot(Ir), t = Rr.dot(Ir); if (0 <= t && l <= t) return e.copy(r); a = l * o - a * t; if (a <= 0 && 0 <= o && t <= 0) return p = o / (o - t), e.copy(n).addScaledVector(Rr, p); o = s * t - l * c; if (o <= 0 && 0 <= c - s && 0 <= l - t) return Pr.subVectors(r, i), p = (c - s) / (c - s + (l - t)), e.copy(i).addScaledVector(Pr, p); var o = 1 / (o + a + h), u = a * o, p = h * o; return e.copy(n).addScaledVector(Lr, u).addScaledVector(Rr, p) }), equals: function (t) { return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c) } }), ((ea.prototype = Object.create(lr.prototype)).constructor = ea).prototype.isMeshBasicMaterial = !0, ea.prototype.copy = function (t) { return lr.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this }, na.prototype = Object.assign(Object.create(Si.prototype), { constructor: na, isMesh: !0, setDrawMode: function (t) { this.drawMode = t }, copy: function (t) { return Si.prototype.copy.call(this, t), this.drawMode = t.drawMode, void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this }, updateMorphTargets: function () { var t, e, n, i = this.geometry; if (i.isBufferGeometry) { var r = i.morphAttributes, a = Object.keys(r); if (0 < a.length) { var o = r[a[0]]; if (void 0 !== o) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = o.length; t < e; t++)n = o[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t } } else { i = i.morphTargets; void 0 !== i && 0 < i.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } }, raycast: (Br = new je, zr = new $r, Ur = new Bn, Gr = new qe, Fr = new qe, Hr = new qe, Vr = new qe, kr = new qe, jr = new qe, Wr = new ke, qr = new ke, Xr = new ke, Yr = new qe, Jr = new qe, function (t, e) { var n = this.geometry, i = this.material, r = this.matrixWorld; if (void 0 !== i && (null === n.boundingSphere && n.computeBoundingSphere(), Ur.copy(n.boundingSphere), Ur.applyMatrix4(r), !1 !== t.ray.intersectsSphere(Ur) && (Br.getInverse(r), zr.copy(t.ray).applyMatrix4(Br), null === n.boundingBox || !1 !== zr.intersectsBox(n.boundingBox)))) if (n.isBufferGeometry) { var a, o, s, c, h, l, u, p, d, f = n.index, m = n.attributes.position, g = n.attributes.uv, v = n.groups, y = n.drawRange; if (null !== f) if (Array.isArray(i)) for (c = 0, l = v.length; c < l; c++)for (d = i[(p = v[c]).materialIndex], h = Math.max(p.start, y.start), u = Math.min(p.start + p.count, y.start + y.count); h < u; h += 3)a = f.getX(h), o = f.getX(h + 1), s = f.getX(h + 2), (L = ra(this, d, t, zr, m, g, a, o, s)) && (L.faceIndex = Math.floor(h / 3), L.face.materialIndex = p.materialIndex, e.push(L)); else for (c = Math.max(0, y.start), l = Math.min(f.count, y.start + y.count); c < l; c += 3)a = f.getX(c), o = f.getX(c + 1), s = f.getX(c + 2), (L = ra(this, i, t, zr, m, g, a, o, s)) && (L.faceIndex = Math.floor(c / 3), e.push(L)); else if (void 0 !== m) if (Array.isArray(i)) for (c = 0, l = v.length; c < l; c++)for (d = i[(p = v[c]).materialIndex], h = Math.max(p.start, y.start), u = Math.min(p.start + p.count, y.start + y.count); h < u; h += 3)(L = ra(this, d, t, zr, m, g, a = h, o = h + 1, s = h + 2)) && (L.faceIndex = Math.floor(h / 3), L.face.materialIndex = p.materialIndex, e.push(L)); else for (c = Math.max(0, y.start), l = Math.min(m.count, y.start + y.count); c < l; c += 3)(L = ra(this, i, t, zr, m, g, a = c, o = c + 1, s = c + 2)) && (L.faceIndex = Math.floor(c / 3), e.push(L)) } else if (n.isGeometry) { var x, b, w, _, M = Array.isArray(i), E = n.vertices, S = n.faces, r = n.faceVertexUvs[0]; 0 < r.length && (_ = r); for (var T = 0, A = S.length; T < A; T++) { var L, R = S[T], P = M ? i[R.materialIndex] : i; if (void 0 !== P) { if (x = E[R.a], b = E[R.b], w = E[R.c], !0 === P.morphTargets) { var C = n.morphTargets, O = this.morphTargetInfluences; Gr.set(0, 0, 0), Fr.set(0, 0, 0), Hr.set(0, 0, 0); for (var I = 0, D = C.length; I < D; I++) { var N, B = O[I]; 0 !== B && (N = C[I].vertices, Gr.addScaledVector(Vr.subVectors(N[R.a], x), B), Fr.addScaledVector(kr.subVectors(N[R.b], b), B), Hr.addScaledVector(jr.subVectors(N[R.c], w), B)) } Gr.add(x), Fr.add(b), Hr.add(w), x = Gr, b = Fr, w = Hr } (L = ia(this, P, t, zr, x, b, w, Yr)) && (_ && _[T] && (P = _[T], Wr.copy(P[0]), qr.copy(P[1]), Xr.copy(P[2]), L.uv = ta.getUV(Yr, x, b, w, Wr, qr, Xr, new ke)), L.face = R, L.faceIndex = T, e.push(L)) } } } }), clone: function () { return new this.constructor(this.geometry, this.material).copy(this) } }), ((ga.prototype = Object.create(An.prototype)).constructor = ga).prototype.isCubeTexture = !0, Object.defineProperty(ga.prototype, "images", { get: function () { return this.image }, set: function (t) { this.image = t } }), ((va.prototype = Object.create(An.prototype)).constructor = va).prototype.isDataTexture3D = !0; var ya = new An, xa = new va, ba = new ga; function wa() { this.seq = [], this.map = {} } var _a = [], Ma = [], Ea = new Float32Array(16), Sa = new Float32Array(9), Ta = new Float32Array(4); function Aa(t, e, n) { var i = t[0]; if (i <= 0 || 0 < i) return t; var r = e * n, a = _a[r]; if (void 0 === a && (a = new Float32Array(r), _a[r] = a), 0 !== e) { i.toArray(a, 0); for (var o = 1, s = 0; o !== e; ++o)s += n, t[o].toArray(a, s) } return a } function La(t, e) { if (t.length !== e.length) return !1; for (var n = 0, i = t.length; n < i; n++)if (t[n] !== e[n]) return !1; return !0 } function Ra(t, e) { for (var n = 0, i = e.length; n < i; n++)t[n] = e[n] } function Pa(t, e) { var n = Ma[e]; void 0 === n && (n = new Int32Array(e), Ma[e] = n); for (var i = 0; i !== e; ++i)n[i] = t.allocTextureUnit(); return n } function Ca(t, e) { var n = this.cache; n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e) } function Oa(t, e) { var n = this.cache; n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e) } function Ia(t, e) { var n = this.cache; void 0 !== e.x ? n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y) : La(n, e) || (t.uniform2fv(this.addr, e), Ra(n, e)) } function Da(t, e) { var n = this.cache; void 0 !== e.x ? n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z) : void 0 !== e.r ? n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b) : La(n, e) || (t.uniform3fv(this.addr, e), Ra(n, e)) } function Na(t, e) { var n = this.cache; void 0 !== e.x ? n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w) : La(n, e) || (t.uniform4fv(this.addr, e), Ra(n, e)) } function Ba(t, e) { var n = this.cache, i = e.elements; void 0 === i ? La(n, e) || (t.uniformMatrix2fv(this.addr, !1, e), Ra(n, e)) : La(n, i) || (Ta.set(i), t.uniformMatrix2fv(this.addr, !1, Ta), Ra(n, i)) } function za(t, e) { var n = this.cache, i = e.elements; void 0 === i ? La(n, e) || (t.uniformMatrix3fv(this.addr, !1, e), Ra(n, e)) : La(n, i) || (Sa.set(i), t.uniformMatrix3fv(this.addr, !1, Sa), Ra(n, i)) } function Ua(t, e) { var n = this.cache, i = e.elements; void 0 === i ? La(n, e) || (t.uniformMatrix4fv(this.addr, !1, e), Ra(n, e)) : La(n, i) || (Ea.set(i), t.uniformMatrix4fv(this.addr, !1, Ea), Ra(n, i)) } function Ga(t, e, n) { var i = this.cache, r = n.allocTextureUnit(); i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2D(e || ya, r) } function Fa(t, e, n) { var i = this.cache, r = n.allocTextureUnit(); i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || xa, r) } function Ha(t, e, n) { var i = this.cache, r = n.allocTextureUnit(); i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTextureCube(e || ba, r) } function Va(t, e) { var n = this.cache; La(n, e) || (t.uniform2iv(this.addr, e), Ra(n, e)) } function ka(t, e) { var n = this.cache; La(n, e) || (t.uniform3iv(this.addr, e), Ra(n, e)) } function ja(t, e) { var n = this.cache; La(n, e) || (t.uniform4iv(this.addr, e), Ra(n, e)) } function Wa(t, e) { var n = this.cache; La(n, e) || (t.uniform1fv(this.addr, e), Ra(n, e)) } function qa(t, e) { var n = this.cache; La(n, e) || (t.uniform1iv(this.addr, e), Ra(n, e)) } function Xa(t, e) { var n = this.cache, e = Aa(e, this.size, 2); La(n, e) || (t.uniform2fv(this.addr, e), this.updateCache(e)) } function Ya(t, e) { var n = this.cache, e = Aa(e, this.size, 3); La(n, e) || (t.uniform3fv(this.addr, e), this.updateCache(e)) } function Ja(t, e) { var n = this.cache, e = Aa(e, this.size, 4); La(n, e) || (t.uniform4fv(this.addr, e), this.updateCache(e)) } function Za(t, e) { var n = this.cache, e = Aa(e, this.size, 4); La(n, e) || (t.uniformMatrix2fv(this.addr, !1, e), this.updateCache(e)) } function Qa(t, e) { var n = this.cache, e = Aa(e, this.size, 9); La(n, e) || (t.uniformMatrix3fv(this.addr, !1, e), this.updateCache(e)) } function Ka(t, e) { var n = this.cache, e = Aa(e, this.size, 16); La(n, e) || (t.uniformMatrix4fv(this.addr, !1, e), this.updateCache(e)) } function $a(t, e, n) { var i = this.cache, r = e.length, a = Pa(n, r); !1 === La(i, a) && (t.uniform1iv(this.addr, a), Ra(i, a)); for (var o = 0; o !== r; ++o)n.setTexture2D(e[o] || ya, a[o]) } function to(t, e, n) { var i = this.cache, r = e.length, a = Pa(n, r); !1 === La(i, a) && (t.uniform1iv(this.addr, a), Ra(i, a)); for (var o = 0; o !== r; ++o)n.setTextureCube(e[o] || ba, a[o]) } function eo(t, e, n) { this.id = t, this.addr = n, this.cache = [], this.setValue = function (t) { switch (t) { case 5126: return Ca; case 35664: return Ia; case 35665: return Da; case 35666: return Na; case 35674: return Ba; case 35675: return za; case 35676: return Ua; case 35678: case 36198: return Ga; case 35679: return Fa; case 35680: return Ha; case 5124: case 35670: return Oa; case 35667: case 35671: return Va; case 35668: case 35672: return ka; case 35669: case 35673: return ja } }(e.type) } function no(t, e, n) { this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function (t) { switch (t) { case 5126: return Wa; case 35664: return Xa; case 35665: return Ya; case 35666: return Ja; case 35674: return Za; case 35675: return Qa; case 35676: return Ka; case 35678: return $a; case 35680: return to; case 5124: case 35670: return qa; case 35667: case 35671: return Va; case 35668: case 35672: return ka; case 35669: case 35673: return ja } }(e.type) } function io(t) { this.id = t, wa.call(this) } no.prototype.updateCache = function (t) { var e = this.cache; t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Ra(e, t) }, io.prototype.setValue = function (t, e, n) { for (var i = this.seq, r = 0, a = i.length; r !== a; ++r) { var o = i[r]; o.setValue(t, e[o.id], n) } }; var ro = /([\w\d_]+)(\])?(\[|\.)?/g; function ao(t, e) { t.seq.push(e), t.map[e.id] = e } function oo(t, e, n) { wa.call(this), this.renderer = n; for (var i = t.getProgramParameter(e, 35718), r = 0; r < i; ++r) { var a = t.getActiveUniform(e, r); !function (t, e, n) { var i = t.name, r = i.length; for (ro.lastIndex = 0; ;) { var a = ro.exec(i), o = ro.lastIndex, s = a[1], c = "]" === a[2], a = a[3]; if (c && (s |= 0), void 0 === a || "[" === a && o + 2 === r) { ao(n, new (void 0 === a ? eo : no)(s, t, e)); break } a = n.map[s]; void 0 === a && ao(n, a = new io(s)), n = a } }(a, t.getUniformLocation(e, a.name), this) } } function so(t, e, n) { var i = t.createShader(e); return t.shaderSource(i, n), t.compileShader(i), !1 === t.getShaderParameter(i, 35713) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(i) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === e ? "vertex" : "fragment", t.getShaderInfoLog(i), function (t) { for (var e = t.split("\n"), n = 0; n < e.length; n++)e[n] = n + 1 + ": " + e[n]; return e.join("\n") }(n)), i } oo.prototype.setValue = function (t, e, n) { e = this.map[e]; void 0 !== e && e.setValue(t, n, this.renderer) }, oo.prototype.setOptional = function (t, e, n) { e = e[n]; void 0 !== e && this.setValue(t, n, e) }, oo.upload = function (t, e, n, i) { for (var r = 0, a = e.length; r !== a; ++r) { var o = e[r], s = n[o.id]; !1 !== s.needsUpdate && o.setValue(t, s.value, i) } }, oo.seqWithValue = function (t, e) { for (var n = [], i = 0, r = t.length; i !== r; ++i) { var a = t[i]; a.id in e && n.push(a) } return n }; var co = 0; function ho(t) { switch (t) { case Ce: return ["Linear", "( value )"]; case Oe: return ["sRGB", "( value )"]; case De: return ["RGBE", "( value )"]; case Ne: return ["RGBM", "( value, 7.0 )"]; case Be: return ["RGBM", "( value, 16.0 )"]; case ze: return ["RGBD", "( value, 256.0 )"]; case Ie: return ["Gamma", "( value, float( GAMMA_FACTOR ) )"]; default: throw new Error("unsupported encoding: " + t) } } function lo(t, e) { e = ho(e); return "vec4 " + t + "( vec4 value ) { return " + e[0] + "ToLinear" + e[1] + "; }" } function uo(t) { return "" !== t } function po(t, e) { return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights) } function fo(t, e) { return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection) } function mo(t) { return t.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function (t, e) { var n = Gn[e]; if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">"); return mo(n) }) } function go(t) { return t.replace(/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function (t, e, n, i) { for (var r = "", a = parseInt(e); a < parseInt(n); a++)r += i.replace(/\[ i \]/g, "[ " + a + " ]"); return r }) } function vo(t, e, n, i, r, a, o) { var s = t.context, c = i.defines, h = r.vertexShader, l = r.fragmentShader, u = "SHADOWMAP_TYPE_BASIC"; a.shadowMapType === C ? u = "SHADOWMAP_TYPE_PCF" : a.shadowMapType === A && (u = "SHADOWMAP_TYPE_PCF_SOFT"); var p = "ENVMAP_TYPE_CUBE", d = "ENVMAP_MODE_REFLECTION", f = "ENVMAP_BLENDING_MULTIPLY"; if (a.envMap) { switch (i.envMap.mapping) { case vt: case yt: p = "ENVMAP_TYPE_CUBE"; break; case Et: case St: p = "ENVMAP_TYPE_CUBE_UV"; break; case xt: case bt: p = "ENVMAP_TYPE_EQUIREC"; break; case wt: p = "ENVMAP_TYPE_SPHERE" }switch (i.envMap.mapping) { case yt: case bt: d = "ENVMAP_MODE_REFRACTION" }switch (i.combine) { case j: f = "ENVMAP_BLENDING_MULTIPLY"; break; case lt: f = "ENVMAP_BLENDING_MIX"; break; case ut: f = "ENVMAP_BLENDING_ADD" } } var m, g, v, y, x, b = 0 < t.gammaFactor ? t.gammaFactor : 1, v = o.isWebGL2 ? "" : (m = i.extensions, g = a, v = e, [(m = m || {}).derivatives || g.envMapCubeUV || g.bumpMap || g.normalMap && !g.objectSpaceNormalMap || g.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (m.fragDepth || g.logarithmicDepthBuffer) && v.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", m.drawBuffers && v.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (m.shaderTextureLOD || g.envMap) && v.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(uo).join("\n")), c = function (t) { var e, n = []; for (e in t) { var i = t[e]; !1 !== i && n.push("#define " + e + " " + i) } return n.join("\n") }(c), w = s.createProgram(); i.isRawShaderMaterial ? (0 < (y = [c].filter(uo).join("\n")).length && (y += "\n"), 0 < (x = [v, c].filter(uo).join("\n")).length && (x += "\n")) : (y = ["precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, c, a.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + b, "#define MAX_BONES " + a.maxBones, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + d : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a.displacementMap && a.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexTangents ? "#define USE_TANGENT" : "", a.vertexColors ? "#define USE_COLOR" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.skinning ? "#define USE_SKINNING" : "", a.useVertexTexture ? "#define BONE_TEXTURE" : "", a.morphTargets ? "#define USE_MORPHTARGETS" : "", a.morphNormals && !1 === a.flatShading ? "#define USE_MORPHNORMALS" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + u : "", a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (o.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(uo).join("\n"), x = [v, "precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, c, a.alphaTest ? "#define ALPHATEST " + a.alphaTest + (a.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + b, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.matcap ? "#define USE_MATCAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + p : "", a.envMap ? "#define " + d : "", a.envMap ? "#define " + f : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexTangents ? "#define USE_TANGENT" : "", a.vertexColors ? "#define USE_COLOR" : "", a.gradientMap ? "#define USE_GRADIENTMAP" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + u : "", a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", a.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (o.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", a.envMap && (o.isWebGL2 || e.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", a.toneMapping !== pt ? "#define TONE_MAPPING" : "", a.toneMapping !== pt ? Gn.tonemapping_pars_fragment : "", a.toneMapping !== pt ? function (t, e) { var n; switch (e) { case Mt: n = "Linear"; break; case dt: n = "Reinhard"; break; case ft: n = "Uncharted2"; break; case mt: n = "OptimizedCineon"; break; case gt: n = "ACESFilmic"; break; default: throw new Error("unsupported toneMapping: " + e) }return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }" }("toneMapping", a.toneMapping) : "", a.dithering ? "#define DITHERING" : "", a.outputEncoding || a.mapEncoding || a.matcapEncoding || a.envMapEncoding || a.emissiveMapEncoding ? Gn.encodings_pars_fragment : "", a.mapEncoding ? lo("mapTexelToLinear", a.mapEncoding) : "", a.matcapEncoding ? lo("matcapTexelToLinear", a.matcapEncoding) : "", a.envMapEncoding ? lo("envMapTexelToLinear", a.envMapEncoding) : "", a.emissiveMapEncoding ? lo("emissiveMapTexelToLinear", a.emissiveMapEncoding) : "", a.outputEncoding ? (e = "linearToOutputTexel", _ = ho(_ = a.outputEncoding), "vec4 " + e + "( vec4 value ) { return LinearTo" + _[0] + _[1] + "; }") : "", a.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(uo).join("\n")), h = fo(h = po(h = mo(h), a), a), l = fo(l = po(l = mo(l), a), a), h = go(h), l = go(l), o.isWebGL2 && !i.isRawShaderMaterial && (T = !1, M = /^\s*#version\s+300\s+es\s*\n/, i.isShaderMaterial && null !== h.match(M) && null !== l.match(M) && (T = !0, h = h.replace(M, ""), l = l.replace(M, "")), y = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + y, x = ["#version 300 es\n", "#define varying in", T ? "" : "out highp vec4 pc_fragColor;", T ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + x); var _ = x + l, o = so(s, 35633, y + h), M = so(s, 35632, _); s.attachShader(w, o), s.attachShader(w, M), void 0 !== i.index0AttributeName ? s.bindAttribLocation(w, 0, i.index0AttributeName) : !0 === a.morphTargets && s.bindAttribLocation(w, 0, "position"), s.linkProgram(w); var E, S, T = s.getProgramInfoLog(w).trim(), l = s.getShaderInfoLog(o).trim(), h = s.getShaderInfoLog(M).trim(), _ = !0, a = !0; return !1 === s.getProgramParameter(w, 35714) ? (_ = !1, console.error("THREE.WebGLProgram: shader error: ", s.getError(), "35715", s.getProgramParameter(w, 35715), "gl.getProgramInfoLog", T, l, h)) : "" !== T ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", T) : "" !== l && "" !== h || (a = !1), a && (this.diagnostics = { runnable: _, material: i, programLog: T, vertexShader: { log: l, prefix: y }, fragmentShader: { log: h, prefix: x } }), s.deleteShader(o), s.deleteShader(M), this.getUniforms = function () { return void 0 === E && (E = new oo(s, w, t)), E }, this.getAttributes = function () { return void 0 === S && (S = function (t, e) { for (var n = {}, i = t.getProgramParameter(e, 35721), r = 0; r < i; r++) { var a = t.getActiveAttrib(e, r).name; n[a] = t.getAttribLocation(e, a) } return n }(s, w)), S }, this.destroy = function () { s.deleteProgram(w), this.program = void 0 }, Object.defineProperties(this, { uniforms: { get: function () { return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms() } }, attributes: { get: function () { return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes() } } }), this.name = r.name, this.id = co++, this.code = n, this.usedTimes = 1, this.program = w, this.vertexShader = o, this.fragmentShader = M, this } function yo(u, c, p) { var h = [], d = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "phong", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, a = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"]; function f(t, e) { var n; return t ? t.isTexture ? n = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), n = t.texture.encoding) : n = Ce, n === Ce && e && (n = Ie), n } this.getParameters = function (t, e, n, i, r, a, o) { var s = d[t.type], c = o.isSkinnedMesh ? (h = (l = o).skeleton.bones, p.floatVertexTextures ? 1024 : (l = p.maxVertexUniforms, l = Math.floor((l - 20) / 4), (l = Math.min(l, h.length)) < h.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + h.length + " bones. This GPU supports " + l + "."), 0) : l)) : 0, h = p.precision; null !== t.precision && (h = p.getMaxPrecision(t.precision)) !== t.precision && console.warn("THREE.WebGLProgram.getParameters:", t.precision, "not supported, using", h, "instead."); var l = u.getRenderTarget(); return { shaderID: s, precision: h, supportsVertexTextures: p.vertexTextures, outputEncoding: f(l ? l.texture : null, u.gammaOutput), map: !!t.map, mapEncoding: f(t.map, u.gammaInput), matcap: !!t.matcap, matcapEncoding: f(t.matcap, u.gammaInput), envMap: !!t.envMap, envMapMode: t.envMap && t.envMap.mapping, envMapEncoding: f(t.envMap, u.gammaInput), envMapCubeUV: !!t.envMap && (t.envMap.mapping === Et || t.envMap.mapping === St), lightMap: !!t.lightMap, aoMap: !!t.aoMap, emissiveMap: !!t.emissiveMap, emissiveMapEncoding: f(t.emissiveMap, u.gammaInput), bumpMap: !!t.bumpMap, normalMap: !!t.normalMap, objectSpaceNormalMap: t.normalMapType === He, displacementMap: !!t.displacementMap, roughnessMap: !!t.roughnessMap, metalnessMap: !!t.metalnessMap, specularMap: !!t.specularMap, alphaMap: !!t.alphaMap, gradientMap: !!t.gradientMap, combine: t.combine, vertexTangents: t.normalMap && t.vertexTangents, vertexColors: t.vertexColors, fog: !!i, useFog: t.fog, fogExp: i && i.isFogExp2, flatShading: t.flatShading, sizeAttenuation: t.sizeAttenuation, logarithmicDepthBuffer: p.logarithmicDepthBuffer, skinning: t.skinning && 0 < c, maxBones: c, useVertexTexture: p.floatVertexTextures, morphTargets: t.morphTargets, morphNormals: t.morphNormals, maxMorphTargets: u.maxMorphTargets, maxMorphNormals: u.maxMorphNormals, numDirLights: e.directional.length, numPointLights: e.point.length, numSpotLights: e.spot.length, numRectAreaLights: e.rectArea.length, numHemiLights: e.hemi.length, numClippingPlanes: r, numClipIntersection: a, dithering: t.dithering, shadowMapEnabled: u.shadowMap.enabled && o.receiveShadow && 0 < n.length, shadowMapType: u.shadowMap.type, toneMapping: u.toneMapping, physicallyCorrectLights: u.physicallyCorrectLights, premultipliedAlpha: t.premultipliedAlpha, alphaTest: t.alphaTest, doubleSided: t.side === Y, flipSided: t.side === _t, depthPacking: void 0 !== t.depthPacking && t.depthPacking } }, this.getProgramCode = function (t, e) { var n = []; if (e.shaderID ? n.push(e.shaderID) : (n.push(t.fragmentShader), n.push(t.vertexShader)), void 0 !== t.defines) for (var i in t.defines) n.push(i), n.push(t.defines[i]); for (var r = 0; r < a.length; r++)n.push(e[a[r]]); return n.push(t.onBeforeCompile.toString()), n.push(u.gammaOutput), n.push(u.gammaFactor), n.join() }, this.acquireProgram = function (t, e, n, i) { for (var r, a = 0, o = h.length; a < o; a++) { var s = h[a]; if (s.code === i) { ++(r = s).usedTimes; break } } return void 0 === r && (r = new vo(u, c, i, t, e, n, p), h.push(r)), r }, this.releaseProgram = function (t) { var e; 0 == --t.usedTimes && (e = h.indexOf(t), h[e] = h[h.length - 1], h.pop(), t.destroy()) }, this.programs = h } function xo() { var i = new WeakMap; return { get: function (t) { var e = i.get(t); return void 0 === e && (e = {}, i.set(t, e)), e }, remove: function (t) { i.delete(t) }, update: function (t, e, n) { i.get(t)[e] = n }, dispose: function () { i = new WeakMap } } } function bo(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program && t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id } function wo(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id } function _o() { var s = [], c = 0, o = [], h = []; function l(t, e, n, i, r, a) { var o = s[c]; return void 0 === o ? (o = { id: t.id, object: t, geometry: e, material: n, program: n.program, groupOrder: i, renderOrder: t.renderOrder, z: r, group: a }, s[c] = o) : (o.id = t.id, o.object = t, o.geometry = e, o.material = n, o.program = n.program, o.groupOrder = i, o.renderOrder = t.renderOrder, o.z = r, o.group = a), c++, o } return { opaque: o, transparent: h, init: function () { c = 0, o.length = 0, h.length = 0 }, push: function (t, e, n, i, r, a) { a = l(t, e, n, i, r, a), (!0 === n.transparent ? h : o).push(a) }, unshift: function (t, e, n, i, r, a) { a = l(t, e, n, i, r, a), (!0 === n.transparent ? h : o).unshift(a) }, sort: function () { 1 < o.length && o.sort(bo), 1 < h.length && h.sort(wo) } } } function Mo() { var r = {}; function a(t) { t = t.target; t.removeEventListener("dispose", a), delete r[t.id] } return { get: function (t, e) { var n, i = r[t.id]; return void 0 === i ? (n = new _o, r[t.id] = {}, r[t.id][e.id] = n, t.addEventListener("dispose", a)) : void 0 === (n = i[e.id]) && (n = new _o, i[e.id] = n), n }, dispose: function () { r = {} } } } function Eo() { var n = {}; return { get: function (t) { if (void 0 !== n[t.id]) return n[t.id]; var e; switch (t.type) { case "DirectionalLight": e = { direction: new qe, color: new Xn, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new ke }; break; case "SpotLight": e = { position: new qe, direction: new qe, color: new Xn, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new ke }; break; case "PointLight": e = { position: new qe, color: new Xn, distance: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new ke, shadowCameraNear: 1, shadowCameraFar: 1e3 }; break; case "HemisphereLight": e = { direction: new qe, skyColor: new Xn, groundColor: new Xn }; break; case "RectAreaLight": e = { color: new Xn, position: new qe, halfWidth: new qe, halfHeight: new qe } }return n[t.id] = e } } } var So = 0; function To() { var w = new Eo, _ = { id: So++, hash: { stateID: -1, directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, shadowsLength: -1 }, ambient: [0, 0, 0], directional: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], point: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }, M = new qe, E = new je, S = new je; return { setup: function (t, e, n) { for (var i = 0, r = 0, a = 0, o = 0, s = 0, c = 0, h = 0, l = 0, u = n.matrixWorldInverse, p = 0, d = t.length; p < d; p++) { var f, m, g = t[p], v = g.color, y = g.intensity, x = g.distance, b = g.shadow && g.shadow.map ? g.shadow.map.texture : null; g.isAmbientLight ? (i += v.r * y, r += v.g * y, a += v.b * y) : g.isDirectionalLight ? ((m = w.get(g)).color.copy(g.color).multiplyScalar(g.intensity), m.direction.setFromMatrixPosition(g.matrixWorld), M.setFromMatrixPosition(g.target.matrixWorld), m.direction.sub(M), m.direction.transformDirection(u), m.shadow = g.castShadow, g.castShadow && (f = g.shadow, m.shadowBias = f.bias, m.shadowRadius = f.radius, m.shadowMapSize = f.mapSize), _.directionalShadowMap[o] = b, _.directionalShadowMatrix[o] = g.shadow.matrix, _.directional[o] = m, o++) : g.isSpotLight ? ((m = w.get(g)).position.setFromMatrixPosition(g.matrixWorld), m.position.applyMatrix4(u), m.color.copy(v).multiplyScalar(y), m.distance = x, m.direction.setFromMatrixPosition(g.matrixWorld), M.setFromMatrixPosition(g.target.matrixWorld), m.direction.sub(M), m.direction.transformDirection(u), m.coneCos = Math.cos(g.angle), m.penumbraCos = Math.cos(g.angle * (1 - g.penumbra)), m.decay = g.decay, m.shadow = g.castShadow, g.castShadow && (f = g.shadow, m.shadowBias = f.bias, m.shadowRadius = f.radius, m.shadowMapSize = f.mapSize), _.spotShadowMap[c] = b, _.spotShadowMatrix[c] = g.shadow.matrix, _.spot[c] = m, c++) : g.isRectAreaLight ? ((m = w.get(g)).color.copy(v).multiplyScalar(y), m.position.setFromMatrixPosition(g.matrixWorld), m.position.applyMatrix4(u), S.identity(), E.copy(g.matrixWorld), E.premultiply(u), S.extractRotation(E), m.halfWidth.set(.5 * g.width, 0, 0), m.halfHeight.set(0, .5 * g.height, 0), m.halfWidth.applyMatrix4(S), m.halfHeight.applyMatrix4(S), _.rectArea[h] = m, h++) : g.isPointLight ? ((m = w.get(g)).position.setFromMatrixPosition(g.matrixWorld), m.position.applyMatrix4(u), m.color.copy(g.color).multiplyScalar(g.intensity), m.distance = g.distance, m.decay = g.decay, m.shadow = g.castShadow, g.castShadow && (f = g.shadow, m.shadowBias = f.bias, m.shadowRadius = f.radius, m.shadowMapSize = f.mapSize, m.shadowCameraNear = f.camera.near, m.shadowCameraFar = f.camera.far), _.pointShadowMap[s] = b, _.pointShadowMatrix[s] = g.shadow.matrix, _.point[s] = m, s++) : g.isHemisphereLight && ((m = w.get(g)).direction.setFromMatrixPosition(g.matrixWorld), m.direction.transformDirection(u), m.direction.normalize(), m.skyColor.copy(g.color).multiplyScalar(y), m.groundColor.copy(g.groundColor).multiplyScalar(y), _.hemi[l] = m, l++) } _.ambient[0] = i, _.ambient[1] = r, _.ambient[2] = a, _.directional.length = o, _.spot.length = c, _.rectArea.length = h, _.point.length = s, _.hemi.length = l, _.hash.stateID = _.id, _.hash.directionalLength = o, _.hash.pointLength = s, _.hash.spotLength = c, _.hash.rectAreaLength = h, _.hash.hemiLength = l, _.hash.shadowsLength = e.length }, state: _ } } function Ao() { var e = new To, n = [], i = []; return { init: function () { n.length = 0, i.length = 0 }, state: { lightsArray: n, shadowsArray: i, lights: e }, setupLights: function (t) { e.setup(n, i, t) }, pushLight: function (t) { n.push(t) }, pushShadow: function (t) { i.push(t) } } } function Lo() { var i = {}; function r(t) { t = t.target; t.removeEventListener("dispose", r), delete i[t.id] } return { get: function (t, e) { var n; return void 0 === i[t.id] ? (n = new Ao, i[t.id] = {}, i[t.id][e.id] = n, t.addEventListener("dispose", r)) : void 0 === i[t.id][e.id] ? (n = new Ao, i[t.id][e.id] = n) : n = i[t.id][e.id], n }, dispose: function () { i = {} } } } function Ro(t) { lr.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Ue, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(t) } function Po(t) { lr.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new qe, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(t) } function Co(v, y, t) { for (var x = new Un, b = new je, w = new ke, _ = new ke(t, t), M = new qe, E = new qe, p = 1, d = 2, e = 1 + (p | d), f = new Array(e), m = new Array(e), g = {}, S = { 0: _t, 1: O, 2: Y }, T = [new qe(1, 0, 0), new qe(-1, 0, 0), new qe(0, 0, 1), new qe(0, 0, -1), new qe(0, 1, 0), new qe(0, -1, 0)], A = [new qe(0, 1, 0), new qe(0, 1, 0), new qe(0, 1, 0), new qe(0, 1, 0), new qe(0, 0, 1), new qe(0, 0, -1)], L = [new Ln, new Ln, new Ln, new Ln, new Ln, new Ln], n = 0; n !== e; ++n) { var i = 0 != (n & p), r = 0 != (n & d), a = new Ro({ depthPacking: Ge, morphTargets: i, skinning: r }); f[n] = a; r = new Po({ morphTargets: i, skinning: r }); m[n] = r } var R = this; function P(t, e, n, i, r, a) { var o, s, c = t.geometry, h = null, l = f, u = t.customDepthMaterial; return n && (l = m, u = t.customDistanceMaterial), h = u || (u = !1, e.morphTargets && (c && c.isBufferGeometry ? u = c.morphAttributes && c.morphAttributes.position && 0 < c.morphAttributes.position.length : c && c.isGeometry && (u = c.morphTargets && 0 < c.morphTargets.length)), t.isSkinnedMesh && !1 === e.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t), s = t.isSkinnedMesh && e.skinning, o = 0, u && (o |= p), s && (o |= d), l[o]), v.localClippingEnabled && !0 === e.clipShadows && 0 !== e.clippingPlanes.length && (s = h.uuid, l = e.uuid, void 0 === (o = g[s]) && (o = {}, g[s] = o), void 0 === (s = o[l]) && (s = h.clone(), o[l] = s), h = s), h.visible = e.visible, h.wireframe = e.wireframe, h.side = null != e.shadowSide ? e.shadowSide : S[e.side], h.clipShadows = e.clipShadows, h.clippingPlanes = e.clippingPlanes, h.clipIntersection = e.clipIntersection, h.wireframeLinewidth = e.wireframeLinewidth, h.linewidth = e.linewidth, n && h.isMeshDistanceMaterial && (h.referencePosition.copy(i), h.nearDistance = r, h.farDistance = a), h } this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = C, this.render = function (t, e, n) { if (!1 !== R.enabled && (!1 !== R.autoUpdate || !1 !== R.needsUpdate) && 0 !== t.length) { var i, r = v.getRenderTarget(), a = v.state; a.setBlending(J), a.buffers.color.setClear(1, 1, 1, 1), a.buffers.depth.setTest(!0), a.setScissorTest(!1); for (var o = 0, s = t.length; o < s; o++) { var c = t[o], h = c.shadow, l = c && c.isPointLight; if (void 0 !== h) { var u, p, d = h.camera; w.copy(h.mapSize), w.min(_), l && (u = w.x, p = w.y, L[0].set(2 * u, p, u, p), L[1].set(0, p, u, p), L[2].set(3 * u, p, u, p), L[3].set(u, p, u, p), L[4].set(3 * u, 0, u, p), L[5].set(u, 0, u, p), w.x *= 4, w.y *= 2), null === h.map && (f = { minFilter: Rt, magFilter: Rt, format: Jt }, h.map = new Rn(w.x, w.y, f), h.map.texture.name = c.name + ".shadowMap", d.updateProjectionMatrix()), h.isSpotLightShadow && h.update(c); var f = h.map, h = h.matrix; E.setFromMatrixPosition(c.matrixWorld), d.position.copy(E), l ? (i = 6, h.makeTranslation(-E.x, -E.y, -E.z)) : (i = 1, M.setFromMatrixPosition(c.target.matrixWorld), d.lookAt(M), d.updateMatrixWorld(), h.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), h.multiply(d.projectionMatrix), h.multiply(d.matrixWorldInverse)), v.setRenderTarget(f), v.clear(); for (var m, g = 0; g < i; g++)l && (M.copy(d.position), M.add(T[g]), d.up.copy(A[g]), d.lookAt(M), d.updateMatrixWorld(), m = L[g], a.viewport(m)), b.multiplyMatrices(d.projectionMatrix, d.matrixWorldInverse), x.setFromMatrix(b), function t(e, n, i, r) { if (!1 === e.visible) return; var a = e.layers.test(n.layers); if (a && (e.isMesh || e.isLine || e.isPoints) && e.castShadow && (!e.frustumCulled || x.intersectsObject(e))) { e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld); var o = y.update(e), s = e.material; if (Array.isArray(s)) for (var c = o.groups, h = 0, l = c.length; h < l; h++) { var u, p = c[h], d = s[p.materialIndex]; d && d.visible && (u = P(e, d, r, E, i.near, i.far), v.renderBufferDirect(i, null, o, u, e, p)) } else s.visible && (u = P(e, s, r, E, i.near, i.far), v.renderBufferDirect(i, null, o, u, e, null)) } var f = e.children; for (var m = 0, g = f.length; m < g; m++)t(f[m], n, i, r) }(e, n, d, l) } else console.warn("THREE.WebGLShadowMap:", c, "has no shadow.") } R.needsUpdate = !1, v.setRenderTarget(r) } } } function Oo(l, n, c, i) { var r = new function () { var e = !1, a = new Ln, n = null, o = new Ln(0, 0, 0, 0); return { setMask: function (t) { n === t || e || (l.colorMask(t, t, t, t), n = t) }, setLocked: function (t) { e = t }, setClear: function (t, e, n, i, r) { !0 === r && (t *= i, e *= i, n *= i), a.set(t, e, n, i), !1 === o.equals(a) && (l.clearColor(t, e, n, i), o.copy(a)) }, reset: function () { e = !1, n = null, o.set(-1, 0, 0, 0) } } }, a = new function () { var e = !1, n = null, i = null, r = null; return { setTest: function (t) { (t ? U : G)(2929) }, setMask: function (t) { n === t || e || (l.depthMask(t), n = t) }, setFunc: function (t) { if (i !== t) { if (t) switch (t) { case nt: l.depthFunc(512); break; case it: l.depthFunc(519); break; case rt: l.depthFunc(513); break; case at: l.depthFunc(515); break; case ot: l.depthFunc(514); break; case st: l.depthFunc(518); break; case ct: l.depthFunc(516); break; case ht: l.depthFunc(517); break; default: l.depthFunc(515) } else l.depthFunc(515); i = t } }, setLocked: function (t) { e = t }, setClear: function (t) { r !== t && (l.clearDepth(t), r = t) }, reset: function () { e = !1, r = i = n = null } } }, e = new function () { var e = !1, n = null, i = null, r = null, a = null, o = null, s = null, c = null, h = null; return { setTest: function (t) { (t ? U : G)(2960) }, setMask: function (t) { n === t || e || (l.stencilMask(t), n = t) }, setFunc: function (t, e, n) { i === t && r === e && a === n || (l.stencilFunc(t, e, n), i = t, r = e, a = n) }, setOp: function (t, e, n) { o === t && s === e && c === n || (l.stencilOp(t, e, n), o = t, s = e, c = n) }, setLocked: function (t) { e = t }, setClear: function (t) { h !== t && (l.clearStencil(t), h = t) }, reset: function () { e = !1, h = c = s = o = a = r = i = n = null } } }, t = l.getParameter(34921), o = new Uint8Array(t), s = new Uint8Array(t), h = new Uint8Array(t), u = {}, p = null, d = null, f = null, m = null, g = null, v = null, y = null, x = null, b = null, w = null, _ = !1, M = null, E = null, S = null, T = null, A = null, L = l.getParameter(35661), R = !1, P = 0, t = l.getParameter(7938); -1 !== t.indexOf("WebGL") ? (P = parseFloat(/^WebGL\ ([0-9])/.exec(t)[1]), R = 1 <= P) : -1 !== t.indexOf("OpenGL ES") && (P = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(t)[1]), R = 2 <= P); var C = null, O = {}, I = new Ln, D = new Ln; function N(t, e, n) { var i = new Uint8Array(4), r = l.createTexture(); l.bindTexture(t, r), l.texParameteri(t, 10241, 9728), l.texParameteri(t, 10240, 9728); for (var a = 0; a < n; a++)l.texImage2D(e + a, 0, 6408, 1, 1, 0, 6408, 5121, i); return r } var B = {}; function z(t, e) { o[t] = 1, 0 === s[t] && (l.enableVertexAttribArray(t), s[t] = 1), h[t] !== e && ((i.isWebGL2 ? l : n.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](t, e), h[t] = e) } function U(t) { !0 !== u[t] && (l.enable(t), u[t] = !0) } function G(t) { !1 !== u[t] && (l.disable(t), u[t] = !1) } function F(t, e, n, i, r, a, o, s) { if (t !== J) { if (f || (U(3042), f = !0), t === tt) r = r || e, a = a || n, o = o || i, e === g && r === x || (l.blendEquationSeparate(c.convert(e), c.convert(r)), g = e, x = r), n === v && i === y && a === b && o === w || (l.blendFuncSeparate(c.convert(n), c.convert(i), c.convert(a), c.convert(o)), v = n, y = i, b = a, w = o), m = t, _ = null; else if (t !== m || s !== _) { if (g === et && x === et || (l.blendEquation(32774), x = g = et), s) switch (t) { case Z: l.blendFuncSeparate(1, 771, 1, 771); break; case Q: l.blendFunc(1, 1); break; case K: l.blendFuncSeparate(0, 0, 769, 771); break; case $: l.blendFuncSeparate(0, 768, 0, 770); break; default: console.error("THREE.WebGLState: Invalid blending: ", t) } else switch (t) { case Z: l.blendFuncSeparate(770, 771, 1, 771); break; case Q: l.blendFunc(770, 1); break; case K: l.blendFunc(0, 769); break; case $: l.blendFunc(0, 768); break; default: console.error("THREE.WebGLState: Invalid blending: ", t) }w = b = y = v = null, m = t, _ = s } } else f && (G(3042), f = !1) } function H(t) { M !== t && (t ? l.frontFace(2304) : l.frontFace(2305), M = t) } function V(t) { t !== W ? (U(2884), t !== E && (t === q ? l.cullFace(1029) : t === X ? l.cullFace(1028) : l.cullFace(1032))) : G(2884), E = t } function k(t, e, n) { t ? (U(32823), T === e && A === n || (l.polygonOffset(e, n), T = e, A = n)) : G(32823) } function j(t) { void 0 === t && (t = 33984 + L - 1), C !== t && (l.activeTexture(t), C = t) } return B[3553] = N(3553, 3553, 1), B[34067] = N(34067, 34069, 6), r.setClear(0, 0, 0, 1), a.setClear(1), e.setClear(0), U(2929), a.setFunc(at), H(!1), V(q), U(2884), F(J), { buffers: { color: r, depth: a, stencil: e }, initAttributes: function () { for (var t = 0, e = o.length; t < e; t++)o[t] = 0 }, enableAttribute: function (t) { z(t, 0) }, enableAttributeAndDivisor: z, disableUnusedAttributes: function () { for (var t = 0, e = s.length; t !== e; ++t)s[t] !== o[t] && (l.disableVertexAttribArray(t), s[t] = 0) }, enable: U, disable: G, getCompressedTextureFormats: function () { if (null === p && (p = [], n.get("WEBGL_compressed_texture_pvrtc") || n.get("WEBGL_compressed_texture_s3tc") || n.get("WEBGL_compressed_texture_etc1") || n.get("WEBGL_compressed_texture_astc"))) for (var t = l.getParameter(34467), e = 0; e < t.length; e++)p.push(t[e]); return p }, useProgram: function (t) { return d !== t && (l.useProgram(t), d = t, !0) }, setBlending: F, setMaterial: function (t, e) { (t.side === Y ? G : U)(2884); var n = t.side === _t; e && (n = !n), H(n), t.blending === Z && !1 === t.transparent ? F(J) : F(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), a.setFunc(t.depthFunc), a.setTest(t.depthTest), a.setMask(t.depthWrite), r.setMask(t.colorWrite), k(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits) }, setFlipSided: H, setCullFace: V, setLineWidth: function (t) { t !== S && (R && l.lineWidth(t), S = t) }, setPolygonOffset: k, setScissorTest: function (t) { (t ? U : G)(3089) }, activeTexture: j, bindTexture: function (t, e) { null === C && j(); var n = O[C]; void 0 === n && (n = { type: void 0, texture: void 0 }, O[C] = n), n.type === t && n.texture === e || (l.bindTexture(t, e || B[t]), n.type = t, n.texture = e) }, compressedTexImage2D: function () { try { l.compressedTexImage2D.apply(l, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, texImage2D: function () { try { l.texImage2D.apply(l, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, texImage3D: function () { try { l.texImage3D.apply(l, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, scissor: function (t) { !1 === I.equals(t) && (l.scissor(t.x, t.y, t.z, t.w), I.copy(t)) }, viewport: function (t) { !1 === D.equals(t) && (l.viewport(t.x, t.y, t.z, t.w), D.copy(t)) }, reset: function () { for (var t = 0; t < s.length; t++)1 === s[t] && (l.disableVertexAttribArray(t), s[t] = 0); u = {}, O = {}, E = M = m = d = C = p = null, r.reset(), a.reset(), e.reset() } } } function Io(g, i, v, y, x, b, c) { var a, o = {}, s = "undefined" != typeof OffscreenCanvas; function h(t, e) { return s ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") } function w(t, e, n, i) { var r = 1; if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) { if (t instanceof HTMLImageElement || t instanceof HTMLCanvasElement) { i = e ? Ve.floorPowerOfTwo : Math.floor, e = i(r * t.width), r = i(r * t.height); void 0 === a && (a = h(e, r)); n = n ? h(e, r) : a; return n.width = e, n.height = r, n.getContext("2d").drawImage(t, 0, 0, e, r), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + e + "x" + r + ")."), s ? n.transferToImageBitmap() : n } return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t } return t } function _(t) { return Ve.isPowerOfTwo(t.width) && Ve.isPowerOfTwo(t.height) } function M(t, e) { return t.generateMipmaps && e && t.minFilter !== Rt && t.minFilter !== Ot } function E(t, e, n, i) { g.generateMipmap(t), y.get(e).__maxMipLevel = Math.log(Math.max(n, i)) * Math.LOG2E } function S(t, e) { if (!x.isWebGL2) return t; var n = t; return 6403 === t && (5126 === e && (n = 33326), 5131 === e && (n = 33325), 5121 === e && (n = 33321)), 6407 === t && (5126 === e && (n = 34837), 5131 === e && (n = 34843), 5121 === e && (n = 32849)), 6408 === t && (5126 === e && (n = 34836), 5131 === e && (n = 34842), 5121 === e && (n = 32856)), 33325 === n || 33326 === n || 34842 === n || 34836 === n ? i.get("EXT_color_buffer_float") : 34843 !== n && 34837 !== n || console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."), n } function r(t) { return t === Rt || t === Pt || t === Ct ? 9728 : 9729 } function l(t) { var e, n = t.target; n.removeEventListener("dispose", l), e = n, void 0 !== (t = y.get(e)).__webglInit && (g.deleteTexture(t.__webglTexture), y.remove(e)), n.isVideoTexture && delete o[n.id], c.memory.textures-- } function u(t) { t = t.target; t.removeEventListener("dispose", u), function (t) { var e = y.get(t), n = y.get(t.texture); if (t) { if (void 0 !== n.__webglTexture && g.deleteTexture(n.__webglTexture), t.depthTexture && t.depthTexture.dispose(), t.isWebGLRenderTargetCube) for (var i = 0; i < 6; i++)g.deleteFramebuffer(e.__webglFramebuffer[i]), e.__webglDepthbuffer && g.deleteRenderbuffer(e.__webglDepthbuffer[i]); else g.deleteFramebuffer(e.__webglFramebuffer), e.__webglDepthbuffer && g.deleteRenderbuffer(e.__webglDepthbuffer); y.remove(t.texture), y.remove(t) } }(t), c.memory.textures-- } function p(t, e) { var n, i, r = y.get(t); if (t.isVideoTexture && (n = (a = t).id, i = c.render.frame, o[n] !== i && (o[n] = i, a.update())), 0 < t.version && r.__version !== t.version) { var a = t.image; if (void 0 === a) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else { if (!1 !== a.complete) return void d(r, t, e); console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } } v.activeTexture(33984 + e), v.bindTexture(3553, r.__webglTexture) } function T(t, e, n) { n ? (g.texParameteri(t, 10242, b.convert(e.wrapS)), g.texParameteri(t, 10243, b.convert(e.wrapT)), 32879 === t && g.texParameteri(t, 32882, b.convert(e.wrapR)), g.texParameteri(t, 10240, b.convert(e.magFilter)), g.texParameteri(t, 10241, b.convert(e.minFilter))) : (g.texParameteri(t, 10242, 33071), g.texParameteri(t, 10243, 33071), 32879 === t && g.texParameteri(t, 32882, 33071), e.wrapS === At && e.wrapT === At || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), g.texParameteri(t, 10240, r(e.magFilter)), g.texParameteri(t, 10241, r(e.minFilter)), e.minFilter !== Rt && e.minFilter !== Ot && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), (n = i.get("EXT_texture_filter_anisotropic")) && (e.type === Ht && null === i.get("OES_texture_float_linear") || e.type === Vt && null === (x.isWebGL2 || i.get("OES_texture_half_float_linear")) || (1 < e.anisotropy || y.get(e).__currentAnisotropy) && (g.texParameterf(t, n.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(e.anisotropy, x.getMaxAnisotropy())), y.get(e).__currentAnisotropy = e.anisotropy)) } function A(t, e) { void 0 === t.__webglInit && (t.__webglInit = !0, e.addEventListener("dispose", l), t.__webglTexture = g.createTexture(), c.memory.textures++) } function d(t, e, n) { var i = e.isDataTexture3D ? 32879 : 3553; A(t, e), v.activeTexture(33984 + n), v.bindTexture(i, t.__webglTexture), g.pixelStorei(37440, e.flipY), g.pixelStorei(37441, e.premultiplyAlpha), g.pixelStorei(3317, e.unpackAlignment); var n = (r = e, !x.isWebGL2 && (r.wrapS !== At || r.wrapT !== At || r.minFilter !== Rt && r.minFilter !== Ot) && !1 === _(e.image)), r = w(e.image, n, !1, x.maxTextureSize), n = _(r) || x.isWebGL2, a = b.convert(e.format), o = b.convert(e.type), s = S(a, o); T(i, e, n); var c, h = e.mipmaps; if (e.isDepthTexture) { if (s = 6402, e.type === Ht) { if (!x.isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0"); s = 36012 } else x.isWebGL2 && (s = 33189); e.format === $t && 6402 === s && e.type !== Ut && e.type !== Ft && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), e.type = Ut, o = b.convert(e.type)), e.format === te && (s = 34041, e.type !== qt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), e.type = qt, o = b.convert(e.type))), v.texImage2D(3553, 0, s, r.width, r.height, 0, a, o, null) } else if (e.isDataTexture) if (0 < h.length && n) { for (var l = 0, u = h.length; l < u; l++)c = h[l], v.texImage2D(3553, l, s, c.width, c.height, 0, a, o, c.data); e.generateMipmaps = !1, t.__maxMipLevel = h.length - 1 } else v.texImage2D(3553, 0, s, r.width, r.height, 0, a, o, r.data), t.__maxMipLevel = 0; else if (e.isCompressedTexture) { for (l = 0, u = h.length; l < u; l++)c = h[l], e.format !== Jt && e.format !== Yt ? -1 < v.getCompressedTextureFormats().indexOf(a) ? v.compressedTexImage2D(3553, l, s, c.width, c.height, 0, c.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : v.texImage2D(3553, l, s, c.width, c.height, 0, a, o, c.data); t.__maxMipLevel = h.length - 1 } else if (e.isDataTexture3D) v.texImage3D(32879, 0, s, r.width, r.height, r.depth, 0, a, o, r.data), t.__maxMipLevel = 0; else if (0 < h.length && n) { for (l = 0, u = h.length; l < u; l++)c = h[l], v.texImage2D(3553, l, s, a, o, c); e.generateMipmaps = !1, t.__maxMipLevel = h.length - 1 } else v.texImage2D(3553, 0, s, a, o, r), t.__maxMipLevel = 0; M(e, n) && E(3553, e, r.width, r.height), t.__version = e.version, e.onUpdate && e.onUpdate(e) } function f(t, e, n, i) { var r = b.convert(e.texture.format), a = b.convert(e.texture.type), o = S(r, a); v.texImage2D(i, 0, o, e.width, e.height, 0, r, a, null), g.bindFramebuffer(36160, t), g.framebufferTexture2D(36160, n, i, y.get(e.texture).__webglTexture, 0), g.bindFramebuffer(36160, null) } function m(t, e, n) { var i; g.bindRenderbuffer(36161, t), e.depthBuffer && !e.stencilBuffer ? (n ? (i = R(e), g.renderbufferStorageMultisample(36161, i, 33189, e.width, e.height)) : g.renderbufferStorage(36161, 33189, e.width, e.height), g.framebufferRenderbuffer(36160, 36096, 36161, t)) : e.depthBuffer && e.stencilBuffer ? (n ? (i = R(e), g.renderbufferStorageMultisample(36161, i, 34041, e.width, e.height)) : g.renderbufferStorage(36161, 34041, e.width, e.height), g.framebufferRenderbuffer(36160, 33306, 36161, t)) : (t = S(b.convert(e.texture.format), b.convert(e.texture.type)), n ? (i = R(e), g.renderbufferStorageMultisample(36161, i, t, e.width, e.height)) : g.renderbufferStorage(36161, t, e.width, e.height)), g.bindRenderbuffer(36161, null) } function L(t) { var e = y.get(t), n = !0 === t.isWebGLRenderTargetCube; if (t.depthTexture) { if (n) throw new Error("target.depthTexture not supported in Cube render targets"); !function (t, e) { if (e && e.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported"); if (g.bindFramebuffer(36160, t), !e.depthTexture || !e.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); if (y.get(e.depthTexture).__webglTexture && e.depthTexture.image.width === e.width && e.depthTexture.image.height === e.height || (e.depthTexture.image.width = e.width, e.depthTexture.image.height = e.height, e.depthTexture.needsUpdate = !0), p(e.depthTexture, 0), t = y.get(e.depthTexture).__webglTexture, e.depthTexture.format === $t) g.framebufferTexture2D(36160, 36096, 3553, t, 0); else { if (e.depthTexture.format !== te) throw new Error("Unknown depthTexture format"); g.framebufferTexture2D(36160, 33306, 3553, t, 0) } }(e.__webglFramebuffer, t) } else if (n) { e.__webglDepthbuffer = []; for (var i = 0; i < 6; i++)g.bindFramebuffer(36160, e.__webglFramebuffer[i]), e.__webglDepthbuffer[i] = g.createRenderbuffer(), m(e.__webglDepthbuffer[i], t) } else g.bindFramebuffer(36160, e.__webglFramebuffer), e.__webglDepthbuffer = g.createRenderbuffer(), m(e.__webglDepthbuffer, t); g.bindFramebuffer(36160, null) } function R(t) { return x.isWebGL2 && t.isWebGLMultisampleRenderTarget ? Math.min(x.maxSamples, t.samples) : 0 } this.setTexture2D = p, this.setTexture3D = function (t, e) { var n = y.get(t); 0 < t.version && n.__version !== t.version ? d(n, t, e) : (v.activeTexture(33984 + e), v.bindTexture(32879, n.__webglTexture)) }, this.setTextureCube = function (t, e) { var n = y.get(t); if (6 === t.image.length) if (0 < t.version && n.__version !== t.version) { A(n, t), v.activeTexture(33984 + e), v.bindTexture(34067, n.__webglTexture), g.pixelStorei(37440, t.flipY); for (var i = t && t.isCompressedTexture, r = t.image[0] && t.image[0].isDataTexture, a = [], o = 0; o < 6; o++)a[o] = i || r ? r ? t.image[o].image : t.image[o] : w(t.image[o], !1, !0, x.maxCubemapSize); var s = a[0], c = _(s) || x.isWebGL2, h = b.convert(t.format), l = b.convert(t.type), u = S(h, l); T(34067, t, c); for (o = 0; o < 6; o++)if (i) for (var p, d = a[o].mipmaps, f = 0, m = d.length; f < m; f++)p = d[f], t.format !== Jt && t.format !== Yt ? -1 < v.getCompressedTextureFormats().indexOf(h) ? v.compressedTexImage2D(34069 + o, f, u, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : v.texImage2D(34069 + o, f, u, p.width, p.height, 0, h, l, p.data); else r ? v.texImage2D(34069 + o, 0, u, a[o].width, a[o].height, 0, h, l, a[o].data) : v.texImage2D(34069 + o, 0, u, h, l, a[o]); n.__maxMipLevel = i ? d.length - 1 : 0, M(t, c) && E(34067, t, s.width, s.height), n.__version = t.version, t.onUpdate && t.onUpdate(t) } else v.activeTexture(33984 + e), v.bindTexture(34067, n.__webglTexture) }, this.setTextureCubeDynamic = function (t, e) { v.activeTexture(33984 + e), v.bindTexture(34067, y.get(t).__webglTexture) }, this.setupRenderTarget = function (t) { var e = y.get(t), n = y.get(t.texture); t.addEventListener("dispose", u), n.__webglTexture = g.createTexture(), c.memory.textures++; var i, r = !0 === t.isWebGLRenderTargetCube, a = !0 === t.isWebGLMultisampleRenderTarget, o = _(t) || x.isWebGL2; if (r) { e.__webglFramebuffer = []; for (var s = 0; s < 6; s++)e.__webglFramebuffer[s] = g.createFramebuffer() } else e.__webglFramebuffer = g.createFramebuffer(), a && (x.isWebGL2 ? (e.__webglMultisampledFramebuffer = g.createFramebuffer(), e.__webglColorRenderbuffer = g.createRenderbuffer(), g.bindRenderbuffer(36161, e.__webglColorRenderbuffer), i = S(b.convert(t.texture.format), b.convert(t.texture.type)), a = R(t), g.renderbufferStorageMultisample(36161, a, i, t.width, t.height), g.bindFramebuffer(36160, e.__webglMultisampledFramebuffer), g.framebufferRenderbuffer(36160, 36064, 36161, e.__webglColorRenderbuffer), g.bindRenderbuffer(36161, null), t.depthBuffer && (e.__webglDepthRenderbuffer = g.createRenderbuffer(), m(e.__webglDepthRenderbuffer, t, !0)), g.bindFramebuffer(36160, null)) : console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")); if (r) { v.bindTexture(34067, n.__webglTexture), T(34067, t.texture, o); for (s = 0; s < 6; s++)f(e.__webglFramebuffer[s], t, 36064, 34069 + s); M(t.texture, o) && E(34067, t.texture, t.width, t.height), v.bindTexture(34067, null) } else v.bindTexture(3553, n.__webglTexture), T(3553, t.texture, o), f(e.__webglFramebuffer, t, 36064, 3553), M(t.texture, o) && E(3553, t.texture, t.width, t.height), v.bindTexture(3553, null); t.depthBuffer && L(t) }, this.updateRenderTargetMipmap = function (t) { var e, n, i = t.texture; M(i, _(t) || x.isWebGL2) && (e = t.isWebGLRenderTargetCube ? 34067 : 3553, n = y.get(i).__webglTexture, v.bindTexture(e, n), E(e, i, t.width, t.height), v.bindTexture(e, null)) }, this.updateMultisampleRenderTarget = function (t) { var e, n, i; t.isWebGLMultisampleRenderTarget && (x.isWebGL2 ? (i = y.get(t), g.bindFramebuffer(36008, i.__webglMultisampledFramebuffer), g.bindFramebuffer(36009, i.__webglFramebuffer), e = t.width, n = t.height, i = 16384, t.depthBuffer && (i |= 256), t.stencilBuffer && (i |= 1024), g.blitFramebuffer(0, 0, e, n, 0, 0, e, n, i, 9728)) : console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")) } } function Do(t, n, i) { return { convert: function (t) { var e; if (t === Tt) return 10497; if (t === At) return 33071; if (t === Lt) return 33648; if (t === Rt) return 9728; if (t === Pt) return 9984; if (t === Ct) return 9986; if (t === Ot) return 9729; if (t === It) return 9985; if (t === Dt) return 9987; if (t === Nt) return 5121; if (t === kt) return 32819; if (t === jt) return 32820; if (t === Wt) return 33635; if (t === Bt) return 5120; if (t === zt) return 5122; if (t === Ut) return 5123; if (t === Gt) return 5124; if (t === Ft) return 5125; if (t === Ht) return 5126; if (t === Vt) { if (i.isWebGL2) return 5131; if (null !== (e = n.get("OES_texture_half_float"))) return e.HALF_FLOAT_OES } if (t === Xt) return 6406; if (t === Yt) return 6407; if (t === Jt) return 6408; if (t === Zt) return 6409; if (t === Qt) return 6410; if (t === $t) return 6402; if (t === te) return 34041; if (t === ee) return 6403; if (t === et) return 32774; if (t === T) return 32778; if (t === L) return 32779; if (t === I) return 0; if (t === D) return 1; if (t === N) return 768; if (t === B) return 769; if (t === z) return 770; if (t === U) return 771; if (t === G) return 772; if (t === F) return 773; if (t === H) return 774; if (t === V) return 775; if (t === k) return 776; if ((t === ne || t === ie || t === re || t === ae) && null !== (e = n.get("WEBGL_compressed_texture_s3tc"))) { if (t === ne) return e.COMPRESSED_RGB_S3TC_DXT1_EXT; if (t === ie) return e.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (t === re) return e.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (t === ae) return e.COMPRESSED_RGBA_S3TC_DXT5_EXT } if ((t === oe || t === se || t === ce || t === he) && null !== (e = n.get("WEBGL_compressed_texture_pvrtc"))) { if (t === oe) return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (t === se) return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (t === ce) return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (t === he) return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (t === le && null !== (e = n.get("WEBGL_compressed_texture_etc1"))) return e.COMPRESSED_RGB_ETC1_WEBGL; if ((t === ue || t === pe || t === de || t === fe || t === me || t === ge || t === ve || t === ye || t === xe || t === be || t === we || t === _e || t === Me || t === Ee) && null !== (e = n.get("WEBGL_compressed_texture_astc"))) return t; if (t === R || t === P) { if (i.isWebGL2) { if (t === R) return 32775; if (t === P) return 32776 } if (null !== (e = n.get("EXT_blend_minmax"))) { if (t === R) return e.MIN_EXT; if (t === P) return e.MAX_EXT } } if (t === qt) { if (i.isWebGL2) return 34042; if (null !== (e = n.get("WEBGL_depth_texture"))) return e.UNSIGNED_INT_24_8_WEBGL } return 0 } } } function No() { Si.call(this), this.type = "Group" } function Bo() { Si.call(this), this.type = "Camera", this.matrixWorldInverse = new je, this.projectionMatrix = new je, this.projectionMatrixInverse = new je } function zo(t, e, n, i) { Bo.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== i ? i : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } function Uo(t) { zo.call(this), this.cameras = t || [] } ((Ro.prototype = Object.create(lr.prototype)).constructor = Ro).prototype.isMeshDepthMaterial = !0, Ro.prototype.copy = function (t) { return lr.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this }, ((Po.prototype = Object.create(lr.prototype)).constructor = Po).prototype.isMeshDistanceMaterial = !0, Po.prototype.copy = function (t) { return lr.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this }, No.prototype = Object.assign(Object.create(Si.prototype), { constructor: No, isGroup: !0 }), Bo.prototype = Object.assign(Object.create(Si.prototype), { constructor: Bo, isCamera: !0, copy: function (t, e) { return Si.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this }, getWorldDirection: function (t) { void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new qe), this.updateMatrixWorld(!0); var e = this.matrixWorld.elements; return t.set(-e[8], -e[9], -e[10]).normalize() }, updateMatrixWorld: function (t) { Si.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld) }, clone: function () { return (new this.constructor).copy(this) } }), zo.prototype = Object.assign(Object.create(Bo.prototype), { constructor: zo, isPerspectiveCamera: !0, copy: function (t, e) { return Bo.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this }, setFocalLength: function (t) { t = .5 * this.getFilmHeight() / t; this.fov = 2 * Ve.RAD2DEG * Math.atan(t), this.updateProjectionMatrix() }, getFocalLength: function () { var t = Math.tan(.5 * Ve.DEG2RAD * this.fov); return .5 * this.getFilmHeight() / t }, getEffectiveFOV: function () { return 2 * Ve.RAD2DEG * Math.atan(Math.tan(.5 * Ve.DEG2RAD * this.fov) / this.zoom) }, getFilmWidth: function () { return this.filmGauge * Math.min(this.aspect, 1) }, getFilmHeight: function () { return this.filmGauge / Math.max(this.aspect, 1) }, setViewOffset: function (t, e, n, i, r, a) { this.aspect = t / e, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix() }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function () { var t, e = this.near, n = e * Math.tan(.5 * Ve.DEG2RAD * this.fov) / this.zoom, i = 2 * n, r = this.aspect * i, a = -.5 * r, o = this.view; null !== this.view && this.view.enabled && (t = o.fullWidth, s = o.fullHeight, a += o.offsetX * r / t, n -= o.offsetY * i / s, r *= o.width / t, i *= o.height / s); var s = this.filmOffset; 0 !== s && (a += e * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(a, a + r, n, n - i, e, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix) }, toJSON: function (t) { t = Si.prototype.toJSON.call(this, t); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t } }), Uo.prototype = Object.assign(Object.create(zo.prototype), { constructor: Uo, isArrayCamera: !0 }); var Go, Fo, Ho, Vo, ko, jo, Wo, qo, Xo, Yo, Jo, Zo, Qo, Ko, $o, ts, es, ns, is, rs, as, os, ss, cs, hs, ls, us, ps, ds = new qe, fs = new qe; function ms(t, e, n) { ds.setFromMatrixPosition(e.matrixWorld), fs.setFromMatrixPosition(n.matrixWorld); var i = ds.distanceTo(fs), r = e.projectionMatrix.elements, a = n.projectionMatrix.elements, o = r[14] / (r[10] - 1), s = r[14] / (r[10] + 1), c = (r[9] + 1) / r[5], h = (r[9] - 1) / r[5], l = (r[8] - 1) / r[0], n = (a[8] + 1) / a[0], r = o * l, a = o * n, n = i / (n - l), l = n * -l; e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(l), t.translateZ(n), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld); o += n, n = s + n, r -= l, a = i - l + a, c = c * s / n * o, s = h * s / n * o; t.projectionMatrix.makePerspective(r, a, c, s, o, n) } function gs(n) { var i = this, r = null, a = null, o = null, s = [], c = new je, h = new je, l = 1, u = "stage"; "undefined" != typeof window && "VRFrameData" in window && (a = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", t, !1)); var p = new je, d = new We, f = new qe, m = new zo; m.bounds = new Ln(0, 0, .5, 1), m.layers.enable(1); var g = new zo; g.bounds = new Ln(.5, 0, .5, 1), g.layers.enable(2); var v = new Uo([m, g]); function y() { return null !== r && !0 === r.isPresenting } v.layers.enable(1), v.layers.enable(2); var x, b = new ke; function t() { var t, e; y() ? (t = (e = r.getEyeParameters("left")).renderWidth * l, e = e.renderHeight * l, x = n.getPixelRatio(), n.getSize(b), n.setDrawingBufferSize(2 * t, e, 1), M.start()) : (i.enabled && n.setDrawingBufferSize(b.width, b.height, x), M.stop()) } var w = []; function _() { for (var t = 0; t < s.length; t++) { var e = s[t], n = function (t) { for (var e = navigator.getGamepads && navigator.getGamepads(), n = 0, i = 0, r = e.length; n < r; n++) { var a = e[n]; if (a && ("Daydream Controller" === a.id || "Gear VR Controller" === a.id || "Oculus Go Controller" === a.id || "OpenVR Gamepad" === a.id || a.id.startsWith("Oculus Touch") || a.id.startsWith("Spatial Controller"))) { if (i === t) return a; i++ } } }(t); if (void 0 !== n && void 0 !== n.pose) { if (null === n.pose) return; var i = n.pose; !1 === i.hasPosition && e.position.set(.2, -.6, -.05), null !== i.position && e.position.fromArray(i.position), null !== i.orientation && e.quaternion.fromArray(i.orientation), e.matrix.compose(e.position, e.quaternion, e.scale), e.matrix.premultiply(c), e.matrix.decompose(e.position, e.quaternion, e.scale), e.matrixWorldNeedsUpdate = !0, e.visible = !0; i = "Daydream Controller" === n.id ? 0 : 1; w[t] !== n.buttons[i].pressed && (w[t] = n.buttons[i].pressed, !0 === w[t] ? e.dispatchEvent({ type: "selectstart" }) : (e.dispatchEvent({ type: "selectend" }), e.dispatchEvent({ type: "select" }))) } else e.visible = !1 } } this.enabled = !1, this.getController = function (t) { var e = s[t]; return void 0 === e && ((e = new No).matrixAutoUpdate = !1, e.visible = !1, s[t] = e), e }, this.getDevice = function () { return r }, this.setDevice = function (t) { void 0 !== t && (r = t), M.setContext(t) }, this.setFramebufferScaleFactor = function (t) { l = t }, this.setFrameOfReferenceType = function (t) { u = t }, this.setPoseTarget = function (t) { void 0 !== t && (o = t) }, this.getCamera = function (t) { var e = "stage" === u ? 1.6 : 0; if (!1 === y()) return t.position.set(0, e, 0), t.rotation.set(0, 0, 0), t; r.depthNear = t.near, r.depthFar = t.far, r.getFrameData(a), "stage" === u && ((n = r.stageParameters) ? c.fromArray(n.sittingToStandingTransform) : c.makeTranslation(0, e, 0)); var n = a.pose, e = null !== o ? o : t; e.matrix.copy(c), e.matrix.decompose(e.position, e.quaternion, e.scale), null !== n.orientation && (d.fromArray(n.orientation), e.quaternion.multiply(d)), null !== n.position && (d.setFromRotationMatrix(c), f.fromArray(n.position), f.applyQuaternion(d), e.position.add(f)), e.updateMatrixWorld(), m.near = t.near, g.near = t.near, m.far = t.far, g.far = t.far, m.matrixWorldInverse.fromArray(a.leftViewMatrix), g.matrixWorldInverse.fromArray(a.rightViewMatrix), h.getInverse(c), "stage" === u && (m.matrixWorldInverse.multiply(h), g.matrixWorldInverse.multiply(h)); e = e.parent; null !== e && (p.getInverse(e.matrixWorld), m.matrixWorldInverse.multiply(p), g.matrixWorldInverse.multiply(p)), m.matrixWorld.getInverse(m.matrixWorldInverse), g.matrixWorld.getInverse(g.matrixWorldInverse), m.projectionMatrix.fromArray(a.leftProjectionMatrix), g.projectionMatrix.fromArray(a.rightProjectionMatrix), ms(v, m, g); e = r.getLayers(); return e.length && (null !== (e = e[0]).leftBounds && 4 === e.leftBounds.length && m.bounds.fromArray(e.leftBounds), null !== e.rightBounds && 4 === e.rightBounds.length && g.bounds.fromArray(e.rightBounds)), _(), v }, this.getStandingMatrix = function () { return c }, this.isPresenting = y; var M = new ei; this.setAnimationLoop = function (t) { M.setAnimationLoop(t) }, this.submitFrame = function () { y() && r.submitFrame() }, this.dispose = function () { "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", t) } } function vs(e) { var n = e.context, i = null, u = null, r = 1, p = null, a = "stage", d = null, f = [], m = []; function o() { return null !== u && null !== p } var s = new zo; s.layers.enable(1), s.viewport = new Ln; var c = new zo; c.layers.enable(2), c.viewport = new Ln; var g = new Uo([s, c]); function h(t) { var e = f[m.indexOf(t.inputSource)]; e && e.dispatchEvent({ type: t.type }) } function l() { e.setFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), x.stop() } function v(t, e) { null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld) } g.layers.enable(1), g.layers.enable(2), this.enabled = !1, this.getController = function (t) { var e = f[t]; return void 0 === e && ((e = new No).matrixAutoUpdate = !1, e.visible = !1, f[t] = e), e }, this.getDevice = function () { return i }, this.setDevice = function (t) { void 0 !== t && (i = t), t instanceof XRDevice && n.setCompatibleXRDevice(t) }, this.setFramebufferScaleFactor = function (t) { r = t }, this.setFrameOfReferenceType = function (t) { a = t }, this.setSession = function (t) { null !== (u = t) && (u.addEventListener("select", h), u.addEventListener("selectstart", h), u.addEventListener("selectend", h), u.addEventListener("end", l), u.baseLayer = new XRWebGLLayer(u, n, { framebufferScaleFactor: r }), u.requestFrameOfReference(a).then(function (t) { p = t, e.setFramebuffer(u.baseLayer.framebuffer), x.setContext(u), x.start() }), m = u.getInputSources(), u.addEventListener("inputsourceschange", function () { m = u.getInputSources(), console.log(m); for (var t = 0; t < f.length; t++)f[t].userData.inputSource = m[t] })) }, this.getCamera = function (t) { if (o()) { var e = t.parent, n = g.cameras; v(g, e); for (var i = 0; i < n.length; i++)v(n[i], e); t.matrixWorld.copy(g.matrixWorld); for (var r = t.children, i = 0, a = r.length; i < a; i++)r[i].updateMatrixWorld(!0); return ms(g, s, c), g } return t }, this.isPresenting = o; var y = null; var x = new ei; x.setAnimationLoop(function (t, e) { if (null !== (d = e.getDevicePose(p))) for (var n = u.baseLayer, i = e.views, r = 0; r < i.length; r++) { var a = i[r], o = n.getViewport(a), s = d.getViewMatrix(a), c = g.cameras[r]; c.matrix.fromArray(s).getInverse(c.matrix), c.projectionMatrix.fromArray(a.projectionMatrix), c.viewport.set(o.x, o.y, o.width, o.height), 0 === r && g.matrix.copy(c.matrix) } for (r = 0; r < f.length; r++) { var h = f[r], l = m[r]; if (l) { l = e.getInputPose(l, p); if (null !== l) { "targetRay" in l ? h.matrix.elements = l.targetRay.transformMatrix : "pointerMatrix" in l && (h.matrix.elements = l.pointerMatrix), h.matrix.decompose(h.position, h.rotation, h.scale), h.visible = !0; continue } } h.visible = !1 } y && y(t) }), this.setAnimationLoop = function (t) { y = t }, this.dispose = function () { }, this.getStandingMatrix = function () { return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new je }, this.submitFrame = function () { } } function ys(t) { console.log("THREE.WebGLRenderer", "102"); var i = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), e = void 0 !== t.context ? t.context : null, n = void 0 !== t.alpha && t.alpha, r = void 0 === t.depth || t.depth, a = void 0 === t.stencil || t.stencil, o = void 0 !== t.antialias && t.antialias, s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha, c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer, h = void 0 !== t.powerPreference ? t.powerPreference : "default", f = null, E = null; this.domElement = i, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = Mt, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4; var S, y, T, A, l, L, u, x, p, m, d, g, v, b, w, _, M, R, P = this, C = !1, O = null, I = null, D = null, N = -1, B = { geometry: null, program: null, wireframe: !1 }, z = null, U = null, G = new Ln, F = new Ln, H = null, V = 0, k = i.width, j = i.height, W = 1, q = new Ln(0, 0, k, j), X = new Ln(0, 0, k, j), Y = !1, J = new Un, Z = new ca, Q = !1, K = !1, $ = new je, tt = new qe; function et() { return null === I ? W : 1 } try { var nt = { alpha: n, depth: r, stencil: a, antialias: o, premultipliedAlpha: s, preserveDrawingBuffer: c, powerPreference: h }; if (i.addEventListener("webglcontextlost", ot, !1), i.addEventListener("webglcontextrestored", st, !1), null === (S = e || i.getContext("webgl", nt) || i.getContext("experimental-webgl", nt))) throw null !== i.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context."); void 0 === S.getShaderPrecisionFormat && (S.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (t) { throw console.error("THREE.WebGLRenderer: " + t.message), t } function it() { y = new ha(S), (T = new sa(S, y, t)).isWebGL2 || (y.get("WEBGL_depth_texture"), y.get("OES_texture_float"), y.get("OES_texture_half_float"), y.get("OES_texture_half_float_linear"), y.get("OES_standard_derivatives"), y.get("OES_element_index_uint"), y.get("ANGLE_instanced_arrays")), y.get("OES_texture_float_linear"), R = new Do(0, y, T), (A = new Oo(S, y, R, T)).scissor(F.copy(X).multiplyScalar(W)), A.viewport(G.copy(q).multiplyScalar(W)), l = new pa, L = new xo, u = new Io(S, y, A, L, T, R, l), x = new ni(S), p = new la(0, x, l), m = new ma(p, l), w = new fa(S), d = new yo(P, y, T), g = new Mo, v = new Lo, b = new aa(P, A, m, s), _ = new oa(S, y, l, T), M = new ua(S, y, l, T), l.programs = d.programs, P.context = S, P.capabilities = T, P.extensions = y, P.properties = L, P.renderLists = g, P.state = A, P.info = l } it(); var rt = null; "undefined" != typeof navigator && (rt = new ("xr" in navigator ? vs : gs)(P)), this.vr = rt; var at = new Co(P, m, T.maxTextureSize); function ot(t) { t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), C = !0 } function st() { console.log("THREE.WebGLRenderer: Context Restored."), C = !1, it() } function ct(t) { t = t.target; t.removeEventListener("dispose", ct), ht(t = t), L.remove(t) } function ht(t) { var e = L.get(t).program; (t.program = void 0) !== e && d.releaseProgram(e) } this.shadowMap = at, this.getContext = function () { return S }, this.getContextAttributes = function () { return S.getContextAttributes() }, this.forceContextLoss = function () { var t = y.get("WEBGL_lose_context"); t && t.loseContext() }, this.forceContextRestore = function () { var t = y.get("WEBGL_lose_context"); t && t.restoreContext() }, this.getPixelRatio = function () { return W }, this.setPixelRatio = function (t) { void 0 !== t && (W = t, this.setSize(k, j, !1)) }, this.getSize = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new ke), t.set(k, j) }, this.setSize = function (t, e, n) { rt.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (k = t, j = e, i.width = t * W, i.height = e * W, !1 !== n && (i.style.width = t + "px", i.style.height = e + "px"), this.setViewport(0, 0, t, e)) }, this.getDrawingBufferSize = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new ke), t.set(k * W, j * W) }, this.setDrawingBufferSize = function (t, e, n) { k = t, j = e, W = n, i.width = t * n, i.height = e * n, this.setViewport(0, 0, t, e) }, this.getCurrentViewport = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new Ln), t.copy(G) }, this.getViewport = function (t) { return t.copy(q) }, this.setViewport = function (t, e, n, i) { t.isVector4 ? q.set(t.x, t.y, t.z, t.w) : q.set(t, e, n, i), A.viewport(G.copy(q).multiplyScalar(W)) }, this.getScissor = function (t) { return t.copy(X) }, this.setScissor = function (t, e, n, i) { t.isVector4 ? X.set(t.x, t.y, t.z, t.w) : X.set(t, e, n, i), A.scissor(F.copy(X).multiplyScalar(W)) }, this.getScissorTest = function () { return Y }, this.setScissorTest = function (t) { A.setScissorTest(Y = t) }, this.getClearColor = function () { return b.getClearColor() }, this.setClearColor = function () { b.setClearColor.apply(b, arguments) }, this.getClearAlpha = function () { return b.getClearAlpha() }, this.setClearAlpha = function () { b.setClearAlpha.apply(b, arguments) }, this.clear = function (t, e, n) { var i = 0; void 0 !== t && !t || (i |= 16384), void 0 !== e && !e || (i |= 256), void 0 !== n && !n || (i |= 1024), S.clear(i) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { i.removeEventListener("webglcontextlost", ot, !1), i.removeEventListener("webglcontextrestored", st, !1), g.dispose(), v.dispose(), L.dispose(), m.dispose(), rt.dispose(), ft.stop() }, this.renderBufferImmediate = function (t, e) { A.initAttributes(); var n = L.get(t); t.hasPositions && !n.position && (n.position = S.createBuffer()), t.hasNormals && !n.normal && (n.normal = S.createBuffer()), t.hasUvs && !n.uv && (n.uv = S.createBuffer()), t.hasColors && !n.color && (n.color = S.createBuffer()); e = e.getAttributes(); t.hasPositions && (S.bindBuffer(34962, n.position), S.bufferData(34962, t.positionArray, 35048), A.enableAttribute(e.position), S.vertexAttribPointer(e.position, 3, 5126, !1, 0, 0)), t.hasNormals && (S.bindBuffer(34962, n.normal), S.bufferData(34962, t.normalArray, 35048), A.enableAttribute(e.normal), S.vertexAttribPointer(e.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (S.bindBuffer(34962, n.uv), S.bufferData(34962, t.uvArray, 35048), A.enableAttribute(e.uv), S.vertexAttribPointer(e.uv, 2, 5126, !1, 0, 0)), t.hasColors && (S.bindBuffer(34962, n.color), S.bufferData(34962, t.colorArray, 35048), A.enableAttribute(e.color), S.vertexAttribPointer(e.color, 3, 5126, !1, 0, 0)), A.disableUnusedAttributes(), S.drawArrays(4, 0, t.count), t.count = 0 }, this.renderBufferDirect = function (t, e, n, i, r, a) { var o = r.isMesh && r.matrixWorld.determinant() < 0; A.setMaterial(i, o); var s = yt(t, e, i, r), c = !1; B.geometry === n.id && B.program === s.id && B.wireframe === (!0 === i.wireframe) || (B.geometry = n.id, B.program = s.id, B.wireframe = !0 === i.wireframe, c = !0), r.morphTargetInfluences && (w.update(r, n, i, s), c = !0); o = n.index, t = n.attributes.position, e = 1; !0 === i.wireframe && (o = p.getWireframeAttribute(n), e = 2); var h = _; null !== o && (l = x.get(o), (h = M).setIndex(l)), c && (function (t, e, n) { if (n && n.isInstancedBufferGeometry && !T.isWebGL2 && null === y.get("ANGLE_instanced_arrays")) return console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); A.initAttributes(); var i, r = n.attributes, a = e.getAttributes(), o = t.defaultAttributeValues; for (i in a) { var s = a[i]; if (0 <= s) { var c = r[i]; if (void 0 !== c) { var h, l, u, p, d, f = c.normalized, m = c.itemSize, g = x.get(c); void 0 !== g && (h = g.buffer, l = g.type, u = g.bytesPerElement, c.isInterleavedBufferAttribute ? (p = c.data, d = p.stride, g = c.offset, p && p.isInstancedInterleavedBuffer ? (A.enableAttributeAndDivisor(s, p.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = p.meshPerAttribute * p.count)) : A.enableAttribute(s), S.bindBuffer(34962, h), S.vertexAttribPointer(s, m, l, f, d * u, g * u)) : (c.isInstancedBufferAttribute ? (A.enableAttributeAndDivisor(s, c.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = c.meshPerAttribute * c.count)) : A.enableAttribute(s), S.bindBuffer(34962, h), S.vertexAttribPointer(s, m, l, f, 0, 0))) } else if (void 0 !== o) { var v = o[i]; if (void 0 !== v) switch (v.length) { case 2: S.vertexAttrib2fv(s, v); break; case 3: S.vertexAttrib3fv(s, v); break; case 4: S.vertexAttrib4fv(s, v); break; default: S.vertexAttrib1fv(s, v) } } } } A.disableUnusedAttributes() }(i, s, n), null !== o && S.bindBuffer(34963, l.buffer)); s = 1 / 0; null !== o ? s = o.count : void 0 !== t && (s = t.count); var l = n.drawRange.start * e, o = n.drawRange.count * e, t = null !== a ? a.start * e : 0, a = null !== a ? a.count * e : 1 / 0, e = Math.max(l, t), a = Math.min(s, l + o, t + a) - 1, a = Math.max(0, a - e + 1); if (0 !== a) { if (r.isMesh) if (!0 === i.wireframe) A.setLineWidth(i.wireframeLinewidth * et()), h.setMode(1); else switch (r.drawMode) { case Pe: h.setMode(4); break; case 1: h.setMode(5); break; case 2: h.setMode(6) } else r.isLine ? (void 0 === (i = i.linewidth) && (i = 1), A.setLineWidth(i * et()), r.isLineSegments ? h.setMode(1) : r.isLineLoop ? h.setMode(2) : h.setMode(3)) : r.isPoints ? h.setMode(0) : r.isSprite && h.setMode(4); n && n.isInstancedBufferGeometry ? 0 < n.maxInstancedCount && h.renderInstances(n, e, a) : h.render(e, a) } }, this.compile = function (n, t) { (E = v.get(n, t)).init(), n.traverse(function (t) { t.isLight && (E.pushLight(t), t.castShadow && E.pushShadow(t)) }), E.setupLights(t), n.traverse(function (t) { if (t.material) if (Array.isArray(t.material)) for (var e = 0; e < t.material.length; e++)vt(t.material[e], n.fog, t); else vt(t.material, n.fog, t) }) }; var lt = null; var ut, pt, dt, ft = new ei; function mt(t, e, n, i) { for (var r = 0, a = t.length; r < a; r++) { var o = t[r], s = o.object, c = o.geometry, h = void 0 === i ? o.material : i, l = o.group; if (n.isArrayCamera) for (var u = (U = n).cameras, p = 0, d = u.length; p < d; p++) { var f, m, g, v, y = u[p]; s.layers.test(y.layers) && ("viewport" in y ? A.viewport(G.copy(y.viewport)) : (f = (v = y.bounds).x * k, m = v.y * j, g = v.z * k, v = v.w * j, A.viewport(G.set(f, m, g, v).multiplyScalar(W))), E.setupLights(y), gt(s, e, y, c, h, l)) } else U = null, gt(s, e, n, c, h, l) } } function gt(t, e, n, i, r, a) { var o, s; t.onBeforeRender(P, e, n, i, r, a), E = v.get(e, U || n), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject ? (A.setMaterial(r), o = yt(n, e.fog, r, t), B.geometry = null, B.program = null, B.wireframe = !1, s = o, t.render(function (t) { P.renderBufferImmediate(t, s) })) : P.renderBufferDirect(n, e.fog, i, r, t, a), t.onAfterRender(P, e, n, i, r, a), E = v.get(e, U || n) } function vt(t, e, n) { var i = L.get(t), r = E.state.lights, a = E.state.shadowsArray, o = i.lightsHash, s = r.state.hash, c = d.getParameters(t, r.state, a, e, Z.numPlanes, Z.numIntersection, n), h = d.getProgramCode(t, c), a = i.program, n = !0; if (void 0 === a) t.addEventListener("dispose", ct); else if (a.code !== h) ht(t); else if (o.stateID !== s.stateID || o.directionalLength !== s.directionalLength || o.pointLength !== s.pointLength || o.spotLength !== s.spotLength || o.rectAreaLength !== s.rectAreaLength || o.hemiLength !== s.hemiLength || o.shadowsLength !== s.shadowsLength) o.stateID = s.stateID, o.directionalLength = s.directionalLength, o.pointLength = s.pointLength, o.spotLength = s.spotLength, o.rectAreaLength = s.rectAreaLength, o.hemiLength = s.hemiLength, o.shadowsLength = s.shadowsLength, n = !1; else { if (void 0 !== c.shaderID) return; n = !1 } n && (c.shaderID ? (n = ti[c.shaderID], i.shader = { name: t.type, uniforms: Fn(n.uniforms), vertexShader: n.vertexShader, fragmentShader: n.fragmentShader }) : i.shader = { name: t.type, uniforms: t.uniforms, vertexShader: t.vertexShader, fragmentShader: t.fragmentShader }, t.onBeforeCompile(i.shader, P), h = d.getProgramCode(t, c), a = d.acquireProgram(t, i.shader, c, h), i.program = a, t.program = a); var l = a.getAttributes(); if (t.morphTargets) for (var u = t.numSupportedMorphTargets = 0; u < P.maxMorphTargets; u++)0 <= l["morphTarget" + u] && t.numSupportedMorphTargets++; if (t.morphNormals) for (u = t.numSupportedMorphNormals = 0; u < P.maxMorphNormals; u++)0 <= l["morphNormal" + u] && t.numSupportedMorphNormals++; a = i.shader.uniforms; (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (i.numClippingPlanes = Z.numPlanes, i.numIntersection = Z.numIntersection, a.clippingPlanes = Z.uniform), i.fog = e, void 0 === o && (i.lightsHash = o = {}), o.stateID = s.stateID, o.directionalLength = s.directionalLength, o.pointLength = s.pointLength, o.spotLength = s.spotLength, o.rectAreaLength = s.rectAreaLength, o.hemiLength = s.hemiLength, o.shadowsLength = s.shadowsLength, t.lights && (a.ambientLightColor.value = r.state.ambient, a.directionalLights.value = r.state.directional, a.spotLights.value = r.state.spot, a.rectAreaLights.value = r.state.rectArea, a.pointLights.value = r.state.point, a.hemisphereLights.value = r.state.hemi, a.directionalShadowMap.value = r.state.directionalShadowMap, a.directionalShadowMatrix.value = r.state.directionalShadowMatrix, a.spotShadowMap.value = r.state.spotShadowMap, a.spotShadowMatrix.value = r.state.spotShadowMatrix, a.pointShadowMap.value = r.state.pointShadowMap, a.pointShadowMatrix.value = r.state.pointShadowMatrix); r = i.program.getUniforms(), a = oo.seqWithValue(r.seq, a); i.uniformsList = a } function yt(t, e, n, i) { V = 0; var r = L.get(n), a = E.state.lights, o = r.lightsHash, s = a.state.hash; Q && (!K && t === z || (M = t === z && n.id === N, Z.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, t, r, M))), !1 === n.needsUpdate && (void 0 === r.program || n.fog && r.fog !== e || n.lights && (o.stateID !== s.stateID || o.directionalLength !== s.directionalLength || o.pointLength !== s.pointLength || o.spotLength !== s.spotLength || o.rectAreaLength !== s.rectAreaLength || o.hemiLength !== s.hemiLength || o.shadowsLength !== s.shadowsLength) || void 0 !== r.numClippingPlanes && (r.numClippingPlanes !== Z.numPlanes || r.numIntersection !== Z.numIntersection)) && (n.needsUpdate = !0), n.needsUpdate && (vt(n, e, i), n.needsUpdate = !1); var c, h, l, u, p, d, f, m, g, v, y, x, b = !1, w = !1, _ = !1, a = r.program, M = a.getUniforms(), o = r.shader.uniforms; return A.useProgram(a.program) && (_ = w = b = !0), n.id !== N && (N = n.id, w = !0), !b && z === t || (M.setValue(S, "projectionMatrix", t.projectionMatrix), T.logarithmicDepthBuffer && M.setValue(S, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), z !== t && (z = t, _ = w = !0), !(n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.envMap) || void 0 !== (c = M.map.cameraPosition) && c.setValue(S, tt.setFromMatrixPosition(t.matrixWorld)), (n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && M.setValue(S, "viewMatrix", t.matrixWorldInverse)), n.skinning && (M.setOptional(S, i, "bindMatrix"), M.setOptional(S, i, "bindMatrixInverse"), (s = i.skeleton) && (b = s.bones, T.floatVertexTextures ? (void 0 === s.boneTexture && (c = Math.sqrt(4 * b.length), c = Ve.ceilPowerOfTwo(c), c = Math.max(c, 4), (t = new Float32Array(c * c * 4)).set(s.boneMatrices), (b = new On(t, c, c, Jt, Ht)).needsUpdate = !0, s.boneMatrices = t, s.boneTexture = b, s.boneTextureSize = c), M.setValue(S, "boneTexture", s.boneTexture), M.setValue(S, "boneTextureSize", s.boneTextureSize)) : M.setOptional(S, s, "boneMatrices"))), w && (M.setValue(S, "toneMappingExposure", P.toneMappingExposure), M.setValue(S, "toneMappingWhitePoint", P.toneMappingWhitePoint), n.lights && (x = _, (_ = o).ambientLightColor.needsUpdate = x, _.directionalLights.needsUpdate = x, _.pointLights.needsUpdate = x, _.spotLights.needsUpdate = x, _.rectAreaLights.needsUpdate = x, _.hemisphereLights.needsUpdate = x), e && n.fog && (x = e, (e = o).fogColor.value = x.color, x.isFog ? (e.fogNear.value = x.near, e.fogFar.value = x.far) : x.isFogExp2 && (e.fogDensity.value = x.density)), n.isMeshBasicMaterial ? xt(o, n) : n.isMeshLambertMaterial ? (xt(o, n), v = o, (y = n).emissiveMap && (v.emissiveMap.value = y.emissiveMap)) : n.isMeshPhongMaterial ? (xt(o, n), n.isMeshToonMaterial ? (bt(v = o, y = n), y.gradientMap && (v.gradientMap.value = y.gradientMap)) : bt(o, n)) : n.isMeshStandardMaterial ? (xt(o, n), n.isMeshPhysicalMaterial ? (wt(m = o, g = n), m.reflectivity.value = g.reflectivity, m.clearCoat.value = g.clearCoat, m.clearCoatRoughness.value = g.clearCoatRoughness) : wt(o, n)) : n.isMeshMatcapMaterial ? (xt(o, n), m = o, (g = n).matcap && (m.matcap.value = g.matcap), g.bumpMap && (m.bumpMap.value = g.bumpMap, m.bumpScale.value = g.bumpScale, g.side === _t && (m.bumpScale.value *= -1)), g.normalMap && (m.normalMap.value = g.normalMap, m.normalScale.value.copy(g.normalScale), g.side === _t && m.normalScale.value.negate()), g.displacementMap && (m.displacementMap.value = g.displacementMap, m.displacementScale.value = g.displacementScale, m.displacementBias.value = g.displacementBias)) : n.isMeshDepthMaterial ? (xt(o, n), d = o, (f = n).displacementMap && (d.displacementMap.value = f.displacementMap, d.displacementScale.value = f.displacementScale, d.displacementBias.value = f.displacementBias)) : n.isMeshDistanceMaterial ? (xt(o, n), d = o, (f = n).displacementMap && (d.displacementMap.value = f.displacementMap, d.displacementScale.value = f.displacementScale, d.displacementBias.value = f.displacementBias), d.referencePosition.value.copy(f.referencePosition), d.nearDistance.value = f.nearDistance, d.farDistance.value = f.farDistance) : n.isMeshNormalMaterial ? (xt(o, n), u = o, (p = n).bumpMap && (u.bumpMap.value = p.bumpMap, u.bumpScale.value = p.bumpScale, p.side === _t && (u.bumpScale.value *= -1)), p.normalMap && (u.normalMap.value = p.normalMap, u.normalScale.value.copy(p.normalScale), p.side === _t && u.normalScale.value.negate()), p.displacementMap && (u.displacementMap.value = p.displacementMap, u.displacementScale.value = p.displacementScale, u.displacementBias.value = p.displacementBias)) : n.isLineBasicMaterial ? (u = n, (p = o).diffuse.value = u.color, p.opacity.value = u.opacity, n.isLineDashedMaterial && (p = n, (u = o).dashSize.value = p.dashSize, u.totalSize.value = p.dashSize + p.gapSize, u.scale.value = p.scale)) : n.isPointsMaterial ? (l = n, (h = o).diffuse.value = l.color, h.opacity.value = l.opacity, h.size.value = l.size * W, h.scale.value = .5 * j, h.map.value = l.map, null !== l.map && (!0 === l.map.matrixAutoUpdate && l.map.updateMatrix(), h.uvTransform.value.copy(l.map.matrix))) : n.isSpriteMaterial ? (h = n, (l = o).diffuse.value = h.color, l.opacity.value = h.opacity, l.rotation.value = h.rotation, l.map.value = h.map, null !== h.map && (!0 === h.map.matrixAutoUpdate && h.map.updateMatrix(), l.uvTransform.value.copy(h.map.matrix))) : n.isShadowMaterial && (o.color.value = n.color, o.opacity.value = n.opacity), void 0 !== o.ltc_1 && (o.ltc_1.value = $n.LTC_1), void 0 !== o.ltc_2 && (o.ltc_2.value = $n.LTC_2), oo.upload(S, r.uniformsList, o, P)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (oo.upload(S, r.uniformsList, o, P), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && M.setValue(S, "center", i.center), M.setValue(S, "modelViewMatrix", i.modelViewMatrix), M.setValue(S, "normalMatrix", i.normalMatrix), M.setValue(S, "modelMatrix", i.matrixWorld), a } function xt(t, e) { var n; t.opacity.value = e.opacity, e.color && (t.diffuse.value = e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio, t.maxMipLevel.value = L.get(e.envMap).__maxMipLevel), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map ? n = e.map : e.specularMap ? n = e.specularMap : e.displacementMap ? n = e.displacementMap : e.normalMap ? n = e.normalMap : e.bumpMap ? n = e.bumpMap : e.roughnessMap ? n = e.roughnessMap : e.metalnessMap ? n = e.metalnessMap : e.alphaMap ? n = e.alphaMap : e.emissiveMap && (n = e.emissiveMap), void 0 !== n && (n.isWebGLRenderTarget && (n = n.texture), !0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix)) } function bt(t, e) { t.specular.value = e.specular, t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === _t && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === _t && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) } function wt(t, e) { t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === _t && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === _t && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity) } ft.setAnimationLoop(function (t) { rt.isPresenting() || lt && lt(t) }), "undefined" != typeof window && ft.setContext(window), this.setAnimationLoop = function (t) { lt = t, rt.setAnimationLoop(t), ft.start() }, this.render = function (t, e) { var n, i, r; void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), i = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), r = arguments[3]), e && e.isCamera ? C || (B.geometry = null, B.program = null, B.wireframe = !1, N = -1, !(z = null) === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), rt.enabled && (e = rt.getCamera(e)), (E = v.get(t, e)).init(), t.onBeforeRender(P, t, e, i || I), $.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), J.setFromMatrix($), K = this.localClippingEnabled, Q = Z.init(this.clippingPlanes, K, e), (f = g.get(t, e)).init(), function t(e, n, i, r) { if (!1 === e.visible) return; var a = e.layers.test(n.layers); if (a) if (e.isGroup) i = e.renderOrder; else if (e.isLight) E.pushLight(e), e.castShadow && E.pushShadow(e); else if (e.isSprite) e.frustumCulled && !J.intersectsSprite(e) || (r && tt.setFromMatrixPosition(e.matrixWorld).applyMatrix4($), o = m.update(e), s = e.material, f.push(e, o, s, i, tt.z, null)); else if (e.isImmediateRenderObject) r && tt.setFromMatrixPosition(e.matrixWorld).applyMatrix4($), f.push(e, null, e.material, i, tt.z, null); else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.update(), !e.frustumCulled || J.intersectsObject(e))) { r && tt.setFromMatrixPosition(e.matrixWorld).applyMatrix4($); var o = m.update(e), s = e.material; if (Array.isArray(s)) for (var c = o.groups, h = 0, l = c.length; h < l; h++) { var u = c[h], p = s[u.materialIndex]; p && p.visible && f.push(e, o, p, i, tt.z, u) } else s.visible && f.push(e, o, s, i, tt.z, null) } var d = e.children; for (var h = 0, l = d.length; h < l; h++)t(d[h], n, i, r) }(t, e, 0, P.sortObjects), !0 === P.sortObjects && f.sort(), Q && Z.beginShadows(), n = E.state.shadowsArray, at.render(n, t, e), E.setupLights(e), Q && Z.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== i && this.setRenderTarget(i), b.render(f, t, e, r), n = f.opaque, i = f.transparent, t.overrideMaterial ? (r = t.overrideMaterial, n.length && mt(n, t, e, r), i.length && mt(i, t, e, r)) : (n.length && mt(n, t, e), i.length && mt(i, t, e)), null !== I && (u.updateRenderTargetMipmap(I), u.updateMultisampleRenderTarget(I)), A.buffers.depth.setTest(!0), A.buffers.depth.setMask(!0), A.buffers.color.setMask(!0), A.setPolygonOffset(!1), t.onAfterRender(P, t, e), rt.enabled && rt.submitFrame(), E = f = null) : console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.") }, this.allocTextureUnit = function () { var t = V; return t >= T.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + t + " texture units while this GPU supports only " + T.maxTextures), V += 1, t }, this.setTexture2D = (ut = !1, function (t, e) { t && t.isWebGLRenderTarget && (ut || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), ut = !0), t = t.texture), u.setTexture2D(t, e) }), this.setTexture3D = function (t, e) { u.setTexture3D(t, e) }, this.setTexture = (pt = !1, function (t, e) { pt || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), pt = !0), u.setTexture2D(t, e) }), this.setTextureCube = (dt = !1, function (t, e) { t && t.isWebGLRenderTargetCube && (dt || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), dt = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? u.setTextureCube(t, e) : u.setTextureCubeDynamic(t, e) }), this.setFramebuffer = function (t) { O = t }, this.getRenderTarget = function () { return I }, this.setRenderTarget = function (t, e, n) { (I = t) && void 0 === L.get(t).__webglFramebuffer && u.setupRenderTarget(t); var i, r = O, a = !1; H = t ? (i = L.get(t).__webglFramebuffer, t.isWebGLRenderTargetCube ? (r = i[e || 0], a = !0) : r = t.isWebGLMultisampleRenderTarget ? L.get(t).__webglMultisampledFramebuffer : i, G.copy(t.viewport), F.copy(t.scissor), t.scissorTest) : (G.copy(q).multiplyScalar(W), F.copy(X).multiplyScalar(W), Y), D !== r && (S.bindFramebuffer(36160, r), D = r), A.viewport(G), A.scissor(F), A.setScissorTest(H), a && (t = L.get(t.texture), S.framebufferTexture2D(36160, 36064, 34069 + e || 0, t.__webglTexture, n || 0)) }, this.readRenderTargetPixels = function (t, e, n, i, r, a) { if (t && t.isWebGLRenderTarget) { var o = L.get(t).__webglFramebuffer; if (o) { var s = !1; o !== D && (S.bindFramebuffer(36160, o), s = !0); try { var c = t.texture, h = c.format, c = c.type; if (h !== Jt && R.convert(h) !== S.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); if (!(c === Nt || R.convert(c) === S.getParameter(35738) || c === Ht && (T.isWebGL2 || y.get("OES_texture_float") || y.get("WEBGL_color_buffer_float")) || c === Vt && (T.isWebGL2 ? y.get("EXT_color_buffer_float") : y.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); 36053 === S.checkFramebufferStatus(36160) ? 0 <= e && e <= t.width - i && 0 <= n && n <= t.height - r && S.readPixels(e, n, i, r, R.convert(h), R.convert(c), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") } finally { s && S.bindFramebuffer(36160, D) } } } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.") }, this.copyFramebufferToTexture = function (t, e, n) { var i = e.image.width, r = e.image.height, a = R.convert(e.format); this.setTexture2D(e, 0), S.copyTexImage2D(3553, n || 0, a, t.x, t.y, i, r, 0) }, this.copyTextureToTexture = function (t, e, n, i) { var r = e.image.width, a = e.image.height, o = R.convert(n.format), s = R.convert(n.type); this.setTexture2D(n, 0), e.isDataTexture ? S.texSubImage2D(3553, i || 0, t.x, t.y, r, a, o, s, e.image.data) : S.texSubImage2D(3553, i || 0, t.x, t.y, o, s, e.image) } } function xs(t, e) { this.name = "", this.color = new Xn(t), this.density = void 0 !== e ? e : 25e-5 } function bs(t, e, n) { this.name = "", this.color = new Xn(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== n ? n : 1e3 } function ws() { Si.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0 } function _s(t, e) { this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } function Ms(t, e, n, i) { this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i } function Es(t) { lr.call(this), this.type = "SpriteMaterial", this.color = new Xn(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(t) } function Ss(t) { var e; Si.call(this), this.type = "Sprite", void 0 === Go && (Go = new rr, e = new _s(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5), Go.setIndex([0, 1, 2, 0, 2, 3]), Go.addAttribute("position", new Ms(e, 3, 0, !1)), Go.addAttribute("uv", new Ms(e, 2, 3, !1))), this.geometry = Go, this.material = void 0 !== t ? t : new Es, this.center = new ke(.5, .5) } function Ts(t, e, n, i, r, a) { ko.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (jo.x = a * ko.x - r * ko.y, jo.y = r * ko.x + a * ko.y) : jo.copy(ko), t.copy(e), t.x += jo.x, t.y += jo.y, t.applyMatrix4(Wo) } function As() { Si.call(this), this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }) } function Ls(t, e) { t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), na.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new je, this.bindMatrixInverse = new je } function Rs(t, e) { if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === e) this.calculateInverses(); else if (this.bones.length === e.length) this.boneInverses = e.slice(0); else { console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = []; for (var n = 0, i = this.bones.length; n < i; n++)this.boneInverses.push(new je) } } function Ps() { Si.call(this), this.type = "Bone" } function Cs(t) { lr.call(this), this.type = "LineBasicMaterial", this.color = new Xn(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(t) } function Os(t, e, n) { 1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), Si.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new rr, this.material = void 0 !== e ? e : new Cs({ color: 16777215 * Math.random() }) } function Is(t, e) { Os.call(this, t, e), this.type = "LineSegments" } function Ds(t, e) { Os.call(this, t, e), this.type = "LineLoop" } function Ns(t) { lr.call(this), this.type = "PointsMaterial", this.color = new Xn(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.lights = !1, this.setValues(t) } function Bs(t, e) { Si.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new rr, this.material = void 0 !== e ? e : new Ns({ color: 16777215 * Math.random() }) } function zs(t, e, n, i, r, a, o, s, c) { An.call(this, t, e, n, i, r, a, o, s, c), this.format = void 0 !== o ? o : Yt, this.minFilter = void 0 !== a ? a : Ot, this.magFilter = void 0 !== r ? r : Ot, this.generateMipmaps = !1 } function Us(t, e, n, i, r, a, o, s, c, h, l, u) { An.call(this, null, a, o, s, c, h, i, r, l, u), this.image = { width: e, height: n }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1 } function Gs(t, e, n, i, r, a, o, s, c) { An.call(this, t, e, n, i, r, a, o, s, c), this.needsUpdate = !0 } function Fs(t, e, n, i, r, a, o, s, c, h) { if ((h = void 0 !== h ? h : $t) !== $t && h !== te) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); void 0 === n && h === $t && (n = Ut), void 0 === n && h === te && (n = qt), An.call(this, null, i, r, a, o, s, h, n, c), this.image = { width: t, height: e }, this.magFilter = void 0 !== o ? o : Rt, this.minFilter = void 0 !== s ? s : Rt, this.flipY = !1, this.generateMipmaps = !1 } function Hs(t) { rr.call(this), this.type = "WireframeGeometry"; var e, n, i, r, a, o, s = [], c = [0, 0], h = {}, l = ["a", "b", "c"]; if (t && t.isGeometry) { for (var u = t.faces, p = 0, d = u.length; p < d; p++)for (var f = u[p], m = 0; m < 3; m++)r = f[l[m]], a = f[l[(m + 1) % 3]], c[0] = Math.min(r, a), c[1] = Math.max(r, a), void 0 === h[o = c[0] + "," + c[1]] && (h[o] = { index1: c[0], index2: c[1] }); for (o in h) i = h[o], w = t.vertices[i.index1], s.push(w.x, w.y, w.z), w = t.vertices[i.index2], s.push(w.x, w.y, w.z) } else if (t && t.isBufferGeometry) { var g, v, y, x, b, w = new qe; if (null !== t.index) { for (g = t.attributes.position, v = t.index, 0 === (y = t.groups).length && (y = [{ start: 0, count: v.count, materialIndex: 0 }]), e = 0, n = y.length; e < n; ++e)for (d = (p = (x = y[e]).start) + x.count; p < d; p += 3)for (m = 0; m < 3; m++)r = v.getX(p + m), a = v.getX(p + (m + 1) % 3), c[0] = Math.min(r, a), c[1] = Math.max(r, a), void 0 === h[o = c[0] + "," + c[1]] && (h[o] = { index1: c[0], index2: c[1] }); for (o in h) i = h[o], w.fromBufferAttribute(g, i.index1), s.push(w.x, w.y, w.z), w.fromBufferAttribute(g, i.index2), s.push(w.x, w.y, w.z) } else for (p = 0, d = (g = t.attributes.position).count / 3; p < d; p++)for (m = 0; m < 3; m++)b = 3 * p + m, w.fromBufferAttribute(g, b), s.push(w.x, w.y, w.z), b = 3 * p + (m + 1) % 3, w.fromBufferAttribute(g, b), s.push(w.x, w.y, w.z) } this.addAttribute("position", new ki(s, 3)) } function Vs(t, e, n) { Di.call(this), this.type = "ParametricGeometry", this.parameters = { func: t, slices: e, stacks: n }, this.fromBufferGeometry(new ks(t, e, n)), this.mergeVertices() } function ks(t, e, n) { rr.call(this), this.type = "ParametricBufferGeometry", this.parameters = { func: t, slices: e, stacks: n }; var i = [], r = [], a = [], o = [], s = new qe, c = new qe, h = new qe, l = new qe, u = new qe; t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."); for (var p = e + 1, d = 0; d <= n; d++)for (var f = d / n, m = 0; m <= e; m++) { var g = m / e; t(g, f, c), r.push(c.x, c.y, c.z), 0 <= g - 1e-5 ? (t(g - 1e-5, f, h), l.subVectors(c, h)) : (t(1e-5 + g, f, h), l.subVectors(h, c)), 0 <= f - 1e-5 ? (t(g, f - 1e-5, h), u.subVectors(c, h)) : (t(g, 1e-5 + f, h), u.subVectors(h, c)), s.crossVectors(l, u).normalize(), a.push(s.x, s.y, s.z), o.push(g, f) } for (d = 0; d < n; d++)for (m = 0; m < e; m++) { var v = d * p + m, y = d * p + m + 1, x = (d + 1) * p + m + 1, b = (d + 1) * p + m; i.push(v, y, b), i.push(y, x, b) } this.setIndex(i), this.addAttribute("position", new ki(r, 3)), this.addAttribute("normal", new ki(a, 3)), this.addAttribute("uv", new ki(o, 2)) } function js(t, e, n, i) { Di.call(this), this.type = "PolyhedronGeometry", this.parameters = { vertices: t, indices: e, radius: n, detail: i }, this.fromBufferGeometry(new Ws(t, e, n, i)), this.mergeVertices() } function Ws(n, r, t, e) { rr.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = { vertices: n, indices: r, radius: t, detail: e }, t = t || 1; var l = [], u = []; function p(t) { l.push(t.x, t.y, t.z) } function a(t, e) { t *= 3; e.x = n[0 + t], e.y = n[1 + t], e.z = n[2 + t] } function d(t, e, n, i) { i < 0 && 1 === t.x && (u[e] = t.x - 1), 0 === n.x && 0 === n.z && (u[e] = i / 2 / Math.PI + .5) } function f(t) { return Math.atan2(t.z, -t.x) } !function (u) { for (var t = new qe, e = new qe, n = new qe, i = 0; i < r.length; i += 3)a(r[i + 0], t), a(r[i + 1], e), a(r[i + 2], n), function (t, e, n) { var i, r, a = Math.pow(2, u), o = []; for (i = 0; i <= a; i++) { o[i] = []; var s = t.clone().lerp(n, i / a), c = e.clone().lerp(n, i / a), h = a - i; for (r = 0; r <= h; r++)o[i][r] = 0 === r && i === a ? s : s.clone().lerp(c, r / h) } for (i = 0; i < a; i++)for (r = 0; r < 2 * (a - i) - 1; r++) { var l = Math.floor(r / 2); r % 2 == 0 ? (p(o[i][l + 1]), p(o[i + 1][l]), p(o[i][l])) : (p(o[i][l + 1]), p(o[i + 1][l + 1]), p(o[i + 1][l])) } }(t, e, n) }(e = e || 0), function (t) { for (var e = new qe, n = 0; n < l.length; n += 3)e.x = l[n + 0], e.y = l[n + 1], e.z = l[n + 2], e.normalize().multiplyScalar(t), l[n + 0] = e.x, l[n + 1] = e.y, l[n + 2] = e.z }(t), function () { for (var t = new qe, e = 0; e < l.length; e += 3) { t.x = l[e + 0], t.y = l[e + 1], t.z = l[e + 2]; var n = f(t) / 2 / Math.PI + .5, i = function (t) { return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) }(t) / Math.PI + .5; u.push(n, 1 - i) } (function () { for (var t = new qe, e = new qe, n = new qe, i = new qe, r = new ke, a = new ke, o = new ke, s = 0, c = 0; s < l.length; s += 9, c += 6) { t.set(l[s + 0], l[s + 1], l[s + 2]), e.set(l[s + 3], l[s + 4], l[s + 5]), n.set(l[s + 6], l[s + 7], l[s + 8]), r.set(u[c + 0], u[c + 1]), a.set(u[c + 2], u[c + 3]), o.set(u[c + 4], u[c + 5]), i.copy(t).add(e).add(n).divideScalar(3); var h = f(i); d(r, c + 0, t, h), d(a, c + 2, e, h), d(o, c + 4, n, h) } })(), function () { for (var t = 0; t < u.length; t += 6) { var e = u[t + 0], n = u[t + 2], i = u[t + 4], r = Math.max(e, n, i), a = Math.min(e, n, i); .9 < r && a < .1 && (e < .2 && (u[t + 0] += 1), n < .2 && (u[t + 2] += 1), i < .2 && (u[t + 4] += 1)) } }() }(), this.addAttribute("position", new ki(l, 3)), this.addAttribute("normal", new ki(l.slice(), 3)), this.addAttribute("uv", new ki(u, 2)), 0 === e ? this.computeVertexNormals() : this.normalizeNormals() } function qs(t, e) { Di.call(this), this.type = "TetrahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new Xs(t, e)), this.mergeVertices() } function Xs(t, e) { Ws.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = { radius: t, detail: e } } function Ys(t, e) { Di.call(this), this.type = "OctahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new Js(t, e)), this.mergeVertices() } function Js(t, e) { Ws.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = { radius: t, detail: e } } function Zs(t, e) { Di.call(this), this.type = "IcosahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new Qs(t, e)), this.mergeVertices() } function Qs(t, e) { var n = (1 + Math.sqrt(5)) / 2; Ws.call(this, [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = { radius: t, detail: e } } function Ks(t, e) { Di.call(this), this.type = "DodecahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new $s(t, e)), this.mergeVertices() } function $s(t, e) { var n = (1 + Math.sqrt(5)) / 2, i = 1 / n; Ws.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = { radius: t, detail: e } } function tc(t, e, n, i, r, a) { Di.call(this), this.type = "TubeGeometry", this.parameters = { path: t, tubularSegments: e, radius: n, radialSegments: i, closed: r }, void 0 !== a && console.warn("THREE.TubeGeometry: taper has been removed."); r = new ec(t, e, n, i, r); this.tangents = r.tangents, this.normals = r.normals, this.binormals = r.binormals, this.fromBufferGeometry(r), this.mergeVertices() } function ec(a, o, s, c, t) { rr.call(this), this.type = "TubeBufferGeometry", this.parameters = { path: a, tubularSegments: o, radius: s, radialSegments: c, closed: t }, o = o || 64, s = s || 1, c = c || 8, t = t || !1; var h = a.computeFrenetFrames(o, t); this.tangents = h.tangents, this.normals = h.normals, this.binormals = h.binormals; var r, l, u = new qe, p = new qe, e = new ke, d = new qe, f = [], m = [], n = [], g = []; function i(t) { d = a.getPointAt(t / o, d); var e = h.normals[t], n = h.binormals[t]; for (l = 0; l <= c; l++) { var i = l / c * Math.PI * 2, r = Math.sin(i), i = -Math.cos(i); p.x = i * e.x + r * n.x, p.y = i * e.y + r * n.y, p.z = i * e.z + r * n.z, p.normalize(), m.push(p.x, p.y, p.z), u.x = d.x + s * p.x, u.y = d.y + s * p.y, u.z = d.z + s * p.z, f.push(u.x, u.y, u.z) } } !function () { for (r = 0; r < o; r++)i(r); i(!1 === t ? o : 0), function () { for (r = 0; r <= o; r++)for (l = 0; l <= c; l++)e.x = r / o, e.y = l / c, n.push(e.x, e.y) }(), function () { for (l = 1; l <= o; l++)for (r = 1; r <= c; r++) { var t = (c + 1) * (l - 1) + (r - 1), e = (c + 1) * l + (r - 1), n = (c + 1) * l + r, i = (c + 1) * (l - 1) + r; g.push(t, e, i), g.push(e, n, i) } }() }(), this.setIndex(g), this.addAttribute("position", new ki(f, 3)), this.addAttribute("normal", new ki(m, 3)), this.addAttribute("uv", new ki(n, 2)) } function nc(t, e, n, i, r, a, o) { Di.call(this), this.type = "TorusKnotGeometry", this.parameters = { radius: t, tube: e, tubularSegments: n, radialSegments: i, p: r, q: a }, void 0 !== o && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new ic(t, e, n, i, r, a)), this.mergeVertices() } function ic(t, e, n, i, r, a) { rr.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = { radius: t, tube: e, tubularSegments: n, radialSegments: i, p: r, q: a }, t = t || 1, e = e || .4, n = Math.floor(n) || 64, i = Math.floor(i) || 8, r = r || 2, a = a || 3; for (var o, s = [], c = [], h = [], l = [], u = new qe, p = new qe, d = new qe, f = new qe, m = new qe, g = new qe, v = new qe, y = 0; y <= n; ++y) { var x = y / n * r * Math.PI * 2; for (T(x, r, a, t, d), T(.01 + x, r, a, t, f), g.subVectors(f, d), v.addVectors(f, d), m.crossVectors(g, v), v.crossVectors(m, g), m.normalize(), v.normalize(), o = 0; o <= i; ++o) { var b = o / i * Math.PI * 2, w = -e * Math.cos(b), b = e * Math.sin(b); u.x = d.x + (w * v.x + b * m.x), u.y = d.y + (w * v.y + b * m.y), u.z = d.z + (w * v.z + b * m.z), c.push(u.x, u.y, u.z), p.subVectors(u, d).normalize(), h.push(p.x, p.y, p.z), l.push(y / n), l.push(o / i) } } for (o = 1; o <= n; o++)for (y = 1; y <= i; y++) { var _ = (i + 1) * (o - 1) + (y - 1), M = (i + 1) * o + (y - 1), E = (i + 1) * o + y, S = (i + 1) * (o - 1) + y; s.push(_, M, S), s.push(M, E, S) } function T(t, e, n, i, r) { var a = Math.cos(t), o = Math.sin(t), e = n / e * t, t = Math.cos(e); r.x = i * (2 + t) * .5 * a, r.y = i * (2 + t) * o * .5, r.z = i * Math.sin(e) * .5 } this.setIndex(s), this.addAttribute("position", new ki(c, 3)), this.addAttribute("normal", new ki(h, 3)), this.addAttribute("uv", new ki(l, 2)) } function rc(t, e, n, i, r) { Di.call(this), this.type = "TorusGeometry", this.parameters = { radius: t, tube: e, radialSegments: n, tubularSegments: i, arc: r }, this.fromBufferGeometry(new ac(t, e, n, i, r)), this.mergeVertices() } function ac(t, e, n, i, r) { rr.call(this), this.type = "TorusBufferGeometry", this.parameters = { radius: t, tube: e, radialSegments: n, tubularSegments: i, arc: r }, t = t || 1, e = e || .4, n = Math.floor(n) || 8, i = Math.floor(i) || 6, r = r || 2 * Math.PI; for (var a, o = [], s = [], c = [], h = [], l = new qe, u = new qe, p = new qe, d = 0; d <= n; d++)for (a = 0; a <= i; a++) { var f = a / i * r, m = d / n * Math.PI * 2; u.x = (t + e * Math.cos(m)) * Math.cos(f), u.y = (t + e * Math.cos(m)) * Math.sin(f), u.z = e * Math.sin(m), s.push(u.x, u.y, u.z), l.x = t * Math.cos(f), l.y = t * Math.sin(f), p.subVectors(u, l).normalize(), c.push(p.x, p.y, p.z), h.push(a / i), h.push(d / n) } for (d = 1; d <= n; d++)for (a = 1; a <= i; a++) { var g = (i + 1) * d + a - 1, v = (i + 1) * (d - 1) + a - 1, y = (i + 1) * (d - 1) + a, x = (i + 1) * d + a; o.push(g, v, x), o.push(v, y, x) } this.setIndex(o), this.addAttribute("position", new ki(s, 3)), this.addAttribute("normal", new ki(c, 3)), this.addAttribute("uv", new ki(h, 2)) } Object.assign(xs.prototype, { isFogExp2: !0, clone: function () { return new xs(this.color, this.density) }, toJSON: function () { return { type: "FogExp2", color: this.color.getHex(), density: this.density } } }), Object.assign(bs.prototype, { isFog: !0, clone: function () { return new bs(this.color, this.near, this.far) }, toJSON: function () { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } } }), ws.prototype = Object.assign(Object.create(Si.prototype), { constructor: ws, isScene: !0, copy: function (t, e) { return Si.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this }, toJSON: function (t) { var e = Si.prototype.toJSON.call(this, t); return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), Object.defineProperty(_s.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), Object.assign(_s.prototype, { isInterleavedBuffer: !0, onUploadCallback: function () { }, setArray: function (t) { if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); return this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t, this }, setDynamic: function (t) { return this.dynamic = t, this }, copy: function (t) { return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this }, copyAt: function (t, e, n) { t *= this.stride, n *= e.stride; for (var i = 0, r = this.stride; i < r; i++)this.array[t + i] = e.array[n + i]; return this }, set: function (t, e) { return void 0 === e && (e = 0), this.array.set(t, e), this }, clone: function () { return (new this.constructor).copy(this) }, onUpload: function (t) { return this.onUploadCallback = t, this } }), Object.defineProperties(Ms.prototype, { count: { get: function () { return this.data.count } }, array: { get: function () { return this.data.array } } }), Object.assign(Ms.prototype, { isInterleavedBufferAttribute: !0, setX: function (t, e) { return this.data.array[t * this.data.stride + this.offset] = e, this }, setY: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 1] = e, this }, setZ: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 2] = e, this }, setW: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 3] = e, this }, getX: function (t) { return this.data.array[t * this.data.stride + this.offset] }, getY: function (t) { return this.data.array[t * this.data.stride + this.offset + 1] }, getZ: function (t) { return this.data.array[t * this.data.stride + this.offset + 2] }, getW: function (t) { return this.data.array[t * this.data.stride + this.offset + 3] }, setXY: function (t, e, n) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this }, setXYZ: function (t, e, n, i) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this }, setXYZW: function (t, e, n, i, r) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this } }), ((Es.prototype = Object.create(lr.prototype)).constructor = Es).prototype.isSpriteMaterial = !0, Es.prototype.copy = function (t) { return lr.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this }, Ss.prototype = Object.assign(Object.create(Si.prototype), { constructor: Ss, isSprite: !0, raycast: (Fo = new qe, Ho = new qe, Vo = new qe, ko = new ke, jo = new ke, Wo = new je, qo = new qe, Xo = new qe, Yo = new qe, Jo = new ke, Zo = new ke, Qo = new ke, function (t, e) { Ho.setFromMatrixScale(this.matrixWorld), Wo.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), Vo.setFromMatrixPosition(this.modelViewMatrix); var n, i, r = this.material.rotation; 0 !== r && (i = Math.cos(r), n = Math.sin(r)); var a = this.center; Ts(qo.set(-.5, -.5, 0), Vo, a, Ho, n, i), Ts(Xo.set(.5, -.5, 0), Vo, a, Ho, n, i), Ts(Yo.set(.5, .5, 0), Vo, a, Ho, n, i), Jo.set(0, 0), Zo.set(1, 0), Qo.set(1, 1); r = t.ray.intersectTriangle(qo, Xo, Yo, !1, Fo); null === r && (Ts(Xo.set(-.5, .5, 0), Vo, a, Ho, n, i), Zo.set(0, 1), null === (r = t.ray.intersectTriangle(qo, Yo, Xo, !1, Fo))) || ((r = t.ray.origin.distanceTo(Fo)) < t.near || r > t.far || e.push({ distance: r, point: Fo.clone(), uv: ta.getUV(Fo, qo, Xo, Yo, Jo, Zo, Qo, new ke), face: null, object: this })) }), clone: function () { return new this.constructor(this.material).copy(this) }, copy: function (t) { return Si.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this } }), As.prototype = Object.assign(Object.create(Si.prototype), { constructor: As, copy: function (t) { Si.prototype.copy.call(this, t, !1); for (var e = t.levels, n = 0, i = e.length; n < i; n++) { var r = e[n]; this.addLevel(r.object.clone(), r.distance) } return this }, addLevel: function (t, e) { void 0 === e && (e = 0), e = Math.abs(e); for (var n = this.levels, i = 0; i < n.length && !(e < n[i].distance); i++); n.splice(i, 0, { distance: e, object: t }), this.add(t) }, getObjectForDistance: function (t) { for (var e = this.levels, n = 1, i = e.length; n < i && !(t < e[n].distance); n++); return e[n - 1].object }, raycast: (ts = new qe, function (t, e) { ts.setFromMatrixPosition(this.matrixWorld); var n = t.ray.origin.distanceTo(ts); this.getObjectForDistance(n).raycast(t, e) }), update: (Ko = new qe, $o = new qe, function (t) { var e = this.levels; if (1 < e.length) { Ko.setFromMatrixPosition(t.matrixWorld), $o.setFromMatrixPosition(this.matrixWorld); var n = Ko.distanceTo($o); e[0].object.visible = !0; for (var i = 1, r = e.length; i < r && n >= e[i].distance; i++)e[i - 1].object.visible = !1, e[i].object.visible = !0; for (; i < r; i++)e[i].object.visible = !1 } }), toJSON: function (t) { var e = Si.prototype.toJSON.call(this, t); e.object.levels = []; for (var n = this.levels, i = 0, r = n.length; i < r; i++) { var a = n[i]; e.object.levels.push({ object: a.object.uuid, distance: a.distance }) } return e } }), Ls.prototype = Object.assign(Object.create(na.prototype), { constructor: Ls, isSkinnedMesh: !0, bind: function (t, e) { this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e) }, pose: function () { this.skeleton.pose() }, normalizeSkinWeights: function () { for (var t = new Ln, e = this.geometry.attributes.skinWeight, n = 0, i = e.count; n < i; n++) { t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n); var r = 1 / t.manhattanLength(); r != 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w) } }, updateMatrixWorld: function (t) { na.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) }, clone: function () { return new this.constructor(this.geometry, this.material).copy(this) } }), Object.assign(Rs.prototype, { calculateInverses: function () { this.boneInverses = []; for (var t = 0, e = this.bones.length; t < e; t++) { var n = new je; this.bones[t] && n.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(n) } }, pose: function () { for (var t, e = 0, n = this.bones.length; e < n; e++)(t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]); for (e = 0, n = this.bones.length; e < n; e++)(t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale)) }, update: (es = new je, ns = new je, function () { for (var t = this.bones, e = this.boneInverses, n = this.boneMatrices, i = this.boneTexture, r = 0, a = t.length; r < a; r++) { var o = t[r] ? t[r].matrixWorld : ns; es.multiplyMatrices(o, e[r]), es.toArray(n, 16 * r) } void 0 !== i && (i.needsUpdate = !0) }), clone: function () { return new Rs(this.bones, this.boneInverses) }, getBoneByName: function (t) { for (var e = 0, n = this.bones.length; e < n; e++) { var i = this.bones[e]; if (i.name === t) return i } } }), Ps.prototype = Object.assign(Object.create(Si.prototype), { constructor: Ps, isBone: !0 }), ((Cs.prototype = Object.create(lr.prototype)).constructor = Cs).prototype.isLineBasicMaterial = !0, Cs.prototype.copy = function (t) { return lr.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this }, Os.prototype = Object.assign(Object.create(Si.prototype), { constructor: Os, isLine: !0, computeLineDistances: (os = new qe, ss = new qe, function () { var t = this.geometry; if (t.isBufferGeometry) if (null === t.index) { for (var e = t.attributes.position, n = [0], i = 1, r = e.count; i < r; i++)os.fromBufferAttribute(e, i - 1), ss.fromBufferAttribute(e, i), n[i] = n[i - 1], n[i] += os.distanceTo(ss); t.addAttribute("lineDistance", new ki(n, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (t.isGeometry) { var a = t.vertices; (n = t.lineDistances)[0] = 0; for (i = 1, r = a.length; i < r; i++)n[i] = n[i - 1], n[i] += a[i - 1].distanceTo(a[i]) } return this }), raycast: (is = new je, rs = new $r, as = new Bn, function (t, e) { var n = t.linePrecision, i = this.geometry, r = this.matrixWorld; if (null === i.boundingSphere && i.computeBoundingSphere(), as.copy(i.boundingSphere), as.applyMatrix4(r), as.radius += n, !1 !== t.ray.intersectsSphere(as)) { is.getInverse(r), rs.copy(t.ray).applyMatrix4(is); var n = n / ((this.scale.x + this.scale.y + this.scale.z) / 3), a = n * n, o = new qe, s = new qe, c = new qe, h = new qe, l = this && this.isLineSegments ? 2 : 1; if (i.isBufferGeometry) { var n = i.index, u = i.attributes.position.array; if (null !== n) for (var p = n.array, d = 0, f = p.length - 1; d < f; d += l) { var m = p[d], g = p[d + 1]; o.fromArray(u, 3 * m), s.fromArray(u, 3 * g), a < rs.distanceSqToSegment(o, s, h, c) || (h.applyMatrix4(this.matrixWorld), (v = t.ray.origin.distanceTo(h)) < t.near || v > t.far || e.push({ distance: v, point: c.clone().applyMatrix4(this.matrixWorld), index: d, face: null, faceIndex: null, object: this })) } else for (d = 0, f = u.length / 3 - 1; d < f; d += l)o.fromArray(u, 3 * d), s.fromArray(u, 3 * d + 3), a < rs.distanceSqToSegment(o, s, h, c) || (h.applyMatrix4(this.matrixWorld), (v = t.ray.origin.distanceTo(h)) < t.near || v > t.far || e.push({ distance: v, point: c.clone().applyMatrix4(this.matrixWorld), index: d, face: null, faceIndex: null, object: this })) } else if (i.isGeometry) for (var v, y = i.vertices, x = y.length, d = 0; d < x - 1; d += l)a < rs.distanceSqToSegment(y[d], y[d + 1], h, c) || (h.applyMatrix4(this.matrixWorld), (v = t.ray.origin.distanceTo(h)) < t.near || v > t.far || e.push({ distance: v, point: c.clone().applyMatrix4(this.matrixWorld), index: d, face: null, faceIndex: null, object: this })) } }), copy: function (t) { return Si.prototype.copy.call(this, t), this.geometry.copy(t.geometry), this.material.copy(t.material), this }, clone: function () { return (new this.constructor).copy(this) } }), Is.prototype = Object.assign(Object.create(Os.prototype), { constructor: Is, isLineSegments: !0, computeLineDistances: (cs = new qe, hs = new qe, function () { var t = this.geometry; if (t.isBufferGeometry) if (null === t.index) { for (var e = t.attributes.position, n = [], i = 0, r = e.count; i < r; i += 2)cs.fromBufferAttribute(e, i), hs.fromBufferAttribute(e, i + 1), n[i] = 0 === i ? 0 : n[i - 1], n[i + 1] = n[i] + cs.distanceTo(hs); t.addAttribute("lineDistance", new ki(n, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (t.isGeometry) for (var a = t.vertices, n = t.lineDistances, i = 0, r = a.length; i < r; i += 2)cs.copy(a[i]), hs.copy(a[i + 1]), n[i] = 0 === i ? 0 : n[i - 1], n[i + 1] = n[i] + cs.distanceTo(hs); return this }) }), Ds.prototype = Object.assign(Object.create(Os.prototype), { constructor: Ds, isLineLoop: !0 }), ((Ns.prototype = Object.create(lr.prototype)).constructor = Ns).prototype.isPointsMaterial = !0, Ns.prototype.copy = function (t) { return lr.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this }, Bs.prototype = Object.assign(Object.create(Si.prototype), { constructor: Bs, isPoints: !0, raycast: (ls = new je, us = new $r, ps = new Bn, function (i, r) { var a = this, t = this.geometry, o = this.matrixWorld, e = i.params.Points.threshold; if (null === t.boundingSphere && t.computeBoundingSphere(), ps.copy(t.boundingSphere), ps.applyMatrix4(o), ps.radius += e, !1 !== i.ray.intersectsSphere(ps)) { ls.getInverse(o), us.copy(i.ray).applyMatrix4(ls); var e = e / ((this.scale.x + this.scale.y + this.scale.z) / 3), s = e * e, n = new qe, c = new qe; if (t.isBufferGeometry) { var e = t.index, h = t.attributes.position.array; if (null !== e) for (var l = e.array, u = 0, p = l.length; u < p; u++) { var d = l[u]; n.fromArray(h, 3 * d), g(n, d) } else for (var u = 0, f = h.length / 3; u < f; u++)n.fromArray(h, 3 * u), g(n, u) } else for (var m = t.vertices, u = 0, f = m.length; u < f; u++)g(m[u], u) } function g(t, e) { var n = us.distanceSqToPoint(t); n < s && (us.closestPointToPoint(t, c), c.applyMatrix4(o), (t = i.ray.origin.distanceTo(c)) < i.near || t > i.far || r.push({ distance: t, distanceToRay: Math.sqrt(n), point: c.clone(), index: e, face: null, object: a })) } }), clone: function () { return new this.constructor(this.geometry, this.material).copy(this) } }), zs.prototype = Object.assign(Object.create(An.prototype), { constructor: zs, isVideoTexture: !0, update: function () { var t = this.image; t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } }), ((Us.prototype = Object.create(An.prototype)).constructor = Us).prototype.isCompressedTexture = !0, ((Gs.prototype = Object.create(An.prototype)).constructor = Gs).prototype.isCanvasTexture = !0, ((Fs.prototype = Object.create(An.prototype)).constructor = Fs).prototype.isDepthTexture = !0, (Hs.prototype = Object.create(rr.prototype)).constructor = Hs, (Vs.prototype = Object.create(Di.prototype)).constructor = Vs, (ks.prototype = Object.create(rr.prototype)).constructor = ks, (js.prototype = Object.create(Di.prototype)).constructor = js, (Ws.prototype = Object.create(rr.prototype)).constructor = Ws, (qs.prototype = Object.create(Di.prototype)).constructor = qs, (Xs.prototype = Object.create(Ws.prototype)).constructor = Xs, (Ys.prototype = Object.create(Di.prototype)).constructor = Ys, (Js.prototype = Object.create(Ws.prototype)).constructor = Js, (Zs.prototype = Object.create(Di.prototype)).constructor = Zs, (Qs.prototype = Object.create(Ws.prototype)).constructor = Qs, (Ks.prototype = Object.create(Di.prototype)).constructor = Ks, ($s.prototype = Object.create(Ws.prototype)).constructor = $s, (tc.prototype = Object.create(Di.prototype)).constructor = tc, ((ec.prototype = Object.create(rr.prototype)).constructor = ec).prototype.toJSON = function () { var t = rr.prototype.toJSON.call(this); return t.path = this.parameters.path.toJSON(), t }, (nc.prototype = Object.create(Di.prototype)).constructor = nc, (ic.prototype = Object.create(rr.prototype)).constructor = ic, (rc.prototype = Object.create(Di.prototype)).constructor = rc, (ac.prototype = Object.create(rr.prototype)).constructor = ac; var oc = function (t, e, n) { n = n || 2; var i, r, a, o, s, c, h, l = e && e.length, u = l ? e[0] * n : t.length, p = sc(t, 0, u, n, !0), d = []; if (!p) return d; if (l && (p = function (t, e, n, i) { var r, a, o, s, c = []; for (r = 0, a = e.length; r < a; r++)o = e[r] * i, s = r < a - 1 ? e[r + 1] * i : t.length, (s = sc(t, o, s, i, !1)) === s.next && (s.steiner = !0), c.push(function (t) { var e = t, n = t; for (; e.x < n.x && (n = e), e = e.next, e !== t;); return n }(s)); for (c.sort(lc), r = 0; r < c.length; r++)!function (t, e) { (e = function (t, e) { var n, i = e, r = t.x, a = t.y, o = -1 / 0; do { if (a <= i.y && a >= i.next.y && i.next.y !== i.y) { var s = i.x + (a - i.y) * (i.next.x - i.x) / (i.next.y - i.y); if (s <= r && o < s) { if ((o = s) === r) { if (a === i.y) return i; if (a === i.next.y) return i.next } n = i.x < i.next.x ? i : i.next } } } while (i = i.next, i !== e); if (!n) return null; if (r === o) return n.prev; var c, h = n, l = n.x, u = n.y, p = 1 / 0; i = n.next; for (; i !== h;)r >= i.x && i.x >= l && r !== i.x && pc(a < u ? r : o, a, l, u, a < u ? o : r, a, i.x, i.y) && ((c = Math.abs(a - i.y) / (r - i.x)) < p || c === p && i.x > n.x) && gc(i, t) && (n = i, p = c), i = i.next; return n }(t, e)) && cc(t = vc(e, t), t.next) }(c[r], n), n = cc(n, n.next); return n }(t, e, p, n)), t.length > 80 * n) { i = a = t[0], r = o = t[1]; for (var f = n; f < u; f += n)(s = t[f]) < i && (i = s), (c = t[f + 1]) < r && (r = c), a < s && (a = s), o < c && (o = c); h = 0 !== (h = Math.max(a - i, o - r)) ? 1 / h : 0 } return hc(p, d, n, i, r, h), d }; function sc(t, e, n, i, r) { var a, o; if (r === 0 < function (t, e, n, i) { for (var r = 0, a = e, o = n - i; a < n; a += i)r += (t[o] - t[a]) * (t[a + 1] + t[o + 1]), o = a; return r }(t, e, n, i)) for (a = e; a < n; a += i)o = yc(a, t[a], t[a + 1], o); else for (a = n - i; e <= a; a -= i)o = yc(a, t[a], t[a + 1], o); return o && fc(o, o.next) && (xc(o), o = o.next), o } function cc(t, e) { if (!t) return t; e = e || t; var n, i = t; do { if (n = !1, i.steiner || !fc(i, i.next) && 0 !== dc(i.prev, i, i.next)) i = i.next; else { if (xc(i), (i = e = i.prev) === i.next) break; n = !0 } } while (n || i !== e); return e } function hc(t, e, n, i, r, a, o) { if (t) { !o && a && function (t, e, n, i) { for (var r = t; null === r.z && (r.z = uc(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next, r !== t;); r.prevZ.nextZ = null, r.prevZ = null, function (t) { var e, n, i, r, a, o, s, c, h = 1; do { for (n = t, a = t = null, o = 0; n;) { for (o++, i = n, e = s = 0; e < h && (s++, i = i.nextZ); e++); for (c = h; 0 < s || 0 < c && i;)0 !== s && (0 === c || !i || n.z <= i.z) ? (n = (r = n).nextZ, s--) : (i = (r = i).nextZ, c--), a ? a.nextZ = r : t = r, r.prevZ = a, a = r; n = i } } while (a.nextZ = null, h *= 2, 1 < o) }(r) }(t, i, r, a); for (var s, c, h = t; t.prev !== t.next;)if (s = t.prev, c = t.next, a ? function (t, e, n, i) { var r = t.prev, a = t, o = t.next; if (0 <= dc(r, a, o)) return !1; var s = (r.x < a.x ? r.x < o.x ? r : o : a.x < o.x ? a : o).x, c = (r.y < a.y ? r.y < o.y ? r : o : a.y < o.y ? a : o).y, h = (r.x > a.x ? r.x > o.x ? r : o : a.x > o.x ? a : o).x, l = (r.y > a.y ? r.y > o.y ? r : o : a.y > o.y ? a : o).y, u = uc(s, c, e, n, i), p = uc(h, l, e, n, i), d = t.nextZ; for (; d && d.z <= p;) { if (d !== t.prev && d !== t.next && pc(r.x, r.y, a.x, a.y, o.x, o.y, d.x, d.y) && 0 <= dc(d.prev, d, d.next)) return !1; d = d.nextZ } d = t.prevZ; for (; d && d.z >= u;) { if (d !== t.prev && d !== t.next && pc(r.x, r.y, a.x, a.y, o.x, o.y, d.x, d.y) && 0 <= dc(d.prev, d, d.next)) return !1; d = d.prevZ } return !0 }(t, i, r, a) : function (t) { var e = t.prev, n = t, i = t.next; if (0 <= dc(e, n, i)) return !1; var r = t.next.next; for (; r !== t.prev;) { if (pc(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && 0 <= dc(r.prev, r, r.next)) return !1; r = r.next } return !0 }(t)) e.push(s.i / n), e.push(t.i / n), e.push(c.i / n), xc(t), t = c.next, h = c.next; else if ((t = c) === h) { o ? 1 === o ? hc(t = function (t, e, n) { var i = t; do { var r = i.prev, a = i.next.next } while (!fc(r, a) && mc(r, i, i.next, a) && gc(r, a) && gc(a, r) && (e.push(r.i / n), e.push(i.i / n), e.push(a.i / n), xc(i), xc(i.next), i = t = a), i = i.next, i !== t); return i }(t, e, n), e, n, i, r, a, 2) : 2 === o && function (t, e, n, i, r, a) { var o = t; do { for (var s = o.next.next; s !== o.prev;) { if (o.i !== s.i && function (t, e) { return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) { var n = t; do { if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && mc(n, n.next, t, e)) return !0 } while (n = n.next, n !== t); return !1 }(t, e) && gc(t, e) && gc(e, t) && function (t, e) { var n = t, i = !1, r = (t.x + e.x) / 2, a = (t.y + e.y) / 2; for (; n.y > a != n.next.y > a && n.next.y !== n.y && r < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next, n !== t;); return i }(t, e) }(o, s)) { var c = vc(o, s); return o = cc(o, o.next), c = cc(c, c.next), hc(o, e, n, i, r, a), hc(c, e, n, i, r, a) } s = s.next } } while ((o = o.next) !== t) }(t, e, n, i, r, a) : hc(cc(t), e, n, i, r, a, 1); break } } } function lc(t, e) { return t.x - e.x } function uc(t, e, n, i, r) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 } function pc(t, e, n, i, r, a, o, s) { return 0 <= (r - o) * (e - s) - (t - o) * (a - s) && 0 <= (t - o) * (i - s) - (n - o) * (e - s) && 0 <= (n - o) * (a - s) - (r - o) * (i - s) } function dc(t, e, n) { return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y) } function fc(t, e) { return t.x === e.x && t.y === e.y } function mc(t, e, n, i) { return fc(t, e) && fc(n, i) || fc(t, i) && fc(n, e) || 0 < dc(t, e, n) != 0 < dc(t, e, i) && 0 < dc(n, i, t) != 0 < dc(n, i, e) } function gc(t, e) { return dc(t.prev, t, t.next) < 0 ? 0 <= dc(t, e, t.next) && 0 <= dc(t, t.prev, e) : dc(t, e, t.prev) < 0 || dc(t, t.next, e) < 0 } function vc(t, e) { var n = new bc(t.i, t.x, t.y), i = new bc(e.i, e.x, e.y), r = t.next, a = e.prev; return (t.next = e).prev = t, (n.next = r).prev = n, (i.next = n).prev = i, (a.next = i).prev = a, i } function yc(t, e, n, i) { n = new bc(t, e, n); return i ? (n.next = i.next, (n.prev = i).next.prev = n, i.next = n) : (n.prev = n).next = n, n } function xc(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) } function bc(t, e, n) { this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } var wc = { area: function (t) { for (var e = t.length, n = 0, i = e - 1, r = 0; r < e; i = r++)n += t[i].x * t[r].y - t[r].x * t[i].y; return .5 * n }, isClockWise: function (t) { return wc.area(t) < 0 }, triangulateShape: function (t, e) { var n = [], i = [], r = []; _c(t), Mc(n, t); var a = t.length; e.forEach(_c); for (var o = 0; o < e.length; o++)i.push(a), a += e[o].length, Mc(n, e[o]); for (var s = oc(n, i), o = 0; o < s.length; o += 3)r.push(s.slice(o, o + 3)); return r } }; function _c(t) { var e = t.length; 2 < e && t[e - 1].equals(t[0]) && t.pop() } function Mc(t, e) { for (var n = 0; n < e.length; n++)t.push(e[n].x), t.push(e[n].y) } function Ec(t, e) { Di.call(this), this.type = "ExtrudeGeometry", this.parameters = { shapes: t, options: e }, this.fromBufferGeometry(new Sc(t, e)), this.mergeVertices() } function Sc(t, Y) { rr.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = { shapes: t, options: Y }, t = Array.isArray(t) ? t : [t]; for (var J = this, Z = [], Q = [], e = 0, n = t.length; e < n; e++)!function (t) { var i = [], e = void 0 !== Y.curveSegments ? Y.curveSegments : 12, l = void 0 !== Y.steps ? Y.steps : 1, n = void 0 !== Y.depth ? Y.depth : 100, r = void 0 === Y.bevelEnabled || Y.bevelEnabled, a = void 0 !== Y.bevelThickness ? Y.bevelThickness : 6, o = void 0 !== Y.bevelSize ? Y.bevelSize : a - 2, u = void 0 !== Y.bevelSegments ? Y.bevelSegments : 3, s = Y.extrudePath, p = void 0 !== Y.UVGenerator ? Y.UVGenerator : Tc; void 0 !== Y.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), n = Y.amount); var c, h, d, f, m, g, v, y, x = !1; s && (c = s.getSpacedPoints(l), r = !(x = !0), h = s.computeFrenetFrames(l, !1), d = new qe, f = new qe, m = new qe), r || (o = a = u = 0); var b = (e = t.extractPoints(e)).shape, w = e.holes; if (!wc.isClockWise(b)) for (b = b.reverse(), v = 0, y = w.length; v < y; v++)g = w[v], wc.isClockWise(g) && (w[v] = g.reverse()); var _ = wc.triangulateShape(b, w), M = b; for (v = 0, y = w.length; v < y; v++)g = w[v], b = b.concat(g); function E(t, e, n) { return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t) } var S, T, A, L, R, P, C = b.length, O = _.length; function I(t, e, n) { var i = t.x - e.x, r = t.y - e.y, a = n.x - t.x, o = n.y - t.y, s = i * i + r * r, c = i * o - r * a; if (Math.abs(c) > Number.EPSILON) { var h = Math.sqrt(s), l = Math.sqrt(a * a + o * o), u = e.x - r / h, p = e.y + i / h, h = ((n.x - o / l - u) * o - (n.y + a / l - p) * a) / (i * o - r * a), p = (l = u + i * h - t.x) * l + (u = p + r * h - t.y) * u; if (p <= 2) return new ke(l, u); h = Math.sqrt(p / 2) } else { p = !1; i > Number.EPSILON ? a > Number.EPSILON && (p = !0) : i < -Number.EPSILON ? a < -Number.EPSILON && (p = !0) : Math.sign(r) === Math.sign(o) && (p = !0), h = p ? (l = -r, u = i, Math.sqrt(s)) : (l = i, u = r, Math.sqrt(s / 2)) } return new ke(l / h, u / h) } for (var D = [], N = 0, B = M.length, z = B - 1, U = N + 1; N < B; N++, z++, U++)z === B && (z = 0), U === B && (U = 0), D[N] = I(M[N], M[z], M[U]); var G, F, H = [], V = D.concat(); for (v = 0, y = w.length; v < y; v++) { for (g = w[v], G = [], N = 0, B = g.length, z = B - 1, U = N + 1; N < B; N++, z++, U++)z === B && (z = 0), U === B && (U = 0), G[N] = I(g[N], g[z], g[U]); H.push(G), V = V.concat(G) } for (S = 0; S < u; S++) { for (A = S / u, L = a * Math.cos(A * Math.PI / 2), T = o * Math.sin(A * Math.PI / 2), N = 0, B = M.length; N < B; N++)j((R = E(M[N], D[N], T)).x, R.y, -L); for (v = 0, y = w.length; v < y; v++)for (g = w[v], G = H[v], N = 0, B = g.length; N < B; N++)j((R = E(g[N], G[N], T)).x, R.y, -L) } for (T = o, N = 0; N < C; N++)R = r ? E(b[N], V[N], T) : b[N], x ? (f.copy(h.normals[0]).multiplyScalar(R.x), d.copy(h.binormals[0]).multiplyScalar(R.y), m.copy(c[0]).add(f).add(d), j(m.x, m.y, m.z)) : j(R.x, R.y, 0); for (F = 1; F <= l; F++)for (N = 0; N < C; N++)R = r ? E(b[N], V[N], T) : b[N], x ? (f.copy(h.normals[F]).multiplyScalar(R.x), d.copy(h.binormals[F]).multiplyScalar(R.y), m.copy(c[F]).add(f).add(d), j(m.x, m.y, m.z)) : j(R.x, R.y, n / l * F); for (S = u - 1; 0 <= S; S--) { for (A = S / u, L = a * Math.cos(A * Math.PI / 2), T = o * Math.sin(A * Math.PI / 2), N = 0, B = M.length; N < B; N++)j((R = E(M[N], D[N], T)).x, R.y, n + L); for (v = 0, y = w.length; v < y; v++)for (g = w[v], G = H[v], N = 0, B = g.length; N < B; N++)R = E(g[N], G[N], T), x ? j(R.x, R.y + c[l - 1].y, c[l - 1].x + L) : j(R.x, R.y, n + L) } function k(t, e) { var n, i, r; for (N = t.length; 0 <= --N;) { (i = (n = N) - 1) < 0 && (i = t.length - 1); for (var a = 0, o = l + 2 * u, a = 0; a < o; a++) { var s = C * a, c = C * (a + 1), h = e + n + s; r = e + i + s, s = e + i + c, c = e + n + c, q(h), q(r), q(c), q(r), q(s), q(c), c = Z.length / 3, X((c = p.generateSideWallUV(J, Z, c - 6, c - 3, c - 2, c - 1))[0]), X(c[1]), X(c[3]), X(c[1]), X(c[2]), !void X(c[3]) } } } function j(t, e, n) { i.push(t), i.push(e), i.push(n) } function W(t, e, n) { q(t), q(e), q(n); n = Z.length / 3, n = p.generateTopUV(J, Z, n - 3, n - 2, n - 1); X(n[0]), X(n[1]), X(n[2]) } function q(t) { Z.push(i[3 * t + 0]), Z.push(i[3 * t + 1]), Z.push(i[3 * t + 2]) } function X(t) { Q.push(t.x), Q.push(t.y) } (function () { var t = Z.length / 3; if (r) { var e = 0 * C; for (N = 0; N < O; N++)W((P = _[N])[2] + e, P[1] + e, P[0] + e); for (e = C * (l + 2 * u), N = 0; N < O; N++)W((P = _[N])[0] + e, P[1] + e, P[2] + e) } else { for (N = 0; N < O; N++)W((P = _[N])[2], P[1], P[0]); for (N = 0; N < O; N++)W((P = _[N])[0] + C * l, P[1] + C * l, P[2] + C * l) } J.addGroup(t, Z.length / 3 - t, 0) })(), function () { var t = Z.length / 3, e = 0; for (k(M, e), e += M.length, v = 0, y = w.length; v < y; v++)k(g = w[v], e), e += g.length; J.addGroup(t, Z.length / 3 - t, 1) }() }(t[e]); this.addAttribute("position", new ki(Z, 3)), this.addAttribute("uv", new ki(Q, 2)), this.computeVertexNormals() } ((Ec.prototype = Object.create(Di.prototype)).constructor = Ec).prototype.toJSON = function () { var t = Di.prototype.toJSON.call(this); return Ac(this.parameters.shapes, this.parameters.options, t) }, ((Sc.prototype = Object.create(rr.prototype)).constructor = Sc).prototype.toJSON = function () { var t = rr.prototype.toJSON.call(this); return Ac(this.parameters.shapes, this.parameters.options, t) }; var Tc = { generateTopUV: function (t, e, n, i, r) { var a = e[3 * n], o = e[3 * n + 1], s = e[3 * i], n = e[3 * i + 1], i = e[3 * r], r = e[3 * r + 1]; return [new ke(a, o), new ke(s, n), new ke(i, r)] }, generateSideWallUV: function (t, e, n, i, r, a) { var o = e[3 * n], s = e[3 * n + 1], c = e[3 * n + 2], h = e[3 * i], l = e[3 * i + 1], u = e[3 * i + 2], p = e[3 * r], d = e[3 * r + 1], n = e[3 * r + 2], i = e[3 * a], r = e[3 * a + 1], a = e[3 * a + 2]; return Math.abs(s - l) < .01 ? [new ke(o, 1 - c), new ke(h, 1 - u), new ke(p, 1 - n), new ke(i, 1 - a)] : [new ke(s, 1 - c), new ke(l, 1 - u), new ke(d, 1 - n), new ke(r, 1 - a)] } }; function Ac(t, e, n) { if (n.shapes = [], Array.isArray(t)) for (var i = 0, r = t.length; i < r; i++) { var a = t[i]; n.shapes.push(a.uuid) } else n.shapes.push(t.uuid); return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n } function Lc(t, e) { Di.call(this), this.type = "TextGeometry", this.parameters = { text: t, parameters: e }, this.fromBufferGeometry(new Rc(t, e)), this.mergeVertices() } function Rc(t, e) { var n = (e = e || {}).font; if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new Di; t = n.generateShapes(t, e.size); e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), Sc.call(this, t, e), this.type = "TextBufferGeometry" } function Pc(t, e, n, i, r, a, o) { Di.call(this), this.type = "SphereGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: n, phiStart: i, phiLength: r, thetaStart: a, thetaLength: o }, this.fromBufferGeometry(new Cc(t, e, n, i, r, a, o)), this.mergeVertices() } function Cc(t, e, n, i, r, a, o) { rr.call(this), this.type = "SphereBufferGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: n, phiStart: i, phiLength: r, thetaStart: a, thetaLength: o }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), n = Math.max(2, Math.floor(n) || 6), i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI; for (var s = (a = void 0 !== a ? a : 0) + (o = void 0 !== o ? o : Math.PI), c = 0, h = [], l = new qe, u = new qe, p = [], d = [], f = [], m = [], g = 0; g <= n; g++) { for (var v = [], y = g / n, x = 0; x <= e; x++) { var b = x / e; l.x = -t * Math.cos(i + b * r) * Math.sin(a + y * o), l.y = t * Math.cos(a + y * o), l.z = t * Math.sin(i + b * r) * Math.sin(a + y * o), d.push(l.x, l.y, l.z), u.set(l.x, l.y, l.z).normalize(), f.push(u.x, u.y, u.z), m.push(b, 1 - y), v.push(c++) } h.push(v) } for (g = 0; g < n; g++)for (x = 0; x < e; x++) { var w = h[g][x + 1], _ = h[g][x], M = h[g + 1][x], E = h[g + 1][x + 1]; (0 !== g || 0 < a) && p.push(w, _, E), (g !== n - 1 || s < Math.PI) && p.push(_, M, E) } this.setIndex(p), this.addAttribute("position", new ki(d, 3)), this.addAttribute("normal", new ki(f, 3)), this.addAttribute("uv", new ki(m, 2)) } function Oc(t, e, n, i, r, a) { Di.call(this), this.type = "RingGeometry", this.parameters = { innerRadius: t, outerRadius: e, thetaSegments: n, phiSegments: i, thetaStart: r, thetaLength: a }, this.fromBufferGeometry(new Ic(t, e, n, i, r, a)), this.mergeVertices() } function Ic(t, e, n, i, r, a) { rr.call(this), this.type = "RingBufferGeometry", this.parameters = { innerRadius: t, outerRadius: e, thetaSegments: n, phiSegments: i, thetaStart: r, thetaLength: a }, t = t || .5, e = e || 1, r = void 0 !== r ? r : 0, a = void 0 !== a ? a : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8; for (var o, s = [], c = [], h = [], l = [], u = t, p = (e - t) / (i = void 0 !== i ? Math.max(1, i) : 1), d = new qe, f = new ke, m = 0; m <= i; m++) { for (v = 0; v <= n; v++)o = r + v / n * a, d.x = u * Math.cos(o), d.y = u * Math.sin(o), c.push(d.x, d.y, d.z), h.push(0, 0, 1), f.x = (d.x / e + 1) / 2, f.y = (d.y / e + 1) / 2, l.push(f.x, f.y); u += p } for (m = 0; m < i; m++)for (var g = m * (n + 1), v = 0; v < n; v++) { var y = (o = v + g) + n + 1, x = o + n + 2, b = o + 1; s.push(o, y, b), s.push(y, x, b) } this.setIndex(s), this.addAttribute("position", new ki(c, 3)), this.addAttribute("normal", new ki(h, 3)), this.addAttribute("uv", new ki(l, 2)) } function Dc(t, e, n, i) { Di.call(this), this.type = "LatheGeometry", this.parameters = { points: t, segments: e, phiStart: n, phiLength: i }, this.fromBufferGeometry(new Nc(t, e, n, i)), this.mergeVertices() } function Nc(t, e, n, i) { rr.call(this), this.type = "LatheBufferGeometry", this.parameters = { points: t, segments: e, phiStart: n, phiLength: i }, e = Math.floor(e) || 12, n = n || 0, i = i || 2 * Math.PI, i = Ve.clamp(i, 0, 2 * Math.PI); var r = [], a = [], o = [], s = 1 / e, c = new qe, h = new ke; for (_ = 0; _ <= e; _++)for (var l = n + _ * s * i, u = Math.sin(l), p = Math.cos(l), d = 0; d <= t.length - 1; d++)c.x = t[d].x * u, c.y = t[d].y, c.z = t[d].x * p, a.push(c.x, c.y, c.z), h.x = _ / e, h.y = d / (t.length - 1), o.push(h.x, h.y); for (_ = 0; _ < e; _++)for (d = 0; d < t.length - 1; d++) { var f = (w = d + _ * t.length) + t.length, m = w + t.length + 1, g = w + 1; r.push(w, f, g), r.push(f, m, g) } if (this.setIndex(r), this.addAttribute("position", new ki(a, 3)), this.addAttribute("uv", new ki(o, 2)), this.computeVertexNormals(), i === 2 * Math.PI) { var v = this.attributes.normal.array, y = new qe, x = new qe, b = new qe, w = e * t.length * 3, _ = 0; for (d = 0; _ < t.length; _++, d += 3)y.x = v[d + 0], y.y = v[d + 1], y.z = v[d + 2], x.x = v[w + d + 0], x.y = v[w + d + 1], x.z = v[w + d + 2], b.addVectors(y, x).normalize(), v[d + 0] = v[w + d + 0] = b.x, v[d + 1] = v[w + d + 1] = b.y, v[d + 2] = v[w + d + 2] = b.z } } function Bc(t, e) { Di.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = { shapes: t, curveSegments: e }, this.fromBufferGeometry(new zc(t, e)), this.mergeVertices() } function zc(t, p) { rr.call(this), this.type = "ShapeBufferGeometry", this.parameters = { shapes: t, curveSegments: p }, p = p || 12; var d = [], f = [], m = [], g = [], e = 0, v = 0; if (!1 === Array.isArray(t)) i(t); else for (var n = 0; n < t.length; n++)i(t[n]), this.addGroup(e, v, n), e += v, v = 0; function i(t) { var e, n = f.length / 3, t = t.extractPoints(p), i = t.shape, r = t.holes; for (!1 === wc.isClockWise(i) && (i = i.reverse()), o = 0, s = r.length; o < s; o++)e = r[o], !0 === wc.isClockWise(e) && (r[o] = e.reverse()); for (var a = wc.triangulateShape(i, r), o = 0, s = r.length; o < s; o++)e = r[o], i = i.concat(e); for (o = 0, s = i.length; o < s; o++) { var c = i[o]; f.push(c.x, c.y, 0), m.push(0, 0, 1), g.push(c.x, c.y) } for (o = 0, s = a.length; o < s; o++) { var h = a[o], l = h[0] + n, u = h[1] + n, h = h[2] + n; d.push(l, u, h), v += 3 } } this.setIndex(d), this.addAttribute("position", new ki(f, 3)), this.addAttribute("normal", new ki(m, 3)), this.addAttribute("uv", new ki(g, 2)) } function Uc(t, e) { if (e.shapes = [], Array.isArray(t)) for (var n = 0, i = t.length; n < i; n++) { var r = t[n]; e.shapes.push(r.uuid) } else e.shapes.push(t.uuid); return e } function Gc(t, e) { rr.call(this), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: e }, e = void 0 !== e ? e : 1; var n, i, r, a, o = [], s = Math.cos(Ve.DEG2RAD * e), c = [0, 0], h = {}, l = ["a", "b", "c"]; t.isBufferGeometry ? (a = new Di).fromBufferGeometry(t) : a = t.clone(), a.mergeVertices(), a.computeFaceNormals(); for (var u = a.vertices, p = a.faces, d = 0, f = p.length; d < f; d++)for (var m = p[d], g = 0; g < 3; g++)n = m[l[g]], i = m[l[(g + 1) % 3]], c[0] = Math.min(n, i), c[1] = Math.max(n, i), void 0 === h[r = c[0] + "," + c[1]] ? h[r] = { index1: c[0], index2: c[1], face1: d, face2: void 0 } : h[r].face2 = d; for (r in h) { var v, y = h[r]; (void 0 === y.face2 || p[y.face1].normal.dot(p[y.face2].normal) <= s) && (v = u[y.index1], o.push(v.x, v.y, v.z), v = u[y.index2], o.push(v.x, v.y, v.z)) } this.addAttribute("position", new ki(o, 3)) } function Fc(t, e, n, i, r, a, o, s) { Di.call(this), this.type = "CylinderGeometry", this.parameters = { radiusTop: t, radiusBottom: e, height: n, radialSegments: i, heightSegments: r, openEnded: a, thetaStart: o, thetaLength: s }, this.fromBufferGeometry(new Hc(t, e, n, i, r, a, o, s)), this.mergeVertices() } function Hc(g, v, y, x, b, t, w, _) { rr.call(this), this.type = "CylinderBufferGeometry", this.parameters = { radiusTop: g, radiusBottom: v, height: y, radialSegments: x, heightSegments: b, openEnded: t, thetaStart: w, thetaLength: _ }; var M = this; g = void 0 !== g ? g : 1, v = void 0 !== v ? v : 1, y = y || 1, x = Math.floor(x) || 8, b = Math.floor(b) || 1, t = void 0 !== t && t, w = void 0 !== w ? w : 0, _ = void 0 !== _ ? _ : 2 * Math.PI; var E = [], S = [], T = [], A = [], L = 0, R = [], P = y / 2, C = 0; function e(t) { for (var e, n = new ke, i = new qe, r = 0, a = !0 === t ? g : v, o = !0 === t ? 1 : -1, s = L, c = 1; c <= x; c++)S.push(0, P * o, 0), T.push(0, o, 0), A.push(.5, .5), L++; for (e = L, c = 0; c <= x; c++) { var h = c / x * _ + w, l = Math.cos(h), h = Math.sin(h); i.x = a * h, i.y = P * o, i.z = a * l, S.push(i.x, i.y, i.z), T.push(0, o, 0), n.x = .5 * l + .5, n.y = .5 * h * o + .5, A.push(n.x, n.y), L++ } for (c = 0; c < x; c++) { var u = s + c, p = e + c; !0 === t ? E.push(p, p + 1, u) : E.push(p + 1, p, u), r += 3 } M.addGroup(C, r, !0 === t ? 1 : 2), C += r } !function () { var t, e, n = new qe, i = new qe, r = 0, a = (v - g) / y; for (e = 0; e <= b; e++) { var o = [], s = e / b, c = s * (v - g) + g; for (t = 0; t <= x; t++) { var h = t / x, l = h * _ + w, u = Math.sin(l), l = Math.cos(l); i.x = c * u, i.y = -s * y + P, i.z = c * l, S.push(i.x, i.y, i.z), n.set(u, a, l).normalize(), T.push(n.x, n.y, n.z), A.push(h, 1 - s), o.push(L++) } R.push(o) } for (t = 0; t < x; t++)for (e = 0; e < b; e++) { var p = R[e][t], d = R[e + 1][t], f = R[e + 1][t + 1], m = R[e][t + 1]; E.push(p, d, m), E.push(d, f, m), r += 6 } M.addGroup(C, r, 0), C += r }(), !1 === t && (0 < g && e(!0), 0 < v && e(!1)), this.setIndex(E), this.addAttribute("position", new ki(S, 3)), this.addAttribute("normal", new ki(T, 3)), this.addAttribute("uv", new ki(A, 2)) } function Vc(t, e, n, i, r, a, o) { Fc.call(this, 0, t, e, n, i, r, a, o), this.type = "ConeGeometry", this.parameters = { radius: t, height: e, radialSegments: n, heightSegments: i, openEnded: r, thetaStart: a, thetaLength: o } } function kc(t, e, n, i, r, a, o) { Hc.call(this, 0, t, e, n, i, r, a, o), this.type = "ConeBufferGeometry", this.parameters = { radius: t, height: e, radialSegments: n, heightSegments: i, openEnded: r, thetaStart: a, thetaLength: o } } function jc(t, e, n, i) { Di.call(this), this.type = "CircleGeometry", this.parameters = { radius: t, segments: e, thetaStart: n, thetaLength: i }, this.fromBufferGeometry(new Wc(t, e, n, i)), this.mergeVertices() } function Wc(t, e, n, i) { rr.call(this), this.type = "CircleBufferGeometry", this.parameters = { radius: t, segments: e, thetaStart: n, thetaLength: i }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, n = void 0 !== n ? n : 0, i = void 0 !== i ? i : 2 * Math.PI; var r, a, o = [], s = [], c = [], h = [], l = new qe, u = new ke; for (s.push(0, 0, 0), c.push(0, 0, 1), h.push(.5, .5), a = 0, r = 3; a <= e; a++, r += 3) { var p = n + a / e * i; l.x = t * Math.cos(p), l.y = t * Math.sin(p), s.push(l.x, l.y, l.z), c.push(0, 0, 1), u.x = (s[r] / t + 1) / 2, u.y = (s[r + 1] / t + 1) / 2, h.push(u.x, u.y) } for (r = 1; r <= e; r++)o.push(r, r + 1, 0); this.setIndex(o), this.addAttribute("position", new ki(s, 3)), this.addAttribute("normal", new ki(c, 3)), this.addAttribute("uv", new ki(h, 2)) } (Lc.prototype = Object.create(Di.prototype)).constructor = Lc, (Rc.prototype = Object.create(Sc.prototype)).constructor = Rc, (Pc.prototype = Object.create(Di.prototype)).constructor = Pc, (Cc.prototype = Object.create(rr.prototype)).constructor = Cc, (Oc.prototype = Object.create(Di.prototype)).constructor = Oc, (Ic.prototype = Object.create(rr.prototype)).constructor = Ic, (Dc.prototype = Object.create(Di.prototype)).constructor = Dc, (Nc.prototype = Object.create(rr.prototype)).constructor = Nc, ((Bc.prototype = Object.create(Di.prototype)).constructor = Bc).prototype.toJSON = function () { var t = Di.prototype.toJSON.call(this); return Uc(this.parameters.shapes, t) }, ((zc.prototype = Object.create(rr.prototype)).constructor = zc).prototype.toJSON = function () { var t = rr.prototype.toJSON.call(this); return Uc(this.parameters.shapes, t) }, (Gc.prototype = Object.create(rr.prototype)).constructor = Gc, (Fc.prototype = Object.create(Di.prototype)).constructor = Fc, (Hc.prototype = Object.create(rr.prototype)).constructor = Hc, (Vc.prototype = Object.create(Fc.prototype)).constructor = Vc, (kc.prototype = Object.create(Hc.prototype)).constructor = kc, (jc.prototype = Object.create(Di.prototype)).constructor = jc, (Wc.prototype = Object.create(rr.prototype)).constructor = Wc; var qc = Object.freeze({ WireframeGeometry: Hs, ParametricGeometry: Vs, ParametricBufferGeometry: ks, TetrahedronGeometry: qs, TetrahedronBufferGeometry: Xs, OctahedronGeometry: Ys, OctahedronBufferGeometry: Js, IcosahedronGeometry: Zs, IcosahedronBufferGeometry: Qs, DodecahedronGeometry: Ks, DodecahedronBufferGeometry: $s, PolyhedronGeometry: js, PolyhedronBufferGeometry: Ws, TubeGeometry: tc, TubeBufferGeometry: ec, TorusKnotGeometry: nc, TorusKnotBufferGeometry: ic, TorusGeometry: rc, TorusBufferGeometry: ac, TextGeometry: Lc, TextBufferGeometry: Rc, SphereGeometry: Pc, SphereBufferGeometry: Cc, RingGeometry: Oc, RingBufferGeometry: Ic, PlaneGeometry: sr, PlaneBufferGeometry: cr, LatheGeometry: Dc, LatheBufferGeometry: Nc, ShapeGeometry: Bc, ShapeBufferGeometry: zc, ExtrudeGeometry: Ec, ExtrudeBufferGeometry: Sc, EdgesGeometry: Gc, ConeGeometry: Vc, ConeBufferGeometry: kc, CylinderGeometry: Fc, CylinderBufferGeometry: Hc, CircleGeometry: jc, CircleBufferGeometry: Wc, BoxGeometry: ar, BoxBufferGeometry: or }); function Xc(t) { lr.call(this), this.type = "ShadowMaterial", this.color = new Xn(0), this.transparent = !0, this.setValues(t) } function Yc(t) { Kr.call(this, t), this.type = "RawShaderMaterial" } function Jc(t) { lr.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Xn(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fe, this.normalScale = new ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function Zc(t) { Jc.call(this), this.defines = { PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(t) } function Qc(t) { lr.call(this), this.type = "MeshPhongMaterial", this.color = new Xn(16777215), this.specular = new Xn(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fe, this.normalScale = new ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = j, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function Kc(t) { Qc.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t) } function $c(t) { lr.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fe, this.normalScale = new ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function th(t) { lr.call(this), this.type = "MeshLambertMaterial", this.color = new Xn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = j, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function eh(t) { lr.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Xn(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fe, this.normalScale = new ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.lights = !1, this.setValues(t) } function nh(t) { Cs.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t) } ((Xc.prototype = Object.create(lr.prototype)).constructor = Xc).prototype.isShadowMaterial = !0, Xc.prototype.copy = function (t) { return lr.prototype.copy.call(this, t), this.color.copy(t.color), this }, ((Yc.prototype = Object.create(Kr.prototype)).constructor = Yc).prototype.isRawShaderMaterial = !0, ((Jc.prototype = Object.create(lr.prototype)).constructor = Jc).prototype.isMeshStandardMaterial = !0, Jc.prototype.copy = function (t) { return lr.prototype.copy.call(this, t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, ((Zc.prototype = Object.create(Jc.prototype)).constructor = Zc).prototype.isMeshPhysicalMaterial = !0, Zc.prototype.copy = function (t) { return Jc.prototype.copy.call(this, t), this.defines = { PHYSICAL: "" }, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this }, ((Qc.prototype = Object.create(lr.prototype)).constructor = Qc).prototype.isMeshPhongMaterial = !0, Qc.prototype.copy = function (t) { return lr.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, ((Kc.prototype = Object.create(Qc.prototype)).constructor = Kc).prototype.isMeshToonMaterial = !0, Kc.prototype.copy = function (t) { return Qc.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this }, (($c.prototype = Object.create(lr.prototype)).constructor = $c).prototype.isMeshNormalMaterial = !0, $c.prototype.copy = function (t) { return lr.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, ((th.prototype = Object.create(lr.prototype)).constructor = th).prototype.isMeshLambertMaterial = !0, th.prototype.copy = function (t) { return lr.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, ((eh.prototype = Object.create(lr.prototype)).constructor = eh).prototype.isMeshMatcapMaterial = !0, eh.prototype.copy = function (t) { return lr.prototype.copy.call(this, t), this.defines = { MATCAP: "" }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, ((nh.prototype = Object.create(Cs.prototype)).constructor = nh).prototype.isLineDashedMaterial = !0, nh.prototype.copy = function (t) { return Cs.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this }; var ih = Object.freeze({ ShadowMaterial: Xc, SpriteMaterial: Es, RawShaderMaterial: Yc, ShaderMaterial: Kr, PointsMaterial: Ns, MeshPhysicalMaterial: Zc, MeshStandardMaterial: Jc, MeshPhongMaterial: Qc, MeshToonMaterial: Kc, MeshNormalMaterial: $c, MeshLambertMaterial: th, MeshDepthMaterial: Ro, MeshDistanceMaterial: Po, MeshBasicMaterial: ea, MeshMatcapMaterial: eh, LineDashedMaterial: nh, LineBasicMaterial: Cs, Material: lr }), rh = { arraySlice: function (t, e, n) { return rh.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n) }, convertArray: function (t, e, n) { return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t) }, isTypedArray: function (t) { return ArrayBuffer.isView(t) && !(t instanceof DataView) }, getKeyframeOrder: function (n) { for (var t = n.length, e = new Array(t), i = 0; i !== t; ++i)e[i] = i; return e.sort(function (t, e) { return n[t] - n[e] }), e }, sortedArray: function (t, e, n) { for (var i = t.length, r = new t.constructor(i), a = 0, o = 0; o !== i; ++a)for (var s = n[a] * e, c = 0; c !== e; ++c)r[o++] = t[s + c]; return r }, flattenJSON: function (t, e, n, i) { for (var r = 1, a = t[0]; void 0 !== a && void 0 === a[i];)a = t[r++]; if (void 0 !== a) { var o = a[i]; if (void 0 !== o) if (Array.isArray(o)) for (; void 0 !== (o = a[i]) && (e.push(a.time), n.push.apply(n, o)), a = t[r++], void 0 !== a;); else if (void 0 !== o.toArray) for (; void 0 !== (o = a[i]) && (e.push(a.time), o.toArray(n, n.length)), a = t[r++], void 0 !== a;); else for (; void 0 !== (o = a[i]) && (e.push(a.time), n.push(o)), a = t[r++], void 0 !== a;); } } }; function ah(t, e, n, i) { this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n } function oh(t, e, n, i) { ah.call(this, t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0 } function sh(t, e, n, i) { ah.call(this, t, e, n, i) } function ch(t, e, n, i) { ah.call(this, t, e, n, i) } function hh(t, e, n, i) { if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t); this.name = t, this.times = rh.convertArray(e, this.TimeBufferType), this.values = rh.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation) } function lh(t, e, n) { hh.call(this, t, e, n) } function uh(t, e, n, i) { hh.call(this, t, e, n, i) } function ph(t, e, n, i) { hh.call(this, t, e, n, i) } function dh(t, e, n, i) { ah.call(this, t, e, n, i) } function fh(t, e, n, i) { hh.call(this, t, e, n, i) } function mh(t, e, n, i) { hh.call(this, t, e, n, i) } function gh(t, e, n, i) { hh.call(this, t, e, n, i) } function vh(t, e, n) { this.name = t, this.tracks = n, this.duration = void 0 !== e ? e : -1, this.uuid = Ve.generateUUID(), this.duration < 0 && this.resetDuration() } function yh(t) { if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); var e, n, i = function (t) { switch (t.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return ph; case "vector": case "vector2": case "vector3": case "vector4": return gh; case "color": return uh; case "quaternion": return fh; case "bool": case "boolean": return lh; case "string": return mh }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t) }(t.type); return void 0 === t.times && (e = [], n = [], rh.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n), void 0 !== i.parse ? i.parse(t) : new i(t.name, t.times, t.values, t.interpolation) } Object.assign(ah.prototype, { evaluate: function (t) { var e, n = this.parameterPositions, i = this._cachedIndex, r = n[i], a = n[i - 1]; t: { e: { n: { i: if (!(t < r)) { for (var o = i + 2; ;) { if (void 0 === r) { if (t < a) break i; return i = n.length, this._cachedIndex = i, this.afterEnd_(i - 1, t, a) } if (i === o) break; if (a = r, t < (r = n[++i])) break e } e = n.length; break n } if (a <= t) break t; var s = n[1]; t < s && (i = 2, a = s); for (o = i - 2; ;) { if (void 0 === a) return this._cachedIndex = 0, this.beforeStart_(0, t, r); if (i === o) break; if (r = a, (a = n[--i - 1]) <= t) break e } e = i, i = 0 } for (; i < e;) { var c = i + e >>> 1; t < n[c] ? e = c : i = 1 + c } if (r = n[i], void 0 === (a = n[i - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, r); if (void 0 === r) return i = n.length, this._cachedIndex = i, this.afterEnd_(i - 1, a, t) } this._cachedIndex = i, this.intervalChanged_(i, a, r) } return this.interpolate_(i, a, t, r) }, settings: null, DefaultSettings_: {}, getSettings_: function () { return this.settings || this.DefaultSettings_ }, copySampleValue_: function (t) { for (var e = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = t * i, a = 0; a !== i; ++a)e[a] = n[r + a]; return e }, interpolate_: function () { throw new Error("call to abstract method") }, intervalChanged_: function () { } }), Object.assign(ah.prototype, { beforeStart_: ah.prototype.copySampleValue_, afterEnd_: ah.prototype.copySampleValue_ }), oh.prototype = Object.assign(Object.create(ah.prototype), { constructor: oh, DefaultSettings_: { endingStart: Ae, endingEnd: Ae }, intervalChanged_: function (t, e, n) { var i = this.parameterPositions, r = t - 2, a = t + 1, o = i[r], s = i[a]; if (void 0 === o) switch (this.getSettings_().endingStart) { case Le: r = t, o = 2 * e - n; break; case Re: o = e + i[r = i.length - 2] - i[r + 1]; break; default: r = t, o = n }if (void 0 === s) switch (this.getSettings_().endingEnd) { case Le: a = t, s = 2 * n - e; break; case Re: s = n + i[a = 1] - i[0]; break; default: a = t - 1, s = e }var c = .5 * (n - e), h = this.valueSize; this._weightPrev = c / (e - o), this._weightNext = c / (s - n), this._offsetPrev = r * h, this._offsetNext = a * h }, interpolate_: function (t, e, n, i) { for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, c = s - o, h = this._offsetPrev, l = this._offsetNext, u = this._weightPrev, t = this._weightNext, n = (n - e) / (i - e), i = n * n, e = i * n, p = -u * e + 2 * u * i - u * n, d = (1 + u) * e + (-1.5 - 2 * u) * i + (-.5 + u) * n + 1, f = (-1 - t) * e + (1.5 + t) * i + .5 * n, m = t * e - t * i, g = 0; g !== o; ++g)r[g] = p * a[h + g] + d * a[c + g] + f * a[s + g] + m * a[l + g]; return r } }), sh.prototype = Object.assign(Object.create(ah.prototype), { constructor: sh, interpolate_: function (t, e, n, i) { for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, c = s - o, h = (n - e) / (i - e), l = 1 - h, u = 0; u !== o; ++u)r[u] = a[c + u] * l + a[s + u] * h; return r } }), ch.prototype = Object.assign(Object.create(ah.prototype), { constructor: ch, interpolate_: function (t) { return this.copySampleValue_(t - 1) } }), Object.assign(hh, { toJSON: function (t) { var e, n = t.constructor; return void 0 !== n.toJSON ? e = n.toJSON(t) : (e = { name: t.name, times: rh.convertArray(t.times, Array), values: rh.convertArray(t.values, Array) }, (n = t.getInterpolation()) !== t.DefaultInterpolation && (e.interpolation = n)), e.type = t.ValueTypeName, e } }), Object.assign(hh.prototype, { constructor: hh, TimeBufferType: Float32Array, ValueBufferType: Float32Array, DefaultInterpolation: Te, InterpolantFactoryMethodDiscrete: function (t) { return new ch(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodLinear: function (t) { return new sh(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodSmooth: function (t) { return new oh(this.times, this.values, this.getValueSize(), t) }, setInterpolation: function (t) { var e; switch (t) { case Se: e = this.InterpolantFactoryMethodDiscrete; break; case Te: e = this.InterpolantFactoryMethodLinear; break; case 2302: e = this.InterpolantFactoryMethodSmooth }if (void 0 !== e) return this.createInterpolant = e, this; var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (t === this.DefaultInterpolation) throw new Error(n); this.setInterpolation(this.DefaultInterpolation) } return console.warn("THREE.KeyframeTrack:", n), this }, getInterpolation: function () { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return Se; case this.InterpolantFactoryMethodLinear: return Te; case this.InterpolantFactoryMethodSmooth: return 2302 } }, getValueSize: function () { return this.values.length / this.times.length }, shift: function (t) { if (0 !== t) for (var e = this.times, n = 0, i = e.length; n !== i; ++n)e[n] += t; return this }, scale: function (t) { if (1 !== t) for (var e = this.times, n = 0, i = e.length; n !== i; ++n)e[n] *= t; return this }, trim: function (t, e) { for (var n, i = this.times, r = i.length, a = 0, o = r - 1; a !== r && i[a] < t;)++a; for (; -1 !== o && i[o] > e;)--o; return ++o, 0 === a && o === r || (o <= a && (a = (o = Math.max(o, 1)) - 1), n = this.getValueSize(), this.times = rh.arraySlice(i, a, o), this.values = rh.arraySlice(this.values, a * n, o * n)), this }, validate: function () { var t = !0, e = this.getValueSize(); e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1); var n = this.times, i = this.values, r = n.length; 0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1); for (var a = null, o = 0; o !== r; o++) { var s = n[o]; if ("number" == typeof s && isNaN(s)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, s), t = !1; break } if (null !== a && s < a) { console.error("THREE.KeyframeTrack: Out of order keys.", this, o, s, a), t = !1; break } a = s } if (void 0 !== i && rh.isTypedArray(i)) for (var o = 0, c = i.length; o !== c; ++o) { var h = i[o]; if (isNaN(h)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, h), t = !1; break } } return t }, optimize: function () { for (var t = this.times, e = this.values, n = this.getValueSize(), i = 2302 === this.getInterpolation(), r = 1, a = t.length - 1, o = 1; o < a; ++o) { var s = !1, c = t[o]; if (c !== t[o + 1] && (1 !== o || c !== c[0])) if (i) s = !0; else for (var h = o * n, l = h - n, u = h + n, p = 0; p !== n; ++p) { var d = e[h + p]; if (d !== e[l + p] || d !== e[u + p]) { s = !0; break } } if (s) { if (o !== r) { t[r] = t[o]; for (var f = o * n, m = r * n, p = 0; p !== n; ++p)e[m + p] = e[f + p] } ++r } } if (0 < a) { t[r] = t[a]; for (f = a * n, m = r * n, p = 0; p !== n; ++p)e[m + p] = e[f + p]; ++r } return r !== t.length && (this.times = rh.arraySlice(t, 0, r), this.values = rh.arraySlice(e, 0, r * n)), this }, clone: function () { var t = rh.arraySlice(this.times, 0), e = rh.arraySlice(this.values, 0), e = new this.constructor(this.name, t, e); return e.createInterpolant = this.createInterpolant, e } }), lh.prototype = Object.assign(Object.create(hh.prototype), { constructor: lh, ValueTypeName: "bool", ValueBufferType: Array, DefaultInterpolation: Se, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), uh.prototype = Object.assign(Object.create(hh.prototype), { constructor: uh, ValueTypeName: "color" }), ph.prototype = Object.assign(Object.create(hh.prototype), { constructor: ph, ValueTypeName: "number" }), dh.prototype = Object.assign(Object.create(ah.prototype), { constructor: dh, interpolate_: function (t, e, n, i) { for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, c = (n - e) / (i - e), h = s + o; s !== h; s += 4)We.slerpFlat(r, 0, a, s - o, a, s, c); return r } }), fh.prototype = Object.assign(Object.create(hh.prototype), { constructor: fh, ValueTypeName: "quaternion", DefaultInterpolation: Te, InterpolantFactoryMethodLinear: function (t) { return new dh(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodSmooth: void 0 }), mh.prototype = Object.assign(Object.create(hh.prototype), { constructor: mh, ValueTypeName: "string", ValueBufferType: Array, DefaultInterpolation: Se, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), gh.prototype = Object.assign(Object.create(hh.prototype), { constructor: gh, ValueTypeName: "vector" }), Object.assign(vh, { parse: function (t) { for (var e = [], n = t.tracks, i = 1 / (t.fps || 1), r = 0, a = n.length; r !== a; ++r)e.push(yh(n[r]).scale(i)); return new vh(t.name, t.duration, e) }, toJSON: function (t) { for (var e = [], n = t.tracks, t = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid }, i = 0, r = n.length; i !== r; ++i)e.push(hh.toJSON(n[i])); return t }, CreateFromMorphTargetSequence: function (t, e, n, i) { for (var r = e.length, a = [], o = 0; o < r; o++) { var s = []; (h = []).push((o + r - 1) % r, o, (o + 1) % r), s.push(0, 1, 0); var c = rh.getKeyframeOrder(h), h = rh.sortedArray(h, 1, c), s = rh.sortedArray(s, 1, c); i || 0 !== h[0] || (h.push(r), s.push(s[0])), a.push(new ph(".morphTargetInfluences[" + e[o].name + "]", h, s).scale(1 / n)) } return new vh(t, -1, a) }, findByName: function (t, e) { var n = t; Array.isArray(t) || (n = t.geometry && t.geometry.animations || t.animations); for (var i = 0; i < n.length; i++)if (n[i].name === e) return n[i]; return null }, CreateClipsFromMorphTargetSequences: function (t, e, n) { for (var i = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = t.length; a < o; a++) { var s = t[a], c = s.name.match(r); c && 1 < c.length && ((c = i[h = c[1]]) || (i[h] = c = []), c.push(s)) } var h, l = []; for (h in i) l.push(vh.CreateFromMorphTargetSequence(h, i[h], e, n)); return l }, parseAnimation: function (t, e) { if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; for (var n = function (t, e, n, i, r) { var a, o; 0 !== n.length && (a = [], o = [], rh.flattenJSON(n, a, o, i), 0 !== a.length && r.push(new t(e, a, o))) }, i = [], r = t.name || "default", a = t.length || -1, o = t.fps || 30, s = t.hierarchy || [], c = 0; c < s.length; c++) { var h = s[c].keys; if (h && 0 !== h.length) if (h[0].morphTargets) { for (var l, u = {}, p = 0; p < h.length; p++)if (h[p].morphTargets) for (var d = 0; d < h[p].morphTargets.length; d++)u[h[p].morphTargets[d]] = -1; for (l in u) { for (var f = [], m = [], d = 0; d !== h[p].morphTargets.length; ++d) { var g = h[p]; f.push(g.time), m.push(g.morphTarget === l ? 1 : 0) } i.push(new ph(".morphTargetInfluence[" + l + "]", f, m)) } a = u.length * (o || 1) } else { var v = ".bones[" + e[c].name + "]"; n(gh, v + ".position", h, "pos", i), n(fh, v + ".quaternion", h, "rot", i), n(gh, v + ".scale", h, "scl", i) } } return 0 === i.length ? null : new vh(r, a, i) } }), Object.assign(vh.prototype, { resetDuration: function () { for (var t = 0, e = 0, n = this.tracks.length; e !== n; ++e)var i = this.tracks[e], t = Math.max(t, i.times[i.times.length - 1]); return this.duration = t, this }, trim: function () { for (var t = 0; t < this.tracks.length; t++)this.tracks[t].trim(0, this.duration); return this }, validate: function () { for (var t = !0, e = 0; e < this.tracks.length; e++)t = t && this.tracks[e].validate(); return t }, optimize: function () { for (var t = 0; t < this.tracks.length; t++)this.tracks[t].optimize(); return this }, clone: function () { for (var t = [], e = 0; e < this.tracks.length; e++)t.push(this.tracks[e].clone()); return new vh(this.name, this.duration, t) } }); var xh = { enabled: !1, files: {}, add: function (t, e) { !1 !== this.enabled && (this.files[t] = e) }, get: function (t) { if (!1 !== this.enabled) return this.files[t] }, remove: function (t) { delete this.files[t] }, clear: function () { this.files = {} } }; function bh(t, e, n) { var i = this, r = !1, a = 0, o = 0, s = void 0; this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (t) { o++, !1 === r && void 0 !== i.onStart && i.onStart(t, a, o), r = !0 }, this.itemEnd = function (t) { a++, void 0 !== i.onProgress && i.onProgress(t, a, o), a === o && (r = !1, void 0 !== i.onLoad && i.onLoad()) }, this.itemError = function (t) { void 0 !== i.onError && i.onError(t) }, this.resolveURL = function (t) { return s ? s(t) : t }, this.setURLModifier = function (t) { return s = t, this } } var wh = new bh, _h = {}; function Mh(t) { this.manager = void 0 !== t ? t : wh } function Eh(t) { this.manager = void 0 !== t ? t : wh } function Sh(t) { this.manager = void 0 !== t ? t : wh, this._parser = null } function Th(t) { this.manager = void 0 !== t ? t : wh, this._parser = null } function Ah(t) { this.manager = void 0 !== t ? t : wh } function Lh(t) { this.manager = void 0 !== t ? t : wh } function Rh(t) { this.manager = void 0 !== t ? t : wh } function Ph() { this.type = "Curve", this.arcLengthDivisions = 200 } function Ch(t, e, n, i, r, a, o, s) { Ph.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = n || 1, this.yRadius = i || 1, this.aStartAngle = r || 0, this.aEndAngle = a || 2 * Math.PI, this.aClockwise = o || !1, this.aRotation = s || 0 } function Oh(t, e, n, i, r, a) { Ch.call(this, t, e, n, n, i, r, a), this.type = "ArcCurve" } function Ih() { var r = 0, a = 0, o = 0, s = 0; function c(t, e, n, i) { o = -3 * (r = t) + 3 * e - 2 * (a = n) - i, s = 2 * t - 2 * e + n + i } return { initCatmullRom: function (t, e, n, i, r) { c(e, n, r * (n - t), r * (i - e)) }, initNonuniformCatmullRom: function (t, e, n, i, r, a, o) { r = (e - t) / r - (n - t) / (r + a) + (n - e) / a, o = (n - e) / a - (i - e) / (a + o) + (i - n) / o; c(e, n, r *= a, o *= a) }, calc: function (t) { var e = t * t; return r + a * t + o * e + s * (e * t) } } } Object.assign(Mh.prototype, { load: function (o, t, e, n) { void 0 === o && (o = ""), void 0 !== this.path && (o = this.path + o), o = this.manager.resolveURL(o); var s = this, i = xh.get(o); if (void 0 !== i) return s.manager.itemStart(o), setTimeout(function () { t && t(i), s.manager.itemEnd(o) }, 0), i; if (void 0 === _h[o]) { var r = o.match(/^data:(.*?)(;base64)?,(.*)$/); if (r) { var a = r[1], c = !!r[2], h = r[3], h = decodeURIComponent(h); c && (h = atob(h)); try { var l = (this.responseType || "").toLowerCase(); switch (l) { case "arraybuffer": case "blob": for (var u = new Uint8Array(h.length), p = 0; p < h.length; p++)u[p] = h.charCodeAt(p); d = "blob" === l ? new Blob([u.buffer], { type: a }) : u.buffer; break; case "document": var d = (new DOMParser).parseFromString(h, a); break; case "json": d = JSON.parse(h); break; default: d = h }setTimeout(function () { t && t(d), s.manager.itemEnd(o) }, 0) } catch (t) { setTimeout(function () { n && n(t), s.manager.itemError(o), s.manager.itemEnd(o) }, 0) } } else { _h[o] = [], _h[o].push({ onLoad: t, onProgress: e, onError: n }); var f, m = new XMLHttpRequest; for (f in m.open("GET", o, !0), m.addEventListener("load", function (t) { var e = this.response; xh.add(o, e); var n = _h[o]; if (delete _h[o], 200 === this.status || 0 === this.status) { 0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."); for (var i = 0, r = n.length; i < r; i++)(a = n[i]).onLoad && a.onLoad(e); s.manager.itemEnd(o) } else { for (var a, i = 0, r = n.length; i < r; i++)(a = n[i]).onError && a.onError(t); s.manager.itemError(o), s.manager.itemEnd(o) } }, !1), m.addEventListener("progress", function (t) { for (var e = _h[o], n = 0, i = e.length; n < i; n++) { var r = e[n]; r.onProgress && r.onProgress(t) } }, !1), m.addEventListener("error", function (t) { var e = _h[o]; delete _h[o]; for (var n = 0, i = e.length; n < i; n++) { var r = e[n]; r.onError && r.onError(t) } s.manager.itemError(o), s.manager.itemEnd(o) }, !1), m.addEventListener("abort", function (t) { var e = _h[o]; delete _h[o]; for (var n = 0, i = e.length; n < i; n++) { var r = e[n]; r.onError && r.onError(t) } s.manager.itemError(o), s.manager.itemEnd(o) }, !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) m.setRequestHeader(f, this.requestHeader[f]); m.send(null) } return s.manager.itemStart(o), m } _h[o].push({ onLoad: t, onProgress: e, onError: n }) }, setPath: function (t) { return this.path = t, this }, setResponseType: function (t) { return this.responseType = t, this }, setWithCredentials: function (t) { return this.withCredentials = t, this }, setMimeType: function (t) { return this.mimeType = t, this }, setRequestHeader: function (t) { return this.requestHeader = t, this } }), Object.assign(Eh.prototype, { load: function (t, e, n, i) { var r = this, a = new Mh(r.manager); a.setPath(r.path), a.load(t, function (t) { e(r.parse(JSON.parse(t))) }, n, i) }, parse: function (t, e) { for (var n = [], i = 0; i < t.length; i++) { var r = vh.parse(t[i]); n.push(r) } e(n) }, setPath: function (t) { return this.path = t, this } }), Object.assign(Sh.prototype, { load: function (t, a, n, i) { var o = this, s = [], c = new Us; c.image = s; var r = new Mh(this.manager); if (r.setPath(this.path), r.setResponseType("arraybuffer"), Array.isArray(t)) for (var h = 0, e = 0, l = t.length; e < l; ++e)!function (e) { r.load(t[e], function (t) { t = o._parser(t, !0); s[e] = { width: t.width, height: t.height, format: t.format, mipmaps: t.mipmaps }, 6 === (h += 1) && (1 === t.mipmapCount && (c.minFilter = Ot), c.format = t.format, c.needsUpdate = !0, a && a(c)) }, n, i) }(e); else r.load(t, function (t) { var e = o._parser(t, !0); if (e.isCubemap) for (var n = e.mipmaps.length / e.mipmapCount, i = 0; i < n; i++) { s[i] = { mipmaps: [] }; for (var r = 0; r < e.mipmapCount; r++)s[i].mipmaps.push(e.mipmaps[i * e.mipmapCount + r]), s[i].format = e.format, s[i].width = e.width, s[i].height = e.height } else c.image.width = e.width, c.image.height = e.height, c.mipmaps = e.mipmaps; 1 === e.mipmapCount && (c.minFilter = Ot), c.format = e.format, c.needsUpdate = !0, a && a(c) }, n, i); return c }, setPath: function (t) { return this.path = t, this } }), Object.assign(Th.prototype, { load: function (t, e, n, i) { var r = this, a = new On, o = new Mh(this.manager); return o.setResponseType("arraybuffer"), o.setPath(this.path), o.load(t, function (t) { t = r._parser(t); t && (void 0 !== t.image ? a.image = t.image : void 0 !== t.data && (a.image.width = t.width, a.image.height = t.height, a.image.data = t.data), a.wrapS = void 0 !== t.wrapS ? t.wrapS : At, a.wrapT = void 0 !== t.wrapT ? t.wrapT : At, a.magFilter = void 0 !== t.magFilter ? t.magFilter : Ot, a.minFilter = void 0 !== t.minFilter ? t.minFilter : Dt, a.anisotropy = void 0 !== t.anisotropy ? t.anisotropy : 1, void 0 !== t.format && (a.format = t.format), void 0 !== t.type && (a.type = t.type), void 0 !== t.mipmaps && (a.mipmaps = t.mipmaps), 1 === t.mipmapCount && (a.minFilter = Ot), a.needsUpdate = !0, e && e(a, t)) }, n, i), a }, setPath: function (t) { return this.path = t, this } }), Object.assign(Ah.prototype, { crossOrigin: "anonymous", load: function (e, t, n, i) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); var r = this, a = xh.get(e); if (void 0 !== a) return r.manager.itemStart(e), setTimeout(function () { t && t(a), r.manager.itemEnd(e) }, 0), a; var o = document.createElementNS("http://www.w3.org/1999/xhtml", "img"); function s() { o.removeEventListener("load", s, !1), o.removeEventListener("error", c, !1), xh.add(e, this), t && t(this), r.manager.itemEnd(e) } function c(t) { o.removeEventListener("load", s, !1), o.removeEventListener("error", c, !1), i && i(t), r.manager.itemError(e), r.manager.itemEnd(e) } return o.addEventListener("load", s, !1), o.addEventListener("error", c, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(e), o.src = e, o }, setCrossOrigin: function (t) { return this.crossOrigin = t, this }, setPath: function (t) { return this.path = t, this } }), Object.assign(Lh.prototype, { crossOrigin: "anonymous", load: function (t, n, e, i) { var r = new ga, a = new Ah(this.manager); a.setCrossOrigin(this.crossOrigin), a.setPath(this.path); var o = 0; for (var s = 0; s < t.length; ++s)!function (e) { a.load(t[e], function (t) { r.images[e] = t, 6 === ++o && (r.needsUpdate = !0, n && n(r)) }, void 0, i) }(s); return r }, setCrossOrigin: function (t) { return this.crossOrigin = t, this }, setPath: function (t) { return this.path = t, this } }), Object.assign(Rh.prototype, { crossOrigin: "anonymous", load: function (e, n, t, i) { var r = new An, a = new Ah(this.manager); return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function (t) { r.image = t; t = 0 < e.search(/\.jpe?g($|\?)/i) || 0 === e.search(/^data\:image\/jpeg/); r.format = t ? Yt : Jt, r.needsUpdate = !0, void 0 !== n && n(r) }, t, i), r }, setCrossOrigin: function (t) { return this.crossOrigin = t, this }, setPath: function (t) { return this.path = t, this } }), Object.assign(Ph.prototype, { getPoint: function () { return console.warn("THREE.Curve: .getPoint() not implemented."), null }, getPointAt: function (t, e) { t = this.getUtoTmapping(t); return this.getPoint(t, e) }, getPoints: function (t) { void 0 === t && (t = 5); for (var e = [], n = 0; n <= t; n++)e.push(this.getPoint(n / t)); return e }, getSpacedPoints: function (t) { void 0 === t && (t = 5); for (var e = [], n = 0; n <= t; n++)e.push(this.getPointAt(n / t)); return e }, getLength: function () { var t = this.getLengths(); return t[t.length - 1] }, getLengths: function (t) { if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; var e, n, i = [], r = this.getPoint(0), a = 0; for (i.push(0), n = 1; n <= t; n++)a += (e = this.getPoint(n / t)).distanceTo(r), i.push(a), r = e; return this.cacheArcLengths = i }, updateArcLengths: function () { this.needsUpdate = !0, this.getLengths() }, getUtoTmapping: function (t, e) { for (var n, i = this.getLengths(), r = 0, a = i.length, o = e || t * i[a - 1], s = 0, c = a - 1; s <= c;)if ((n = i[r = Math.floor(s + (c - s) / 2)] - o) < 0) s = r + 1; else { if (!(0 < n)) { c = r; break } c = r - 1 } if (i[r = c] === o) return r / (a - 1); t = i[r]; return (r + (o - t) / (i[r + 1] - t)) / (a - 1) }, getTangent: function (t) { var e = t - 1e-4, t = t + 1e-4; e < 0 && (e = 0), 1 < t && (t = 1); e = this.getPoint(e); return this.getPoint(t).clone().sub(e).normalize() }, getTangentAt: function (t) { t = this.getUtoTmapping(t); return this.getTangent(t) }, computeFrenetFrames: function (t, e) { for (var n, i, r = new qe, a = [], o = [], s = [], c = new qe, h = new je, l = 0; l <= t; l++)n = l / t, a[l] = this.getTangentAt(n), a[l].normalize(); o[0] = new qe, s[0] = new qe; var u = Number.MAX_VALUE, p = Math.abs(a[0].x), d = Math.abs(a[0].y), f = Math.abs(a[0].z); for (p <= u && (u = p, r.set(1, 0, 0)), d <= u && (u = d, r.set(0, 1, 0)), f <= u && r.set(0, 0, 1), c.crossVectors(a[0], r).normalize(), o[0].crossVectors(a[0], c), s[0].crossVectors(a[0], o[0]), l = 1; l <= t; l++)o[l] = o[l - 1].clone(), s[l] = s[l - 1].clone(), c.crossVectors(a[l - 1], a[l]), c.length() > Number.EPSILON && (c.normalize(), i = Math.acos(Ve.clamp(a[l - 1].dot(a[l]), -1, 1)), o[l].applyMatrix4(h.makeRotationAxis(c, i))), s[l].crossVectors(a[l], o[l]); if (!0 === e) for (i = Math.acos(Ve.clamp(o[0].dot(o[t]), -1, 1)), i /= t, 0 < a[0].dot(c.crossVectors(o[0], o[t])) && (i = -i), l = 1; l <= t; l++)o[l].applyMatrix4(h.makeRotationAxis(a[l], i * l)), s[l].crossVectors(a[l], o[l]); return { tangents: a, normals: o, binormals: s } }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.arcLengthDivisions = t.arcLengthDivisions, this }, toJSON: function () { var t = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t }, fromJSON: function (t) { return this.arcLengthDivisions = t.arcLengthDivisions, this } }), ((Ch.prototype = Object.create(Ph.prototype)).constructor = Ch).prototype.isEllipseCurve = !0, Ch.prototype.getPoint = function (t, e) { for (var n = e || new ke, i = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, a = Math.abs(r) < Number.EPSILON; r < 0;)r += i; for (; i < r;)r -= i; r < Number.EPSILON && (r = a ? 0 : i), !0 !== this.aClockwise || a || (r === i ? r = -i : r -= i); var o = this.aStartAngle + t * r, s = this.aX + this.xRadius * Math.cos(o), c = this.aY + this.yRadius * Math.sin(o); return 0 !== this.aRotation && (e = Math.cos(this.aRotation), a = Math.sin(this.aRotation), s = (t = s - this.aX) * e - (o = c - this.aY) * a + this.aX, c = t * a + o * e + this.aY), n.set(s, c) }, Ch.prototype.copy = function (t) { return Ph.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this }, Ch.prototype.toJSON = function () { var t = Ph.prototype.toJSON.call(this); return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t }, Ch.prototype.fromJSON = function (t) { return Ph.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this }, ((Oh.prototype = Object.create(Ch.prototype)).constructor = Oh).prototype.isArcCurve = !0; var Dh = new qe, Nh = new Ih, Bh = new Ih, zh = new Ih; function Uh(t, e, n, i) { Ph.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = n || "centripetal", this.tension = i || .5 } function Gh(t, e, n, i, r) { var a = .5 * (i - e), e = .5 * (r - n), r = t * t; return (2 * n - 2 * i + a + e) * (t * r) + (-3 * n + 3 * i - 2 * a - e) * r + a * t + n } function Fh(t, e, n, i) { return (r = 1 - (r = t)) * r * e + 2 * (1 - (e = t)) * e * n + (t = t) * t * i; var r } function Hh(t, e, n, i, r) { return (a = 1 - (a = t)) * a * a * e + 3 * (e = 1 - (a = t)) * e * a * n + 3 * (1 - (n = t)) * n * n * i + (t = t) * t * t * r; var a } function Vh(t, e, n, i) { Ph.call(this), this.type = "CubicBezierCurve", this.v0 = t || new ke, this.v1 = e || new ke, this.v2 = n || new ke, this.v3 = i || new ke } function kh(t, e, n, i) { Ph.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new qe, this.v1 = e || new qe, this.v2 = n || new qe, this.v3 = i || new qe } function jh(t, e) { Ph.call(this), this.type = "LineCurve", this.v1 = t || new ke, this.v2 = e || new ke } function Wh(t, e) { Ph.call(this), this.type = "LineCurve3", this.v1 = t || new qe, this.v2 = e || new qe } function qh(t, e, n) { Ph.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new ke, this.v1 = e || new ke, this.v2 = n || new ke } function Xh(t, e, n) { Ph.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new qe, this.v1 = e || new qe, this.v2 = n || new qe } function Yh(t) { Ph.call(this), this.type = "SplineCurve", this.points = t || [] } ((Uh.prototype = Object.create(Ph.prototype)).constructor = Uh).prototype.isCatmullRomCurve3 = !0, Uh.prototype.getPoint = function (t, e) { var n, i = e || new qe, r = this.points, a = r.length, o = (a - (this.closed ? 0 : 1)) * t, s = Math.floor(o), c = o - s; return this.closed ? s += 0 < s ? 0 : (Math.floor(Math.abs(s) / a) + 1) * a : 0 === c && s === a - 1 && (s = a - 2, c = 1), n = this.closed || 0 < s ? r[(s - 1) % a] : (Dh.subVectors(r[0], r[1]).add(r[0]), Dh), e = r[s % a], t = r[(s + 1) % a], o = this.closed || s + 2 < a ? r[(s + 2) % a] : (Dh.subVectors(r[a - 1], r[a - 2]).add(r[a - 1]), Dh), "centripetal" === this.curveType || "chordal" === this.curveType ? (s = "chordal" === this.curveType ? .5 : .25, r = Math.pow(n.distanceToSquared(e), s), (a = Math.pow(e.distanceToSquared(t), s)) < 1e-4 && (a = 1), r < 1e-4 && (r = a), (s = Math.pow(t.distanceToSquared(o), s)) < 1e-4 && (s = a), Nh.initNonuniformCatmullRom(n.x, e.x, t.x, o.x, r, a, s), Bh.initNonuniformCatmullRom(n.y, e.y, t.y, o.y, r, a, s), zh.initNonuniformCatmullRom(n.z, e.z, t.z, o.z, r, a, s)) : "catmullrom" === this.curveType && (Nh.initCatmullRom(n.x, e.x, t.x, o.x, this.tension), Bh.initCatmullRom(n.y, e.y, t.y, o.y, this.tension), zh.initCatmullRom(n.z, e.z, t.z, o.z, this.tension)), i.set(Nh.calc(c), Bh.calc(c), zh.calc(c)), i }, Uh.prototype.copy = function (t) { Ph.prototype.copy.call(this, t), this.points = []; for (var e = 0, n = t.points.length; e < n; e++) { var i = t.points[e]; this.points.push(i.clone()) } return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this }, Uh.prototype.toJSON = function () { var t = Ph.prototype.toJSON.call(this); t.points = []; for (var e = 0, n = this.points.length; e < n; e++) { var i = this.points[e]; t.points.push(i.toArray()) } return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t }, Uh.prototype.fromJSON = function (t) { Ph.prototype.fromJSON.call(this, t), this.points = []; for (var e = 0, n = t.points.length; e < n; e++) { var i = t.points[e]; this.points.push((new qe).fromArray(i)) } return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this }, ((Vh.prototype = Object.create(Ph.prototype)).constructor = Vh).prototype.isCubicBezierCurve = !0, Vh.prototype.getPoint = function (t, e) { var n = e || new ke, i = this.v0, r = this.v1, a = this.v2, e = this.v3; return n.set(Hh(t, i.x, r.x, a.x, e.x), Hh(t, i.y, r.y, a.y, e.y)), n }, Vh.prototype.copy = function (t) { return Ph.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this }, Vh.prototype.toJSON = function () { var t = Ph.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t }, Vh.prototype.fromJSON = function (t) { return Ph.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this }, ((kh.prototype = Object.create(Ph.prototype)).constructor = kh).prototype.isCubicBezierCurve3 = !0, kh.prototype.getPoint = function (t, e) { var n = e || new qe, i = this.v0, r = this.v1, a = this.v2, e = this.v3; return n.set(Hh(t, i.x, r.x, a.x, e.x), Hh(t, i.y, r.y, a.y, e.y), Hh(t, i.z, r.z, a.z, e.z)), n }, kh.prototype.copy = function (t) { return Ph.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this }, kh.prototype.toJSON = function () { var t = Ph.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t }, kh.prototype.fromJSON = function (t) { return Ph.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this }, ((jh.prototype = Object.create(Ph.prototype)).constructor = jh).prototype.isLineCurve = !0, jh.prototype.getPoint = function (t, e) { e = e || new ke; return 1 === t ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e }, jh.prototype.getPointAt = function (t, e) { return this.getPoint(t, e) }, jh.prototype.getTangent = function () { return this.v2.clone().sub(this.v1).normalize() }, jh.prototype.copy = function (t) { return Ph.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, jh.prototype.toJSON = function () { var t = Ph.prototype.toJSON.call(this); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, jh.prototype.fromJSON = function (t) { return Ph.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, ((Wh.prototype = Object.create(Ph.prototype)).constructor = Wh).prototype.isLineCurve3 = !0, Wh.prototype.getPoint = function (t, e) { e = e || new qe; return 1 === t ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e }, Wh.prototype.getPointAt = function (t, e) { return this.getPoint(t, e) }, Wh.prototype.copy = function (t) { return Ph.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, Wh.prototype.toJSON = function () { var t = Ph.prototype.toJSON.call(this); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, Wh.prototype.fromJSON = function (t) { return Ph.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, ((qh.prototype = Object.create(Ph.prototype)).constructor = qh).prototype.isQuadraticBezierCurve = !0, qh.prototype.getPoint = function (t, e) { var n = e || new ke, i = this.v0, r = this.v1, e = this.v2; return n.set(Fh(t, i.x, r.x, e.x), Fh(t, i.y, r.y, e.y)), n }, qh.prototype.copy = function (t) { return Ph.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, qh.prototype.toJSON = function () { var t = Ph.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, qh.prototype.fromJSON = function (t) { return Ph.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, ((Xh.prototype = Object.create(Ph.prototype)).constructor = Xh).prototype.isQuadraticBezierCurve3 = !0, Xh.prototype.getPoint = function (t, e) { var n = e || new qe, i = this.v0, r = this.v1, e = this.v2; return n.set(Fh(t, i.x, r.x, e.x), Fh(t, i.y, r.y, e.y), Fh(t, i.z, r.z, e.z)), n }, Xh.prototype.copy = function (t) { return Ph.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, Xh.prototype.toJSON = function () { var t = Ph.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, Xh.prototype.fromJSON = function (t) { return Ph.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, ((Yh.prototype = Object.create(Ph.prototype)).constructor = Yh).prototype.isSplineCurve = !0, Yh.prototype.getPoint = function (t, e) { var n = e || new ke, i = this.points, r = (i.length - 1) * t, a = Math.floor(r), o = r - a, e = i[0 === a ? a : a - 1], t = i[a], r = i[a > i.length - 2 ? i.length - 1 : a + 1], a = i[a > i.length - 3 ? i.length - 1 : a + 2]; return n.set(Gh(o, e.x, t.x, r.x, a.x), Gh(o, e.y, t.y, r.y, a.y)), n }, Yh.prototype.copy = function (t) { Ph.prototype.copy.call(this, t), this.points = []; for (var e = 0, n = t.points.length; e < n; e++) { var i = t.points[e]; this.points.push(i.clone()) } return this }, Yh.prototype.toJSON = function () { var t = Ph.prototype.toJSON.call(this); t.points = []; for (var e = 0, n = this.points.length; e < n; e++) { var i = this.points[e]; t.points.push(i.toArray()) } return t }, Yh.prototype.fromJSON = function (t) { Ph.prototype.fromJSON.call(this, t), this.points = []; for (var e = 0, n = t.points.length; e < n; e++) { var i = t.points[e]; this.points.push((new ke).fromArray(i)) } return this }; var Jh = Object.freeze({ ArcCurve: Oh, CatmullRomCurve3: Uh, CubicBezierCurve: Vh, CubicBezierCurve3: kh, EllipseCurve: Ch, LineCurve: jh, LineCurve3: Wh, QuadraticBezierCurve: qh, QuadraticBezierCurve3: Xh, SplineCurve: Yh }); function Zh() { Ph.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } function Qh(t) { Zh.call(this), this.type = "Path", this.currentPoint = new ke, t && this.setFromPoints(t) } function Kh(t) { Qh.call(this, t), this.uuid = Ve.generateUUID(), this.type = "Shape", this.holes = [] } function $h(t, e) { Si.call(this), this.type = "Light", this.color = new Xn(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0 } function tl(t, e, n) { $h.call(this, t, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(Si.DefaultUp), this.updateMatrix(), this.groundColor = new Xn(e) } function el(t) { this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new ke(512, 512), this.map = null, this.matrix = new je } function nl() { el.call(this, new zo(50, 1, .5, 500)) } function il(t, e, n, i, r, a) { $h.call(this, t, e), this.type = "SpotLight", this.position.copy(Si.DefaultUp), this.updateMatrix(), this.target = new Si, Object.defineProperty(this, "power", { get: function () { return this.intensity * Math.PI }, set: function (t) { this.intensity = t / Math.PI } }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== i ? i : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new nl } function rl(t, e, n, i) { $h.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", { get: function () { return 4 * this.intensity * Math.PI }, set: function (t) { this.intensity = t / (4 * Math.PI) } }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== i ? i : 1, this.shadow = new el(new zo(90, 1, .5, 500)) } function al(t, e, n, i, r, a) { Bo.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== i ? i : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix() } function ol() { el.call(this, new al(-5, 5, 5, -5, .5, 500)) } function sl(t, e) { $h.call(this, t, e), this.type = "DirectionalLight", this.position.copy(Si.DefaultUp), this.updateMatrix(), this.target = new Si, this.shadow = new ol } function cl(t, e) { $h.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0 } function hl(t, e, n, i) { $h.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== i ? i : 10 } function ll(t) { this.manager = void 0 !== t ? t : wh, this.textures = {} } Zh.prototype = Object.assign(Object.create(Ph.prototype), { constructor: Zh, add: function (t) { this.curves.push(t) }, closePath: function () { var t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1); t.equals(e) || this.curves.push(new jh(e, t)) }, getPoint: function (t) { for (var e = t * this.getLength(), n = this.getCurveLengths(), i = 0; i < n.length;) { if (n[i] >= e) { var r = n[i] - e, a = this.curves[i], o = a.getLength(), o = 0 === o ? 0 : 1 - r / o; return a.getPointAt(o) } i++ } return null }, getLength: function () { var t = this.getCurveLengths(); return t[t.length - 1] }, updateArcLengths: function () { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() }, getCurveLengths: function () { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; for (var t = [], e = 0, n = 0, i = this.curves.length; n < i; n++)e += this.curves[n].getLength(), t.push(e); return this.cacheLengths = t }, getSpacedPoints: function (t) { void 0 === t && (t = 40); for (var e = [], n = 0; n <= t; n++)e.push(this.getPoint(n / t)); return this.autoClose && e.push(e[0]), e }, getPoints: function (t) { t = t || 12; for (var e, n = [], i = 0, r = this.curves; i < r.length; i++)for (var a = r[i], o = a && a.isEllipseCurve ? 2 * t : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? t * a.points.length : t, s = a.getPoints(o), c = 0; c < s.length; c++) { var h = s[c]; e && e.equals(h) || (n.push(h), e = h) } return this.autoClose && 1 < n.length && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n }, copy: function (t) { Ph.prototype.copy.call(this, t), this.curves = []; for (var e = 0, n = t.curves.length; e < n; e++) { var i = t.curves[e]; this.curves.push(i.clone()) } return this.autoClose = t.autoClose, this }, toJSON: function () { var t = Ph.prototype.toJSON.call(this); t.autoClose = this.autoClose, t.curves = []; for (var e = 0, n = this.curves.length; e < n; e++) { var i = this.curves[e]; t.curves.push(i.toJSON()) } return t }, fromJSON: function (t) { Ph.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = []; for (var e = 0, n = t.curves.length; e < n; e++) { var i = t.curves[e]; this.curves.push((new Jh[i.type]).fromJSON(i)) } return this } }), Qh.prototype = Object.assign(Object.create(Zh.prototype), { constructor: Qh, setFromPoints: function (t) { this.moveTo(t[0].x, t[0].y); for (var e = 1, n = t.length; e < n; e++)this.lineTo(t[e].x, t[e].y) }, moveTo: function (t, e) { this.currentPoint.set(t, e) }, lineTo: function (t, e) { var n = new jh(this.currentPoint.clone(), new ke(t, e)); this.curves.push(n), this.currentPoint.set(t, e) }, quadraticCurveTo: function (t, e, n, i) { e = new qh(this.currentPoint.clone(), new ke(t, e), new ke(n, i)); this.curves.push(e), this.currentPoint.set(n, i) }, bezierCurveTo: function (t, e, n, i, r, a) { i = new Vh(this.currentPoint.clone(), new ke(t, e), new ke(n, i), new ke(r, a)); this.curves.push(i), this.currentPoint.set(r, a) }, splineThru: function (t) { var e = new Yh([this.currentPoint.clone()].concat(t)); this.curves.push(e), this.currentPoint.copy(t[t.length - 1]) }, arc: function (t, e, n, i, r, a) { var o = this.currentPoint.x, s = this.currentPoint.y; this.absarc(t + o, e + s, n, i, r, a) }, absarc: function (t, e, n, i, r, a) { this.absellipse(t, e, n, n, i, r, a) }, ellipse: function (t, e, n, i, r, a, o, s) { var c = this.currentPoint.x, h = this.currentPoint.y; this.absellipse(t + c, e + h, n, i, r, a, o, s) }, absellipse: function (t, e, n, i, r, a, o, s) { o = new Ch(t, e, n, i, r, a, o, s); 0 < this.curves.length && ((s = o.getPoint(0)).equals(this.currentPoint) || this.lineTo(s.x, s.y)), this.curves.push(o); o = o.getPoint(1); this.currentPoint.copy(o) }, copy: function (t) { return Zh.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this }, toJSON: function () { var t = Zh.prototype.toJSON.call(this); return t.currentPoint = this.currentPoint.toArray(), t }, fromJSON: function (t) { return Zh.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this } }), Kh.prototype = Object.assign(Object.create(Qh.prototype), { constructor: Kh, getPointsHoles: function (t) { for (var e = [], n = 0, i = this.holes.length; n < i; n++)e[n] = this.holes[n].getPoints(t); return e }, extractPoints: function (t) { return { shape: this.getPoints(t), holes: this.getPointsHoles(t) } }, copy: function (t) { Qh.prototype.copy.call(this, t), this.holes = []; for (var e = 0, n = t.holes.length; e < n; e++) { var i = t.holes[e]; this.holes.push(i.clone()) } return this }, toJSON: function () { var t = Qh.prototype.toJSON.call(this); t.uuid = this.uuid, t.holes = []; for (var e = 0, n = this.holes.length; e < n; e++) { var i = this.holes[e]; t.holes.push(i.toJSON()) } return t }, fromJSON: function (t) { Qh.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = []; for (var e = 0, n = t.holes.length; e < n; e++) { var i = t.holes[e]; this.holes.push((new Qh).fromJSON(i)) } return this } }), $h.prototype = Object.assign(Object.create(Si.prototype), { constructor: $h, isLight: !0, copy: function (t) { return Si.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this }, toJSON: function (t) { t = Si.prototype.toJSON.call(this, t); return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t } }), tl.prototype = Object.assign(Object.create($h.prototype), { constructor: tl, isHemisphereLight: !0, copy: function (t) { return $h.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this } }), Object.assign(el.prototype, { copy: function (t) { return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this }, clone: function () { return (new this.constructor).copy(this) }, toJSON: function () { var t = {}; return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t } }), nl.prototype = Object.assign(Object.create(el.prototype), { constructor: nl, isSpotLightShadow: !0, update: function (t) { var e = this.camera, n = 2 * Ve.RAD2DEG * t.angle, i = this.mapSize.width / this.mapSize.height, t = t.distance || e.far; n === e.fov && i === e.aspect && t === e.far || (e.fov = n, e.aspect = i, e.far = t, e.updateProjectionMatrix()) } }), il.prototype = Object.assign(Object.create($h.prototype), { constructor: il, isSpotLight: !0, copy: function (t) { return $h.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } }), rl.prototype = Object.assign(Object.create($h.prototype), { constructor: rl, isPointLight: !0, copy: function (t) { return $h.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this } }), al.prototype = Object.assign(Object.create(Bo.prototype), { constructor: al, isOrthographicCamera: !0, copy: function (t, e) { return Bo.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this }, setViewOffset: function (t, e, n, i, r, a) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix() }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function () { var t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2, r = n - t, a = n + t, o = i + e, s = i - e; null !== this.view && this.view.enabled && (n = this.zoom / (this.view.width / this.view.fullWidth), t = this.zoom / (this.view.height / this.view.fullHeight), i = (this.right - this.left) / this.view.width, e = (this.top - this.bottom) / this.view.height, a = (r += i * (this.view.offsetX / n)) + i * (this.view.width / n), s = (o -= e * (this.view.offsetY / t)) - e * (this.view.height / t)), this.projectionMatrix.makeOrthographic(r, a, o, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix) }, toJSON: function (t) { t = Si.prototype.toJSON.call(this, t); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t } }), ol.prototype = Object.assign(Object.create(el.prototype), { constructor: ol }), sl.prototype = Object.assign(Object.create($h.prototype), { constructor: sl, isDirectionalLight: !0, copy: function (t) { return $h.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } }), cl.prototype = Object.assign(Object.create($h.prototype), { constructor: cl, isAmbientLight: !0 }), hl.prototype = Object.assign(Object.create($h.prototype), { constructor: hl, isRectAreaLight: !0, copy: function (t) { return $h.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this }, toJSON: function (t) { t = $h.prototype.toJSON.call(this, t); return t.object.width = this.width, t.object.height = this.height, t } }), Object.assign(ll.prototype, { load: function (t, e, n, i) { var r = this, a = new Mh(r.manager); a.setPath(r.path), a.load(t, function (t) { e(r.parse(JSON.parse(t))) }, n, i) }, parse: function (t) { var e = this.textures; function n(t) { return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t] } var i, r = new ih[t.type]; if (void 0 !== t.uuid && (r.uuid = t.uuid), void 0 !== t.name && (r.name = t.name), void 0 !== t.color && r.color.setHex(t.color), void 0 !== t.roughness && (r.roughness = t.roughness), void 0 !== t.metalness && (r.metalness = t.metalness), void 0 !== t.emissive && r.emissive.setHex(t.emissive), void 0 !== t.specular && r.specular.setHex(t.specular), void 0 !== t.shininess && (r.shininess = t.shininess), void 0 !== t.clearCoat && (r.clearCoat = t.clearCoat), void 0 !== t.clearCoatRoughness && (r.clearCoatRoughness = t.clearCoatRoughness), void 0 !== t.vertexColors && (r.vertexColors = t.vertexColors), void 0 !== t.fog && (r.fog = t.fog), void 0 !== t.flatShading && (r.flatShading = t.flatShading), void 0 !== t.blending && (r.blending = t.blending), void 0 !== t.combine && (r.combine = t.combine), void 0 !== t.side && (r.side = t.side), void 0 !== t.opacity && (r.opacity = t.opacity), void 0 !== t.transparent && (r.transparent = t.transparent), void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest), void 0 !== t.depthTest && (r.depthTest = t.depthTest), void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite), void 0 !== t.wireframe && (r.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (r.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (r.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (r.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (r.rotation = t.rotation), 1 !== t.linewidth && (r.linewidth = t.linewidth), void 0 !== t.dashSize && (r.dashSize = t.dashSize), void 0 !== t.gapSize && (r.gapSize = t.gapSize), void 0 !== t.scale && (r.scale = t.scale), void 0 !== t.polygonOffset && (r.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (r.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (r.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (r.skinning = t.skinning), void 0 !== t.morphTargets && (r.morphTargets = t.morphTargets), void 0 !== t.dithering && (r.dithering = t.dithering), void 0 !== t.visible && (r.visible = t.visible), void 0 !== t.userData && (r.userData = t.userData), void 0 !== t.uniforms) for (var a in t.uniforms) { var o = t.uniforms[a]; switch (r.uniforms[a] = {}, o.type) { case "t": r.uniforms[a].value = n(o.value); break; case "c": r.uniforms[a].value = (new Xn).setHex(o.value); break; case "v2": r.uniforms[a].value = (new ke).fromArray(o.value); break; case "v3": r.uniforms[a].value = (new qe).fromArray(o.value); break; case "v4": r.uniforms[a].value = (new Ln).fromArray(o.value); break; case "m3": r.uniforms[a].value = (new Xe).fromArray(o.value); case "m4": r.uniforms[a].value = (new je).fromArray(o.value); break; default: r.uniforms[a].value = o.value } } if (void 0 !== t.defines && (r.defines = t.defines), void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (r.fragmentShader = t.fragmentShader), void 0 !== t.extensions) for (var s in t.extensions) r.extensions[s] = t.extensions[s]; return void 0 !== t.shading && (r.flatShading = 1 === t.shading), void 0 !== t.size && (r.size = t.size), void 0 !== t.sizeAttenuation && (r.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (r.map = n(t.map)), void 0 !== t.alphaMap && (r.alphaMap = n(t.alphaMap), r.transparent = !0), void 0 !== t.bumpMap && (r.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale), void 0 !== t.normalMap && (r.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (r.normalMapType = t.normalMapType), void 0 !== t.normalScale && (i = t.normalScale, !1 === Array.isArray(i) && (i = [i, i]), r.normalScale = (new ke).fromArray(i)), void 0 !== t.displacementMap && (r.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (r.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (r.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (r.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (r.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (r.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (r.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (r.specularMap = n(t.specularMap)), void 0 !== t.envMap && (r.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (r.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity), void 0 !== t.lightMap && (r.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (r.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (r.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (r.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (r.gradientMap = n(t.gradientMap)), r }, setPath: function (t) { return this.path = t, this }, setTextures: function (t) { return this.textures = t, this } }); var ul = { decodeText: function (t) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t); for (var e = "", n = 0, i = t.length; n < i; n++)e += String.fromCharCode(t[n]); return decodeURIComponent(escape(e)) }, extractUrlBase: function (t) { var e = t.lastIndexOf("/"); return -1 === e ? "./" : t.substr(0, e + 1) } }; function pl(t) { this.manager = void 0 !== t ? t : wh } Object.assign(pl.prototype, { load: function (t, e, n, i) { var r = this, a = new Mh(r.manager); a.setPath(r.path), a.load(t, function (t) { e(r.parse(JSON.parse(t))) }, n, i) }, parse: function (t) { var e = new rr, n = t.data.index; void 0 !== n && (p = new dl[n.type](n.array), e.setIndex(new Ni(p, 1))); var i = t.data.attributes; for (s in i) { var r = i[s], a = new Ni(p = new dl[r.type](r.array), r.itemSize, r.normalized); void 0 !== r.name && (a.name = r.name), e.addAttribute(s, a) } var o = t.data.morphAttributes; if (o) for (var s in o) { for (var c = o[s], h = [], l = 0, u = c.length; l < u; l++) { var p, r = c[l], a = new Ni(p = new dl[r.type](r.array), r.itemSize, r.normalized); void 0 !== r.name && (a.name = r.name), h.push(a) } e.morphAttributes[s] = h } var d = t.data.groups || t.data.drawcalls || t.data.offsets; if (void 0 !== d) for (var l = 0, f = d.length; l !== f; ++l) { var m = d[l]; e.addGroup(m.start, m.count, m.materialIndex) } var g = t.data.boundingSphere; return void 0 !== g && (n = new qe, void 0 !== g.center && n.fromArray(g.center), e.boundingSphere = new Bn(n, g.radius)), t.name && (e.name = t.name), t.userData && (e.userData = t.userData), e }, setPath: function (t) { return this.path = t, this } }); var dl = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; function fl(t) { this.manager = void 0 !== t ? t : wh, this.resourcePath = "" } Object.assign(fl.prototype, { crossOrigin: "anonymous", load: function (i, r, t, a) { var o = this, e = void 0 === this.path ? ul.extractUrlBase(i) : this.path; this.resourcePath = this.resourcePath || e; e = new Mh(o.manager); e.setPath(this.path), e.load(i, function (t) { var e = null; try { e = JSON.parse(t) } catch (t) { return void 0 !== a && a(t), void console.error("THREE:ObjectLoader: Can't parse " + i + ".", t.message) } var n = e.metadata; void 0 !== n && void 0 !== n.type && "geometry" !== n.type.toLowerCase() ? o.parse(e, r) : console.error("THREE.ObjectLoader: Can't load " + i) }, t, a) }, setPath: function (t) { return this.path = t, this }, setResourcePath: function (t) { return this.resourcePath = t, this }, setCrossOrigin: function (t) { return this.crossOrigin = t, this }, parse: function (t, e) { var n = this.parseShape(t.shapes), i = this.parseGeometries(t.geometries, n), n = this.parseImages(t.images, function () { void 0 !== e && e(r) }), n = this.parseTextures(t.textures, n), n = this.parseMaterials(t.materials, n), r = this.parseObject(t.object, i, n); return t.animations && (r.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(r), r }, parseShape: function (t) { var e = {}; if (void 0 !== t) for (var n = 0, i = t.length; n < i; n++) { var r = (new Kh).fromJSON(t[n]); e[r.uuid] = r } return e }, parseGeometries: function (t, e) { var n = {}; if (void 0 !== t) for (var i = new pl, r = 0, a = t.length; r < a; r++) { var o, s = t[r]; switch (s.type) { case "PlaneGeometry": case "PlaneBufferGeometry": o = new qc[s.type](s.width, s.height, s.widthSegments, s.heightSegments); break; case "BoxGeometry": case "BoxBufferGeometry": case "CubeGeometry": o = new qc[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments); break; case "CircleGeometry": case "CircleBufferGeometry": o = new qc[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength); break; case "CylinderGeometry": case "CylinderBufferGeometry": o = new qc[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength); break; case "ConeGeometry": case "ConeBufferGeometry": o = new qc[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength); break; case "SphereGeometry": case "SphereBufferGeometry": o = new qc[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength); break; case "DodecahedronGeometry": case "DodecahedronBufferGeometry": case "IcosahedronGeometry": case "IcosahedronBufferGeometry": case "OctahedronGeometry": case "OctahedronBufferGeometry": case "TetrahedronGeometry": case "TetrahedronBufferGeometry": o = new qc[s.type](s.radius, s.detail); break; case "RingGeometry": case "RingBufferGeometry": o = new qc[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength); break; case "TorusGeometry": case "TorusBufferGeometry": o = new qc[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc); break; case "TorusKnotGeometry": case "TorusKnotBufferGeometry": o = new qc[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q); break; case "TubeGeometry": case "TubeBufferGeometry": o = new qc[s.type]((new Jh[s.path.type]).fromJSON(s.path), s.tubularSegments, s.radius, s.radialSegments, s.closed); break; case "LatheGeometry": case "LatheBufferGeometry": o = new qc[s.type](s.points, s.segments, s.phiStart, s.phiLength); break; case "PolyhedronGeometry": case "PolyhedronBufferGeometry": o = new qc[s.type](s.vertices, s.indices, s.radius, s.details); break; case "ShapeGeometry": case "ShapeBufferGeometry": for (var c = [], h = 0, l = s.shapes.length; h < l; h++) { var u = e[s.shapes[h]]; c.push(u) } o = new qc[s.type](c, s.curveSegments); break; case "ExtrudeGeometry": case "ExtrudeBufferGeometry": for (c = [], h = 0, l = s.shapes.length; h < l; h++) { u = e[s.shapes[h]]; c.push(u) } var p = s.options.extrudePath; void 0 !== p && (s.options.extrudePath = (new Jh[p.type]).fromJSON(p)), o = new qc[s.type](c, s.options); break; case "BufferGeometry": o = i.parse(s); break; case "Geometry": "THREE" in window && "LegacyJSONLoader" in THREE ? o = (new THREE.LegacyJSONLoader).parse(s, this.resourcePath).geometry : console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".'); break; default: console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"'); continue }o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), !0 === o.isBufferGeometry && void 0 !== s.userData && (o.userData = s.userData), n[s.uuid] = o } return n }, parseMaterials: function (t, e) { var n = {}, i = {}; if (void 0 !== t) { var r = new ll; r.setTextures(e); for (var a = 0, o = t.length; a < o; a++) { var s = t[a]; if ("MultiMaterial" === s.type) { for (var c = [], h = 0; h < s.materials.length; h++) { var l = s.materials[h]; void 0 === n[l.uuid] && (n[l.uuid] = r.parse(l)), c.push(n[l.uuid]) } i[s.uuid] = c } else void 0 === n[s.uuid] && (n[s.uuid] = r.parse(s)), i[s.uuid] = n[s.uuid] } } return i }, parseAnimations: function (t) { for (var e = [], n = 0; n < t.length; n++) { var i = t[n], r = vh.parse(i); void 0 !== i.uuid && (r.uuid = i.uuid), e.push(r) } return e }, parseImages: function (t, e) { var n = this, i = {}; function r(t) { return n.manager.itemStart(t), a.load(t, function () { n.manager.itemEnd(t) }, void 0, function () { n.manager.itemError(t), n.manager.itemEnd(t) }) } if (void 0 !== t && 0 < t.length) { var a = new Ah(new bh(e)); a.setCrossOrigin(this.crossOrigin); for (var o = 0, s = t.length; o < s; o++) { var c = t[o], h = c.url; if (Array.isArray(h)) { i[c.uuid] = []; for (var l = 0, u = h.length; l < u; l++) { var p = h[l], d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : n.resourcePath + p; i[c.uuid].push(r(d)) } } else { d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : n.resourcePath + c.url; i[c.uuid] = r(d) } } } return i }, parseTextures: function (t, e) { function n(t, e) { return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t]) } var i = {}; if (void 0 !== t) for (var r = 0, a = t.length; r < a; r++) { var o, s = t[r]; void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image), (o = new (Array.isArray(e[s.image]) ? ga : An)(e[s.image])).needsUpdate = !0, o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), void 0 !== s.mapping && (o.mapping = n(s.mapping, bl)), void 0 !== s.offset && o.offset.fromArray(s.offset), void 0 !== s.repeat && o.repeat.fromArray(s.repeat), void 0 !== s.center && o.center.fromArray(s.center), void 0 !== s.rotation && (o.rotation = s.rotation), void 0 !== s.wrap && (o.wrapS = n(s.wrap[0], wl), o.wrapT = n(s.wrap[1], wl)), void 0 !== s.format && (o.format = s.format), void 0 !== s.type && (o.type = s.type), void 0 !== s.encoding && (o.encoding = s.encoding), void 0 !== s.minFilter && (o.minFilter = n(s.minFilter, _l)), void 0 !== s.magFilter && (o.magFilter = n(s.magFilter, _l)), void 0 !== s.anisotropy && (o.anisotropy = s.anisotropy), void 0 !== s.flipY && (o.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (o.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (o.unpackAlignment = s.unpackAlignment), i[s.uuid] = o } return i }, parseObject: function (t, e, a) { function n(t) { return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t] } function i(t) { if (void 0 !== t) { if (Array.isArray(t)) { for (var e = [], n = 0, i = t.length; n < i; n++) { var r = t[n]; void 0 === a[r] && console.warn("THREE.ObjectLoader: Undefined material", r), e.push(a[r]) } return e } return void 0 === a[t] && console.warn("THREE.ObjectLoader: Undefined material", t), a[t] } } switch (t.type) { case "Scene": s = new ws, void 0 !== t.background && Number.isInteger(t.background) && (s.background = new Xn(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? s.fog = new bs(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (s.fog = new xs(t.fog.color, t.fog.density))); break; case "PerspectiveCamera": s = new zo(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (s.focus = t.focus), void 0 !== t.zoom && (s.zoom = t.zoom), void 0 !== t.filmGauge && (s.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (s.filmOffset = t.filmOffset), void 0 !== t.view && (s.view = Object.assign({}, t.view)); break; case "OrthographicCamera": s = new al(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (s.zoom = t.zoom), void 0 !== t.view && (s.view = Object.assign({}, t.view)); break; case "AmbientLight": s = new cl(t.color, t.intensity); break; case "DirectionalLight": s = new sl(t.color, t.intensity); break; case "PointLight": s = new rl(t.color, t.intensity, t.distance, t.decay); break; case "RectAreaLight": s = new hl(t.color, t.intensity, t.width, t.height); break; case "SpotLight": s = new il(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay); break; case "HemisphereLight": s = new tl(t.color, t.groundColor, t.intensity); break; case "SkinnedMesh": console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."); case "Mesh": var r = n(t.geometry), o = i(t.material), s = new (r.bones && 0 < r.bones.length ? Ls : na)(r, o); void 0 !== t.drawMode && s.setDrawMode(t.drawMode); break; case "LOD": s = new As; break; case "Line": s = new Os(n(t.geometry), i(t.material), t.mode); break; case "LineLoop": s = new Ds(n(t.geometry), i(t.material)); break; case "LineSegments": s = new Is(n(t.geometry), i(t.material)); break; case "PointCloud": case "Points": s = new Bs(n(t.geometry), i(t.material)); break; case "Sprite": s = new Ss(i(t.material)); break; case "Group": s = new No; break; default: s = new Si }if (s.uuid = t.uuid, void 0 !== t.name && (s.name = t.name), void 0 !== t.matrix ? (s.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (s.matrixAutoUpdate = t.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (void 0 !== t.position && s.position.fromArray(t.position), void 0 !== t.rotation && s.rotation.fromArray(t.rotation), void 0 !== t.quaternion && s.quaternion.fromArray(t.quaternion), void 0 !== t.scale && s.scale.fromArray(t.scale)), void 0 !== t.castShadow && (s.castShadow = t.castShadow), void 0 !== t.receiveShadow && (s.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (s.shadow.bias = t.shadow.bias), void 0 !== t.shadow.radius && (s.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && s.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (s.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (s.visible = t.visible), void 0 !== t.frustumCulled && (s.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (s.renderOrder = t.renderOrder), void 0 !== t.userData && (s.userData = t.userData), void 0 !== t.layers && (s.layers.mask = t.layers), void 0 !== t.children) for (var c = t.children, h = 0; h < c.length; h++)s.add(this.parseObject(c[h], e, a)); if ("LOD" === t.type) for (var l = t.levels, u = 0; u < l.length; u++) { var p = l[u], d = s.getObjectByProperty("uuid", p.object); void 0 !== d && s.addLevel(d, p.distance) } return s } }); var ml, gl, vl, yl, xl, bl = { UVMapping: 300, CubeReflectionMapping: vt, CubeRefractionMapping: yt, EquirectangularReflectionMapping: xt, EquirectangularRefractionMapping: bt, SphericalReflectionMapping: wt, CubeUVReflectionMapping: Et, CubeUVRefractionMapping: St }, wl = { RepeatWrapping: Tt, ClampToEdgeWrapping: At, MirroredRepeatWrapping: Lt }, _l = { NearestFilter: Rt, NearestMipMapNearestFilter: Pt, NearestMipMapLinearFilter: Ct, LinearFilter: Ot, LinearMipMapNearestFilter: It, LinearMipMapLinearFilter: Dt }; function Ml(t) { "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== t ? t : wh, this.options = void 0 } function El() { this.type = "ShapePath", this.color = new Xn, this.subPaths = [], this.currentPath = null } function Sl(t) { this.type = "Font", this.data = t } function Tl(t) { this.manager = void 0 !== t ? t : wh } function Al() { } Ml.prototype = { constructor: Ml, setOptions: function (t) { return this.options = t, this }, load: function (e, n, t, i) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); var r = this, a = xh.get(e); if (void 0 !== a) return r.manager.itemStart(e), setTimeout(function () { n && n(a), r.manager.itemEnd(e) }, 0), a; fetch(e).then(function (t) { return t.blob() }).then(function (t) { return createImageBitmap(t, r.options) }).then(function (t) { xh.add(e, t), n && n(t), r.manager.itemEnd(e) }).catch(function (t) { i && i(t), r.manager.itemError(e), r.manager.itemEnd(e) }), r.manager.itemStart(e) }, setCrossOrigin: function () { return this }, setPath: function (t) { return this.path = t, this } }, Object.assign(El.prototype, { moveTo: function (t, e) { this.currentPath = new Qh, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e) }, lineTo: function (t, e) { this.currentPath.lineTo(t, e) }, quadraticCurveTo: function (t, e, n, i) { this.currentPath.quadraticCurveTo(t, e, n, i) }, bezierCurveTo: function (t, e, n, i, r, a) { this.currentPath.bezierCurveTo(t, e, n, i, r, a) }, splineThru: function (t) { this.currentPath.splineThru(t) }, toShapes: function (t, e) { function n(t) { for (var e = [], n = 0, i = t.length; n < i; n++) { var r = t[n], a = new Kh; a.curves = r.curves, e.push(a) } return e } var i = wc.isClockWise, r = this.subPaths; if (0 === r.length) return []; if (!0 === e) return n(r); var a, o, s, c = []; if (1 === r.length) return o = r[0], (s = new Kh).curves = o.curves, c.push(s), c; var h, l = !i(r[0].getPoints()), l = t ? !l : l, u = [], p = [], d = [], f = 0; p[f] = void 0, d[f] = []; for (var m, g = 0, v = r.length; g < v; g++)a = i(h = (o = r[g]).getPoints()), (a = t ? !a : a) ? (!l && p[f] && f++, p[f] = { s: new Kh, p: h }, p[f].s.curves = o.curves, l && f++, d[f] = []) : d[f].push({ h: o, p: h[0] }); if (!p[0]) return n(r); if (1 < p.length) { for (var y = !1, x = [], b = 0, w = p.length; b < w; b++)u[b] = []; for (b = 0, w = p.length; b < w; b++)for (var _ = d[b], M = 0; M < _.length; M++) { for (var E = _[M], S = !0, T = 0; T < p.length; T++)!function (t, e) { for (var n = e.length, i = !1, r = n - 1, a = 0; a < n; r = a++) { var o = e[r], s = e[a], c = s.x - o.x, h = s.y - o.y; if (Math.abs(h) > Number.EPSILON) { if (h < 0 && (o = e[a], c = -c, s = e[r], h = -h), !(t.y < o.y || t.y > s.y)) if (t.y === o.y) { if (t.x === o.x) return 1 } else { c = h * (t.x - o.x) - c * (t.y - o.y); if (0 == c) return 1; c < 0 || (i = !i) } } else if (t.y === o.y && (s.x <= t.x && t.x <= o.x || o.x <= t.x && t.x <= s.x)) return 1 } return i }(E.p, p[T].p) || (b !== T && x.push({ froms: b, tos: T, hole: M }), S ? (S = !1, u[T].push(E)) : y = !0); S && u[b].push(E) } 0 < x.length && (y || (d = u)) } for (var g = 0, A = p.length; g < A; g++) { s = p[g].s, c.push(s); for (var L = 0, R = (m = d[g]).length; L < R; L++)s.holes.push(m[L].h) } return c } }), Object.assign(Sl.prototype, { isFont: !0, generateShapes: function (t, e) { void 0 === e && (e = 100); for (var n = [], i = function (t, e, n) { for (var i = Array.from ? Array.from(t) : String(t).split(""), r = e / n.resolution, a = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r, o = [], s = 0, c = 0, h = 0; h < i.length; h++) { var l = i[h]; "\n" === l ? (s = 0, c -= a) : (l = function (t, e, n, i, r) { r = r.glyphs[t] || r.glyphs["?"]; if (!r) return; var a, o, s, c, h, l, u, p, d = new El; if (r.o) for (var f = r._cachedOutline || (r._cachedOutline = r.o.split(" ")), m = 0, g = f.length; m < g;)switch (f[m++]) { case "m": a = f[m++] * e + n, o = f[m++] * e + i, d.moveTo(a, o); break; case "l": a = f[m++] * e + n, o = f[m++] * e + i, d.lineTo(a, o); break; case "q": s = f[m++] * e + n, c = f[m++] * e + i, h = f[m++] * e + n, l = f[m++] * e + i, d.quadraticCurveTo(h, l, s, c); break; case "b": s = f[m++] * e + n, c = f[m++] * e + i, h = f[m++] * e + n, l = f[m++] * e + i, u = f[m++] * e + n, p = f[m++] * e + i, d.bezierCurveTo(h, l, u, p, s, c) }return { offsetX: r.ha * e, path: d } }(l, r, s, c, n), s += l.offsetX, o.push(l.path)) } return o }(t, e, this.data), r = 0, a = i.length; r < a; r++)Array.prototype.push.apply(n, i[r].toShapes()); return n } }), Object.assign(Tl.prototype, { load: function (t, i, e, n) { var r = this, a = new Mh(this.manager); a.setPath(this.path), a.load(t, function (e) { var n; try { n = JSON.parse(e) } catch (t) { console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(e.substring(65, e.length - 2)) } var t = r.parse(n); i && i(t) }, e, n) }, parse: function (t) { return new Sl(t) }, setPath: function (t) { return this.path = t, this } }), Al.Handlers = { handlers: [], add: function (t, e) { this.handlers.push(t, e) }, get: function (t) { for (var e = this.handlers, n = 0, i = e.length; n < i; n += 2) { var r = e[n], a = e[n + 1]; if (r.test(t)) return a } return null } }, Object.assign(Al.prototype, { crossOrigin: "anonymous", onLoadStart: function () { }, onLoadProgress: function () { }, onLoadComplete: function () { }, initMaterials: function (t, e, n) { for (var i = [], r = 0; r < t.length; ++r)i[r] = this.createMaterial(t[r], e, n); return i }, createMaterial: (ml = { NoBlending: J, NormalBlending: Z, AdditiveBlending: Q, SubtractiveBlending: K, MultiplyBlending: $, CustomBlending: tt }, gl = new Xn, vl = new Rh, yl = new ll, function (t, o, s) { var c = {}; function e(t, e, n, i, r) { var a = o + t, t = Al.Handlers.get(a), a = null !== t ? t.load(a) : (vl.setCrossOrigin(s), vl.load(a)); void 0 !== e && (a.repeat.fromArray(e), 1 !== e[0] && (a.wrapS = Tt), 1 !== e[1] && (a.wrapT = Tt)), void 0 !== n && a.offset.fromArray(n), void 0 !== i && ("repeat" === i[0] && (a.wrapS = Tt), "mirror" === i[0] && (a.wrapS = Lt), "repeat" === i[1] && (a.wrapT = Tt), "mirror" === i[1] && (a.wrapT = Lt)), void 0 !== r && (a.anisotropy = r); r = Ve.generateUUID(); return c[r] = a, r } var n, i = { uuid: Ve.generateUUID(), type: "MeshLambertMaterial" }; for (n in t) { var r = t[n]; switch (n) { case "DbgColor": case "DbgIndex": case "opticalDensity": case "illumination": break; case "DbgName": i.name = r; break; case "blending": i.blending = ml[r]; break; case "colorAmbient": case "mapAmbient": console.warn("THREE.Loader.createMaterial:", n, "is no longer supported."); break; case "colorDiffuse": i.color = gl.fromArray(r).getHex(); break; case "colorSpecular": i.specular = gl.fromArray(r).getHex(); break; case "colorEmissive": i.emissive = gl.fromArray(r).getHex(); break; case "specularCoef": i.shininess = r; break; case "shading": "basic" === r.toLowerCase() && (i.type = "MeshBasicMaterial"), "phong" === r.toLowerCase() && (i.type = "MeshPhongMaterial"), "standard" === r.toLowerCase() && (i.type = "MeshStandardMaterial"); break; case "mapDiffuse": i.map = e(r, t.mapDiffuseRepeat, t.mapDiffuseOffset, t.mapDiffuseWrap, t.mapDiffuseAnisotropy); break; case "mapDiffuseRepeat": case "mapDiffuseOffset": case "mapDiffuseWrap": case "mapDiffuseAnisotropy": break; case "mapEmissive": i.emissiveMap = e(r, t.mapEmissiveRepeat, t.mapEmissiveOffset, t.mapEmissiveWrap, t.mapEmissiveAnisotropy); break; case "mapEmissiveRepeat": case "mapEmissiveOffset": case "mapEmissiveWrap": case "mapEmissiveAnisotropy": break; case "mapLight": i.lightMap = e(r, t.mapLightRepeat, t.mapLightOffset, t.mapLightWrap, t.mapLightAnisotropy); break; case "mapLightRepeat": case "mapLightOffset": case "mapLightWrap": case "mapLightAnisotropy": break; case "mapAO": i.aoMap = e(r, t.mapAORepeat, t.mapAOOffset, t.mapAOWrap, t.mapAOAnisotropy); break; case "mapAORepeat": case "mapAOOffset": case "mapAOWrap": case "mapAOAnisotropy": break; case "mapBump": i.bumpMap = e(r, t.mapBumpRepeat, t.mapBumpOffset, t.mapBumpWrap, t.mapBumpAnisotropy); break; case "mapBumpScale": i.bumpScale = r; break; case "mapBumpRepeat": case "mapBumpOffset": case "mapBumpWrap": case "mapBumpAnisotropy": break; case "mapNormal": i.normalMap = e(r, t.mapNormalRepeat, t.mapNormalOffset, t.mapNormalWrap, t.mapNormalAnisotropy); break; case "mapNormalFactor": i.normalScale = r; break; case "mapNormalRepeat": case "mapNormalOffset": case "mapNormalWrap": case "mapNormalAnisotropy": break; case "mapSpecular": i.specularMap = e(r, t.mapSpecularRepeat, t.mapSpecularOffset, t.mapSpecularWrap, t.mapSpecularAnisotropy); break; case "mapSpecularRepeat": case "mapSpecularOffset": case "mapSpecularWrap": case "mapSpecularAnisotropy": break; case "mapMetalness": i.metalnessMap = e(r, t.mapMetalnessRepeat, t.mapMetalnessOffset, t.mapMetalnessWrap, t.mapMetalnessAnisotropy); break; case "mapMetalnessRepeat": case "mapMetalnessOffset": case "mapMetalnessWrap": case "mapMetalnessAnisotropy": break; case "mapRoughness": i.roughnessMap = e(r, t.mapRoughnessRepeat, t.mapRoughnessOffset, t.mapRoughnessWrap, t.mapRoughnessAnisotropy); break; case "mapRoughnessRepeat": case "mapRoughnessOffset": case "mapRoughnessWrap": case "mapRoughnessAnisotropy": break; case "mapAlpha": i.alphaMap = e(r, t.mapAlphaRepeat, t.mapAlphaOffset, t.mapAlphaWrap, t.mapAlphaAnisotropy); break; case "mapAlphaRepeat": case "mapAlphaOffset": case "mapAlphaWrap": case "mapAlphaAnisotropy": break; case "flipSided": i.side = _t; break; case "doubleSided": i.side = Y; break; case "transparency": console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), i.opacity = r; break; case "depthTest": case "depthWrite": case "colorWrite": case "opacity": case "reflectivity": case "transparent": case "visible": case "wireframe": i[n] = r; break; case "vertexColors": !0 === r && (i.vertexColors = S), "face" === r && (i.vertexColors = 1); break; default: console.error("THREE.Loader.createMaterial: Unsupported", n, r) } } return "MeshBasicMaterial" === i.type && delete i.emissive, "MeshPhongMaterial" !== i.type && delete i.specular, i.opacity < 1 && (i.transparent = !0), yl.setTextures(c), yl.parse(i) }) }); var Ll, Rl, Pl, Cl, Ol, Il, Dl, Nl, Bl, zl, Ul, Gl, Fl, Hl, Vl, kl, jl, Wl, ql, Xl = { getContext: function () { return void 0 === xl && (xl = new (window.AudioContext || window.webkitAudioContext)), xl }, setContext: function (t) { xl = t } }; function Yl(t) { this.manager = void 0 !== t ? t : wh } function Jl() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new zo, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new zo, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1 } function Zl(t, e, n, i) { Si.call(this), this.type = "CubeCamera"; var a = new zo(90, 1, t, e); a.up.set(0, -1, 0), a.lookAt(new qe(1, 0, 0)), this.add(a); var o = new zo(90, 1, t, e); o.up.set(0, -1, 0), o.lookAt(new qe(-1, 0, 0)), this.add(o); var s = new zo(90, 1, t, e); s.up.set(0, 0, 1), s.lookAt(new qe(0, 1, 0)), this.add(s); var c = new zo(90, 1, t, e); c.up.set(0, 0, -1), c.lookAt(new qe(0, -1, 0)), this.add(c); var h = new zo(90, 1, t, e); h.up.set(0, -1, 0), h.lookAt(new qe(0, 0, 1)), this.add(h); var l = new zo(90, 1, t, e); l.up.set(0, -1, 0), l.lookAt(new qe(0, 0, -1)), this.add(l), i = i || { format: Yt, magFilter: Ot, minFilter: Ot }, this.renderTarget = new Cn(n, n, i), this.renderTarget.texture.name = "CubeCamera", this.update = function (t, e) { null === this.parent && this.updateMatrixWorld(); var n = t.getRenderTarget(), i = this.renderTarget, r = i.texture.generateMipmaps; i.texture.generateMipmaps = !1, t.setRenderTarget(i, 0), t.render(e, a), t.setRenderTarget(i, 1), t.render(e, o), t.setRenderTarget(i, 2), t.render(e, s), t.setRenderTarget(i, 3), t.render(e, c), t.setRenderTarget(i, 4), t.render(e, h), i.texture.generateMipmaps = r, t.setRenderTarget(i, 5), t.render(e, l), t.setRenderTarget(n) }, this.clear = function (t, e, n, i) { for (var r = t.getRenderTarget(), a = this.renderTarget, o = 0; o < 6; o++)t.setRenderTarget(a, o), t.clear(e, n, i); t.setRenderTarget(r) } } function Ql(t) { this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } function Kl() { Si.call(this), this.type = "AudioListener", this.context = Xl.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0 } function $l(t) { Si.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = [] } function tu(t) { $l.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain) } function eu(t, e) { this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser) } function nu(t, e, n) { this.binding = t, this.valueSize = n; var i, r = Float64Array; switch (e) { case "quaternion": i = this._slerp; break; case "string": case "bool": r = Array, i = this._select; break; default: i = this._lerp }this.buffer = new r(4 * n), this._mixBufferRegion = i, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0 } Object.assign(Yl.prototype, { load: function (t, e, n, i) { var r = new Mh(this.manager); r.setResponseType("arraybuffer"), r.setPath(this.path), r.load(t, function (t) { t = t.slice(0); Xl.getContext().decodeAudioData(t, function (t) { e(t) }) }, n, i) }, setPath: function (t) { return this.path = t, this } }), Object.assign(Jl.prototype, { update: (Bl = new je, zl = new je, function (t) { var e, n, i, r, a; Ll === this && Rl === t.focus && Pl === t.fov && Cl === t.aspect * this.aspect && Ol === t.near && Il === t.far && Dl === t.zoom && Nl === this.eyeSep || (Ll = this, Rl = t.focus, Pl = t.fov, Cl = t.aspect * this.aspect, Ol = t.near, Il = t.far, Dl = t.zoom, e = t.projectionMatrix.clone(), n = (Nl = this.eyeSep / 2) * Ol / Rl, i = Ol * Math.tan(Ve.DEG2RAD * Pl * .5) / Dl, zl.elements[12] = -Nl, Bl.elements[12] = Nl, r = -i * Cl + n, a = i * Cl + n, e.elements[0] = 2 * Ol / (a - r), e.elements[8] = (a + r) / (a - r), this.cameraL.projectionMatrix.copy(e), r = -i * Cl - n, a = i * Cl - n, e.elements[0] = 2 * Ol / (a - r), e.elements[8] = (a + r) / (a - r), this.cameraR.projectionMatrix.copy(e)), this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(zl), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Bl) }) }), (Zl.prototype = Object.create(Si.prototype)).constructor = Zl, Object.assign(Ql.prototype, { start: function () { this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 }, stop: function () { this.getElapsedTime(), this.running = !1, this.autoStart = !1 }, getElapsedTime: function () { return this.getDelta(), this.elapsedTime }, getDelta: function () { var t, e = 0; return this.autoStart && !this.running ? (this.start(), 0) : (this.running && (e = ((t = ("undefined" == typeof performance ? Date : performance).now()) - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e), e) } }), Kl.prototype = Object.assign(Object.create(Si.prototype), { constructor: Kl, getInput: function () { return this.gain }, removeFilter: function () { return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this }, getFilter: function () { return this.filter }, setFilter: function (t) { return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this }, getMasterVolume: function () { return this.gain.gain.value }, setMasterVolume: function (t) { return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this }, updateMatrixWorld: (Ul = new qe, Gl = new We, Fl = new qe, Hl = new qe, Vl = new Ql, function (t) { Si.prototype.updateMatrixWorld.call(this, t); var e = this.context.listener, n = this.up; this.timeDelta = Vl.getDelta(), this.matrixWorld.decompose(Ul, Gl, Fl), Hl.set(0, 0, -1).applyQuaternion(Gl), e.positionX ? (t = this.context.currentTime + this.timeDelta, e.positionX.linearRampToValueAtTime(Ul.x, t), e.positionY.linearRampToValueAtTime(Ul.y, t), e.positionZ.linearRampToValueAtTime(Ul.z, t), e.forwardX.linearRampToValueAtTime(Hl.x, t), e.forwardY.linearRampToValueAtTime(Hl.y, t), e.forwardZ.linearRampToValueAtTime(Hl.z, t), e.upX.linearRampToValueAtTime(n.x, t), e.upY.linearRampToValueAtTime(n.y, t), e.upZ.linearRampToValueAtTime(n.z, t)) : (e.setPosition(Ul.x, Ul.y, Ul.z), e.setOrientation(Hl.x, Hl.y, Hl.z, n.x, n.y, n.z)) }) }), $l.prototype = Object.assign(Object.create(Si.prototype), { constructor: $l, getOutput: function () { return this.gain }, setNodeSource: function (t) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this }, setMediaElementSource: function (t) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this }, setBuffer: function (t) { return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this }, play: function () { if (!0 !== this.isPlaying) { if (!1 !== this.hasPlaybackControl) { var t = this.context.createBufferSource(); return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), this.startTime = this.context.currentTime, t.start(this.startTime, this.offset), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } console.warn("THREE.Audio: this Audio has no playback control.") } else console.warn("THREE.Audio: Audio is already playing.") }, pause: function () { if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this; console.warn("THREE.Audio: this Audio has no playback control.") }, stop: function () { if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this; console.warn("THREE.Audio: this Audio has no playback control.") }, connect: function () { if (0 < this.filters.length) { this.source.connect(this.filters[0]); for (var t = 1, e = this.filters.length; t < e; t++)this.filters[t - 1].connect(this.filters[t]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this }, disconnect: function () { if (0 < this.filters.length) { this.source.disconnect(this.filters[0]); for (var t = 1, e = this.filters.length; t < e; t++)this.filters[t - 1].disconnect(this.filters[t]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this }, getFilters: function () { return this.filters }, setFilters: function (t) { return t = t || [], !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this }, setDetune: function (t) { if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this }, getDetune: function () { return this.detune }, getFilter: function () { return this.getFilters()[0] }, setFilter: function (t) { return this.setFilters(t ? [t] : []) }, setPlaybackRate: function (t) { if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this; console.warn("THREE.Audio: this Audio has no playback control.") }, getPlaybackRate: function () { return this.playbackRate }, onEnded: function () { this.isPlaying = !1 }, getLoop: function () { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop }, setLoop: function (t) { if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this; console.warn("THREE.Audio: this Audio has no playback control.") }, getVolume: function () { return this.gain.gain.value }, setVolume: function (t) { return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this } }), tu.prototype = Object.assign(Object.create($l.prototype), { constructor: tu, getOutput: function () { return this.panner }, getRefDistance: function () { return this.panner.refDistance }, setRefDistance: function (t) { return this.panner.refDistance = t, this }, getRolloffFactor: function () { return this.panner.rolloffFactor }, setRolloffFactor: function (t) { return this.panner.rolloffFactor = t, this }, getDistanceModel: function () { return this.panner.distanceModel }, setDistanceModel: function (t) { return this.panner.distanceModel = t, this }, getMaxDistance: function () { return this.panner.maxDistance }, setMaxDistance: function (t) { return this.panner.maxDistance = t, this }, setDirectionalCone: function (t, e, n) { return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this }, updateMatrixWorld: (kl = new qe, jl = new We, Wl = new qe, ql = new qe, function (t) { var e; Si.prototype.updateMatrixWorld.call(this, t), !0 === this.hasPlaybackControl && !1 === this.isPlaying || (this.matrixWorld.decompose(kl, jl, Wl), ql.set(0, 0, 1).applyQuaternion(jl), (e = this.panner).positionX ? (t = this.context.currentTime + this.listener.timeDelta, e.positionX.linearRampToValueAtTime(kl.x, t), e.positionY.linearRampToValueAtTime(kl.y, t), e.positionZ.linearRampToValueAtTime(kl.z, t), e.orientationX.linearRampToValueAtTime(ql.x, t), e.orientationY.linearRampToValueAtTime(ql.y, t), e.orientationZ.linearRampToValueAtTime(ql.z, t)) : (e.setPosition(kl.x, kl.y, kl.z), e.setOrientation(ql.x, ql.y, ql.z))) }) }), Object.assign(eu.prototype, { getFrequencyData: function () { return this.analyser.getByteFrequencyData(this.data), this.data }, getAverageFrequency: function () { for (var t = 0, e = this.getFrequencyData(), n = 0; n < e.length; n++)t += e[n]; return t / e.length } }), Object.assign(nu.prototype, { accumulate: function (t, e) { var n = this.buffer, i = this.valueSize, r = t * i + i, t = this.cumulativeWeight; if (0 === t) { for (var a = 0; a !== i; ++a)n[r + a] = n[a]; t = e } else { e = e / (t += e); this._mixBufferRegion(n, r, 0, e, i) } this.cumulativeWeight = t }, apply: function (t) { var e = this.valueSize, n = this.buffer, i = t * e + e, r = this.cumulativeWeight, a = this.binding; this.cumulativeWeight = 0, r < 1 && (t = 3 * e, this._mixBufferRegion(n, i, t, 1 - r, e)); for (var o = e, s = e + e; o !== s; ++o)if (n[o] !== n[o + e]) { a.setValue(n, i); break } }, saveOriginalState: function () { var t = this.binding, e = this.buffer, n = this.valueSize, i = 3 * n; t.getValue(e, i); for (var r = n, a = i; r !== a; ++r)e[r] = e[i + r % n]; this.cumulativeWeight = 0 }, restoreOriginalState: function () { var t = 3 * this.valueSize; this.binding.setValue(this.buffer, t) }, _select: function (t, e, n, i, r) { if (.5 <= i) for (var a = 0; a !== r; ++a)t[e + a] = t[n + a] }, _slerp: function (t, e, n, i) { We.slerpFlat(t, e, t, e, t, n, i) }, _lerp: function (t, e, n, i, r) { for (var a = 1 - i, o = 0; o !== r; ++o) { var s = e + o; t[s] = t[s] * a + t[n + o] * i } } }); var iu, ru, au, ou, su, cu, hu, lu, uu, pu, du, fu, mu, gu, vu, yu, xu, bu, wu, _u, Mu, Eu, Su, Tu, Au, Lu, Ru, Pu, Cu, Ou, Iu, Du, Nu, Bu = "\\[\\]\\.:\\/"; function zu(t, e, n) { n = n || Uu.parseTrackName(e); this._targetGroup = t, this._bindings = t.subscribe_(e, n) } function Uu(t, e, n) { this.path = e, this.parsedPath = n || Uu.parseTrackName(e), this.node = Uu.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t } function Gu() { this.uuid = Ve.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; var t = {}; this._indicesByUUID = t; for (var e = 0, n = arguments.length; e !== n; ++e)t[arguments[e].uuid] = e; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; var i = this; this.stats = { objects: { get total() { return i._objects.length }, get inUse() { return this.total - i.nCachedObjects_ } }, get bindingsPerObject() { return i._bindings.length } } } function Fu(t, e, n) { this._mixer = t, this._clip = e, this._localRoot = n || null; for (var i = e.tracks, r = i.length, a = new Array(r), o = { endingStart: Ae, endingEnd: Ae }, s = 0; s !== r; ++s) { var c = i[s].createInterpolant(null); (a[s] = c).settings = o } this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } function Hu(t) { this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } function Vu(t) { "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t } function ku() { rr.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0 } function ju(t, e, n) { _s.call(this, t, e), this.meshPerAttribute = n || 1 } function Wu(t, e, n, i) { "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), Ni.call(this, t, e, n), this.meshPerAttribute = i || 1 } function qu(t, e, n, i) { this.ray = new $r(t, e), this.near = n || 0, this.far = i || 1 / 0, this.params = { Mesh: {}, Line: {}, LOD: {}, Points: { threshold: 1 }, Sprite: {} }, Object.defineProperties(this.params, { PointCloud: { get: function () { return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points } } }) } function Xu(t, e) { return t.distance - e.distance } function Yu(t, e, n, i) { if (!1 !== t.visible && (t.raycast(e, n), !0 === i)) for (var r = t.children, a = 0, o = r.length; a < o; a++)Yu(r[a], e, n, !0) } function Ju(t, e, n) { return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== n ? n : 0, this } function Zu(t, e, n) { return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== n ? n : 0, this } function Qu(t, e) { this.min = void 0 !== t ? t : new ke(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new ke(-1 / 0, -1 / 0) } function Ku(t, e) { this.start = void 0 !== t ? t : new qe, this.end = void 0 !== e ? e : new qe } function $u(t) { Si.call(this), this.material = t, this.render = function () { } } function tp(t, e, n, i) { this.object = t, this.size = void 0 !== e ? e : 1; t = void 0 !== n ? n : 16711680, e = void 0 !== i ? i : 1, n = 0, i = this.object.geometry; i && i.isGeometry ? n = 3 * i.faces.length : i && i.isBufferGeometry && (n = i.attributes.normal.count); i = new rr, n = new ki(2 * n * 3, 3); i.addAttribute("position", n), Is.call(this, i, new Cs({ color: t, linewidth: e })), this.matrixAutoUpdate = !1, this.update() } function ep(t, e) { Si.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e; for (var t = new rr, n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], i = 0, r = 1; i < 32; i++, r++) { var a = i / 32 * Math.PI * 2, o = r / 32 * Math.PI * 2; n.push(Math.cos(a), Math.sin(a), 1, Math.cos(o), Math.sin(o), 1) } t.addAttribute("position", new ki(n, 3)); e = new Cs({ fog: !1 }); this.cone = new Is(t, e), this.add(this.cone), this.update() } function np(t) { for (var e = function t(e) { var n = []; e && e.isBone && n.push(e); for (var i = 0; i < e.children.length; i++)n.push.apply(n, t(e.children[i])); return n }(t), n = new rr, i = [], r = [], a = new Xn(0, 0, 1), o = new Xn(0, 1, 0), s = 0; s < e.length; s++) { var c = e[s]; c.parent && c.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(o.r, o.g, o.b)) } n.addAttribute("position", new ki(i, 3)), n.addAttribute("color", new ki(r, 3)); var h = new Cs({ vertexColors: S, depthTest: !1, depthWrite: !1, transparent: !0 }); Is.call(this, n, h), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1 } function ip(t, e, n) { this.light = t, this.light.updateMatrixWorld(), this.color = n; n = new Cc(e, 4, 2), e = new ea({ wireframe: !0, fog: !1 }); na.call(this, n, e), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() } function rp(t, e) { this.type = "RectAreaLightHelper", this.light = t, this.color = e; t = new rr; t.addAttribute("position", new ki([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), t.computeBoundingSphere(); e = new Cs({ fog: !1 }); Os.call(this, t, e); e = new rr; e.addAttribute("position", new ki([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), e.computeBoundingSphere(), this.add(new na(e, new ea({ side: _t, fog: !1 }))), this.update() } function ap(t, e, n) { Si.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n; n = new Js(e); n.rotateY(.5 * Math.PI), this.material = new ea({ wireframe: !0, fog: !1 }), void 0 === this.color && (this.material.vertexColors = S); e = n.getAttribute("position"), e = new Float32Array(3 * e.count); n.addAttribute("color", new Ni(e, 3)), this.add(new na(n, this.material)), this.update() } function op(t, e, n, i) { t = t || 10, e = e || 10, n = new Xn(void 0 !== n ? n : 4473924), i = new Xn(void 0 !== i ? i : 8947848); for (var r = e / 2, a = t / e, o = t / 2, s = [], c = [], h = 0, l = 0, u = -o; h <= e; h++, u += a) { s.push(-o, 0, u, o, 0, u), s.push(u, 0, -o, u, 0, o); var p = h === r ? n : i; p.toArray(c, l), l += 3, p.toArray(c, l), l += 3, p.toArray(c, l), l += 3, p.toArray(c, l), l += 3 } var d = new rr; d.addAttribute("position", new ki(s, 3)), d.addAttribute("color", new ki(c, 3)); t = new Cs({ vertexColors: S }); Is.call(this, d, t) } function sp(t, e, n, i, r, a) { t = t || 10, e = e || 16, n = n || 8, i = i || 64, r = new Xn(void 0 !== r ? r : 4473924), a = new Xn(void 0 !== a ? a : 8947848); for (var o, s, c, h, l, u, p = [], d = [], f = 0; f <= e; f++)c = f / e * (2 * Math.PI), o = Math.sin(c) * t, s = Math.cos(c) * t, p.push(0, 0, 0), p.push(o, 0, s), u = 1 & f ? r : a, d.push(u.r, u.g, u.b), d.push(u.r, u.g, u.b); for (f = 0; f <= n; f++)for (u = 1 & f ? r : a, l = t - t / n * f, h = 0; h < i; h++)c = h / i * (2 * Math.PI), o = Math.sin(c) * l, s = Math.cos(c) * l, p.push(o, 0, s), d.push(u.r, u.g, u.b), c = (h + 1) / i * (2 * Math.PI), o = Math.sin(c) * l, s = Math.cos(c) * l, p.push(o, 0, s), d.push(u.r, u.g, u.b); var m = new rr; m.addAttribute("position", new ki(p, 3)), m.addAttribute("color", new ki(d, 3)); var g = new Cs({ vertexColors: S }); Is.call(this, m, g) } function cp(t, e, n, i) { this.audio = t, this.range = e || 1, this.divisionsInnerAngle = n || 16, this.divisionsOuterAngle = i || 2; e = new rr, n = this.divisionsInnerAngle + 2 * this.divisionsOuterAngle, i = new Float32Array(3 * (3 * n + 3)); e.addAttribute("position", new Ni(i, 3)); n = new Cs({ color: 65280 }), i = new Cs({ color: 16776960 }); Os.call(this, e, [i, n]), this.update() } function hp(t, e, n, i) { this.object = t, this.size = void 0 !== e ? e : 1; t = void 0 !== n ? n : 16776960, e = void 0 !== i ? i : 1, n = 0, i = this.object.geometry; i && i.isGeometry ? n = i.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."); i = new rr, n = new ki(2 * n * 3, 3); i.addAttribute("position", n), Is.call(this, i, new Cs({ color: t, linewidth: e })), this.matrixAutoUpdate = !1, this.update() } function lp(t, e, n) { Si.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === e && (e = 1); n = new rr; n.addAttribute("position", new ki([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)); e = new Cs({ fog: !1 }); this.lightPlane = new Os(n, e), this.add(this.lightPlane), (n = new rr).addAttribute("position", new ki([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Os(n, e), this.add(this.targetLine), this.update() } function up(t) { var e = new rr, n = new Cs({ color: 16777215, vertexColors: 1 }), i = [], r = [], a = {}, o = new Xn(16755200), s = new Xn(16711680), c = new Xn(43775), h = new Xn(16777215), l = new Xn(3355443); function u(t, e, n) { p(t, n), p(e, n) } function p(t, e) { i.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === a[t] && (a[t] = []), a[t].push(i.length / 3 - 1) } u("n1", "n2", o), u("n2", "n4", o), u("n4", "n3", o), u("n3", "n1", o), u("f1", "f2", o), u("f2", "f4", o), u("f4", "f3", o), u("f3", "f1", o), u("n1", "f1", o), u("n2", "f2", o), u("n3", "f3", o), u("n4", "f4", o), u("p", "n1", s), u("p", "n2", s), u("p", "n3", s), u("p", "n4", s), u("u1", "u2", c), u("u2", "u3", c), u("u3", "u1", c), u("c", "t", h), u("p", "c", l), u("cn1", "cn2", l), u("cn3", "cn4", l), u("cf1", "cf2", l), u("cf3", "cf4", l), e.addAttribute("position", new ki(i, 3)), e.addAttribute("color", new ki(r, 3)), Is.call(this, e, n), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update() } function pp(t, e, n, i) { Ru.set(e, n, i).unproject(Pu); var r = Lu[t]; if (void 0 !== r) for (var a = Au.getAttribute("position"), o = 0, s = r.length; o < s; o++)a.setXYZ(r[o], Ru.x, Ru.y, Ru.z) } function dp(t, e) { this.object = t, void 0 === e && (e = 16776960); var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Float32Array(24), t = new rr; t.setIndex(new Ni(n, 1)), t.addAttribute("position", new Ni(i, 3)), Is.call(this, t, new Cs({ color: e })), this.matrixAutoUpdate = !1, this.update() } function fp(t, e) { this.type = "Box3Helper", this.box = t; var n = void 0 !== e ? e : 16776960, t = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), e = new rr; e.setIndex(new Ni(t, 1)), e.addAttribute("position", new ki([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Is.call(this, e, new Cs({ color: n })), this.geometry.computeBoundingSphere() } function mp(t, e, n) { this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e; e = void 0 !== n ? n : 16776960, n = new rr; n.addAttribute("position", new ki([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), n.computeBoundingSphere(), Os.call(this, n, new Cs({ color: e })); n = new rr; n.addAttribute("position", new ki([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), n.computeBoundingSphere(), this.add(new na(n, new ea({ color: e, opacity: .2, transparent: !0, depthWrite: !1 }))) } function gp(t, e, n, i, r, a) { Si.call(this), void 0 === t && (t = new qe(0, 0, 1)), void 0 === e && (e = new qe(0, 0, 0)), void 0 === n && (n = 1), void 0 === i && (i = 16776960), void 0 === r && (r = .2 * n), void 0 === a && (a = .2 * r), void 0 === Ou && ((Ou = new rr).addAttribute("position", new ki([0, 0, 0, 0, 1, 0], 3)), (Iu = new Hc(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(e), this.line = new Os(Ou, new Cs({ color: i })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new na(Iu, new ea({ color: i })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, r, a) } function vp(t) { var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t], t = new rr; t.addAttribute("position", new ki(e, 3)), t.addAttribute("color", new ki([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)); e = new Cs({ vertexColors: S }); Is.call(this, t, e) } Object.assign(zu.prototype, { getValue: function (t, e) { this.bind(); var n = this._targetGroup.nCachedObjects_, n = this._bindings[n]; void 0 !== n && n.getValue(t, e) }, setValue: function (t, e) { for (var n = this._bindings, i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)n[i].setValue(t, e) }, bind: function () { for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)t[e].bind() }, unbind: function () { for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)t[e].unbind() } }), Object.assign(Uu, { Composite: zu, create: function (t, e, n) { return new (t && t.isAnimationObjectGroup ? Uu.Composite : Uu)(t, e, n) }, sanitizeNodeName: (ou = new RegExp("[" + Bu + "]", "g"), function (t) { return t.replace(/\s/g, "_").replace(ou, "") }), parseTrackName: (Mp = "[^" + Bu + "]", _p = "[^" + Bu.replace("\\.", "") + "]", iu = /((?:WC+[\/:])*)/.source.replace("WC", Mp), Bu = /(WCOD+)?/.source.replace("WCOD", _p), _p = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Mp), Mp = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Mp), ru = new RegExp("^" + iu + Bu + _p + Mp + "$"), au = ["material", "materials", "bones"], function (t) { var e = ru.exec(t); if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t); var n = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] }, i = n.nodeName && n.nodeName.lastIndexOf("."); if (void 0 !== i && -1 !== i && (e = n.nodeName.substring(i + 1), -1 !== au.indexOf(e) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = e)), null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t); return n }), findNode: function (t, i) { if (!i || "" === i || "root" === i || "." === i || -1 === i || i === t.name || i === t.uuid) return t; if (t.skeleton) { var e = t.skeleton.getBoneByName(i); if (void 0 !== e) return e } if (t.children) { var r = function (t) { for (var e = 0; e < t.length; e++) { var n = t[e]; if (n.name === i || n.uuid === i) return n; n = r(n.children); if (n) return n } return null }, t = r(t.children); if (t) return t } return null } }), Object.assign(Uu.prototype, { _getValue_unavailable: function () { }, _setValue_unavailable: function () { }, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [function (t, e) { t[e] = this.node[this.propertyName] }, function (t, e) { for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)t[e++] = n[i] }, function (t, e) { t[e] = this.resolvedProperty[this.propertyIndex] }, function (t, e) { this.resolvedProperty.toArray(t, e) }], SetterByBindingTypeAndVersioning: [[function (t, e) { this.targetObject[this.propertyName] = t[e] }, function (t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0 }, function (t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)n[i] = t[e++] }, function (t, e) { for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)n[i] = t[e++]; this.targetObject.needsUpdate = !0 }, function (t, e) { for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)n[i] = t[e++]; this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e] }, function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0 }, function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { this.resolvedProperty.fromArray(t, e) }, function (t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0 }, function (t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0 }]], getValue: function (t, e) { this.bind(), this.getValue(t, e) }, setValue: function (t, e) { this.bind(), this.setValue(t, e) }, bind: function () { var t = this.node, e = this.parsedPath, n = e.objectName, i = e.propertyName, r = e.propertyIndex; if (t || (t = Uu.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) { if (n) { var a = e.objectIndex; switch (n) { case "materials": if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); t = t.material.materials; break; case "bones": if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); t = t.skeleton.bones; for (var o = 0; o < t.length; o++)if (t[o].name === a) { a = o; break } break; default: if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); t = t[n] }if (void 0 !== a) { if (void 0 === t[a]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t); t = t[a] } } var s = t[i]; if (void 0 !== s) { var c = this.Versioning.None; void 0 !== (this.targetObject = t).needsUpdate ? c = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate); var h = this.BindingType.Direct; if (void 0 !== r) { if ("morphTargetInfluences" === i) { if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); if (t.geometry.isBufferGeometry) { if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); for (o = 0; o < this.node.geometry.morphAttributes.position.length; o++)if (t.geometry.morphAttributes.position[o].name === r) { r = o; break } } else { if (!t.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this); for (o = 0; o < this.node.geometry.morphTargets.length; o++)if (t.geometry.morphTargets[o].name === r) { r = o; break } } } h = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r } else void 0 !== s.fromArray && void 0 !== s.toArray ? (h = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (h = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i; this.getValue = this.GetterByBindingType[h], this.setValue = this.SetterByBindingTypeAndVersioning[h][c] } else { e = e.nodeName; console.error("THREE.PropertyBinding: Trying to update property for track: " + e + "." + i + " but it wasn't found.", t) } } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.") }, unbind: function () { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } }), Object.assign(Uu.prototype, { _getValue_unbound: Uu.prototype.getValue, _setValue_unbound: Uu.prototype.setValue }), Object.assign(Gu.prototype, { isAnimationObjectGroup: !0, add: function () { for (var t = this._objects, e = t.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._paths, a = this._parsedPaths, o = this._bindings, s = o.length, c = void 0, h = 0, l = arguments.length; h !== l; ++h) { var u = arguments[h], p = u.uuid, d = i[p]; if (void 0 === d) { d = e++, i[p] = d, t.push(u); for (var f = 0, m = s; f !== m; ++f)o[f].push(new Uu(u, r[f], a[f])) } else if (d < n) { c = t[d]; var g = --n, v = t[g]; t[i[v.uuid] = d] = v, t[i[p] = g] = u; for (f = 0, m = s; f !== m; ++f) { var y = o[f], x = y[g], b = y[d]; y[d] = x, void 0 === b && (b = new Uu(u, r[f], a[f])), y[g] = b } } else t[d] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = n }, remove: function () { for (var t = this._objects, e = this.nCachedObjects_, n = this._indicesByUUID, i = this._bindings, r = i.length, a = 0, o = arguments.length; a !== o; ++a) { var s = arguments[a], c = s.uuid, h = n[c]; if (void 0 !== h && e <= h) { var l = e++, u = t[l]; t[n[u.uuid] = h] = u, t[n[c] = l] = s; for (var p = 0, d = r; p !== d; ++p) { var f = i[p], m = f[l], g = f[h]; f[h] = m, f[l] = g } } } this.nCachedObjects_ = e }, uncache: function () { for (var t = this._objects, e = t.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._bindings, a = r.length, o = 0, s = arguments.length; o !== s; ++o) { var c = arguments[o].uuid, h = i[c]; if (void 0 !== h) if (delete i[c], h < n) { var l, u = --n, c = t[u], p = t[l = --e]; t[i[c.uuid] = h] = c, t[i[p.uuid] = u] = p, t.pop(); for (var d = 0, f = a; d !== f; ++d) { var m = (v = r[d])[u], g = v[l]; v[h] = m, v[u] = g, v.pop() } } else { t[i[(p = t[l = --e]).uuid] = h] = p, t.pop(); for (var v, d = 0, f = a; d !== f; ++d)(v = r[d])[h] = v[l], v.pop() } } this.nCachedObjects_ = n }, subscribe_: function (t, e) { var n = this._bindingsIndicesByPath, i = n[t], r = this._bindings; if (void 0 !== i) return r[i]; var a = this._paths, o = this._parsedPaths, s = this._objects, c = s.length, h = this.nCachedObjects_, l = new Array(c), i = r.length; n[t] = i, a.push(t), o.push(e), r.push(l); for (var u = h, p = s.length; u !== p; ++u) { var d = s[u]; l[u] = new Uu(d, t, e) } return l }, unsubscribe_: function (t) { var e, n, i, r, a, o = this._bindingsIndicesByPath, s = o[t]; void 0 !== s && (e = this._paths, n = this._parsedPaths, a = (i = this._bindings)[r = i.length - 1], i[o[t[r]] = s] = a, i.pop(), n[s] = n[r], n.pop(), e[s] = e[r], e.pop()) } }), Object.assign(Fu.prototype, { play: function () { return this._mixer._activateAction(this), this }, stop: function () { return this._mixer._deactivateAction(this), this.reset() }, reset: function () { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() }, isRunning: function () { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) }, isScheduled: function () { return this._mixer._isActiveAction(this) }, startAt: function (t) { return this._startTime = t, this }, setLoop: function (t, e) { return this.loop = t, this.repetitions = e, this }, setEffectiveWeight: function (t) { return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading() }, getEffectiveWeight: function () { return this._effectiveWeight }, fadeIn: function (t) { return this._scheduleFading(t, 0, 1) }, fadeOut: function (t) { return this._scheduleFading(t, 1, 0) }, crossFadeFrom: function (t, e, n) { var i, r; return t.fadeOut(e), this.fadeIn(e), n && (i = this._clip.duration, n = (r = t._clip.duration) / i, r = i / r, t.warp(1, n, e), this.warp(r, 1, e)), this }, crossFadeTo: function (t, e, n) { return t.crossFadeFrom(this, e, n) }, stopFading: function () { var t = this._weightInterpolant; return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this }, setEffectiveTimeScale: function (t) { return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping() }, getEffectiveTimeScale: function () { return this._effectiveTimeScale }, setDuration: function (t) { return this.timeScale = this._clip.duration / t, this.stopWarping() }, syncWith: function (t) { return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping() }, halt: function (t) { return this.warp(this._effectiveTimeScale, 0, t) }, warp: function (t, e, n) { var i = this._mixer, r = i.time, a = this._timeScaleInterpolant, o = this.timeScale; null === a && (a = i._lendControlInterpolant(), this._timeScaleInterpolant = a); i = a.parameterPositions, a = a.sampleValues; return i[0] = r, i[1] = r + n, a[0] = t / o, a[1] = e / o, this }, stopWarping: function () { var t = this._timeScaleInterpolant; return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this }, getMixer: function () { return this._mixer }, getClip: function () { return this._clip }, getRoot: function () { return this._localRoot || this._mixer._root }, _update: function (t, e, n, i) { if (this.enabled) { var r = this._startTime; if (null !== r) { r = (t - r) * n; if (r < 0 || 0 === n) return; this._startTime = null, e = n * r } e *= this._updateTimeScale(t); var a = this._updateTime(e), o = this._updateWeight(t); if (0 < o) for (var s = this._interpolants, c = this._propertyBindings, h = 0, l = s.length; h !== l; ++h)s[h].evaluate(a), c[h].accumulate(i, o) } else this._updateWeight(t) }, _updateWeight: function (t) { var e, n, i = 0; return this.enabled && (i = this.weight, null !== (e = this._weightInterpolant) && (i *= n = e.evaluate(t)[0], t > e.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1)))), this._effectiveWeight = i }, _updateTimeScale: function (t) { var e, n = 0; return this.paused || (n = this.timeScale, null !== (e = this._timeScaleInterpolant) && (n *= e.evaluate(t)[0], t > e.parameterPositions[1] && (this.stopWarping(), 0 === n ? this.paused = !0 : this.timeScale = n))), this._effectiveTimeScale = n }, _updateTime: function (t) { var e, n = this.time + t, i = this._clip.duration, r = this.loop, a = this._loopCount, o = 2202 === r; if (0 === t) return -1 !== a && o && 1 == (1 & a) ? i - n : n; if (2200 === r) { -1 === a && (this._loopCount = 0, this._setEndings(!0, !0, !1)); t: { if (i <= n) n = i; else { if (!(n < 0)) break t; n = 0 } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t < 0 ? -1 : 1 }) } } else if (-1 === a && (0 <= t ? (a = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), (i <= n || n < 0) && (n -= i * (e = Math.floor(n / i)), a += Math.abs(e), (r = this.repetitions - a) <= 0 ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, n = 0 < t ? i : 0, this._mixer.dispatchEvent({ type: "finished", action: this, direction: 0 < t ? 1 : -1 })) : (1 == r ? (r = t < 0, this._setEndings(r, !r, o)) : this._setEndings(!1, !1, o), this._loopCount = a, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: e }))), o && 1 == (1 & a)) return i - (this.time = n); return this.time = n }, _setEndings: function (t, e, n) { var i = this._interpolantSettings; n ? (i.endingStart = Le, i.endingEnd = Le) : (i.endingStart = t ? this.zeroSlopeAtStart ? Le : Ae : Re, i.endingEnd = e ? this.zeroSlopeAtEnd ? Le : Ae : Re) }, _scheduleFading: function (t, e, n) { var i = this._mixer, r = i.time, a = this._weightInterpolant; null === a && (a = i._lendControlInterpolant(), this._weightInterpolant = a); i = a.parameterPositions, a = a.sampleValues; return i[0] = r, a[0] = e, i[1] = r + t, a[1] = n, this } }), Hu.prototype = Object.assign(Object.create(e.prototype), { constructor: Hu, _bindAction: function (t, e) { var n = t._localRoot || this._root, i = t._clip.tracks, r = i.length, a = t._propertyBindings, o = t._interpolants, s = n.uuid, t = this._bindingsByRootAndName, c = t[s]; void 0 === c && (c = {}, t[s] = c); for (var h = 0; h !== r; ++h) { var l = i[h], u = l.name; if (void 0 !== (p = c[u])) a[h] = p; else { if (void 0 !== (p = a[h])) { null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, s, u)); continue } var p, d = e && e._propertyBindings[h].binding.parsedPath; ++(p = new nu(Uu.create(n, u, d), l.ValueTypeName, l.getValueSize())).referenceCount, this._addInactiveBinding(p, s, u), a[h] = p } o[h].resultBuffer = p.buffer } }, _activateAction: function (t) { if (!this._isActiveAction(t)) { var e, n, i; null === t._cacheIndex && (e = (t._localRoot || this._root).uuid, n = t._clip.uuid, i = this._actionsByClip[n], this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e)); for (var r = t._propertyBindings, a = 0, o = r.length; a !== o; ++a) { var s = r[a]; 0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState()) } this._lendAction(t) } }, _deactivateAction: function (t) { if (this._isActiveAction(t)) { for (var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) { var r = e[n]; 0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r)) } this._takeBackAction(t) } }, _initMemoryManager: function () { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; var t = this; this.stats = { actions: { get total() { return t._actions.length }, get inUse() { return t._nActiveActions } }, bindings: { get total() { return t._bindings.length }, get inUse() { return t._nActiveBindings } }, controlInterpolants: { get total() { return t._controlInterpolants.length }, get inUse() { return t._nActiveControlInterpolants } } } }, _isActiveAction: function (t) { t = t._cacheIndex; return null !== t && t < this._nActiveActions }, _addInactiveAction: function (t, e, n) { var i = this._actions, r = this._actionsByClip, a = r[e]; void 0 === a ? (a = { knownActions: [t], actionByRoot: {} }, t._byClipCacheIndex = 0, r[e] = a) : (e = a.knownActions, t._byClipCacheIndex = e.length, e.push(t)), t._cacheIndex = i.length, i.push(t), a.actionByRoot[n] = t }, _removeInactiveAction: function (t) { var e = this._actions, n = e[e.length - 1], i = t._cacheIndex; e[n._cacheIndex = i] = n, e.pop(), t._cacheIndex = null; var r = t._clip.uuid, a = this._actionsByClip, o = a[r], i = o.knownActions, n = i[i.length - 1], e = t._byClipCacheIndex; i[n._byClipCacheIndex = e] = n, i.pop(), t._byClipCacheIndex = null, delete o.actionByRoot[(t._localRoot || this._root).uuid], 0 === i.length && delete a[r], this._removeInactiveBindingsForAction(t) }, _removeInactiveBindingsForAction: function (t) { for (var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) { var r = e[n]; 0 == --r.referenceCount && this._removeInactiveBinding(r) } }, _lendAction: function (t) { var e = this._actions, n = t._cacheIndex, i = this._nActiveActions++, r = e[i]; e[t._cacheIndex = i] = t, e[r._cacheIndex = n] = r }, _takeBackAction: function (t) { var e = this._actions, n = t._cacheIndex, i = --this._nActiveActions, r = e[i]; e[t._cacheIndex = i] = t, e[r._cacheIndex = n] = r }, _addInactiveBinding: function (t, e, n) { var i = this._bindingsByRootAndName, r = i[e], a = this._bindings; void 0 === r && (r = {}, i[e] = r), (r[n] = t)._cacheIndex = a.length, a.push(t) }, _removeInactiveBinding: function (t) { var e = this._bindings, n = t.binding, i = n.rootNode.uuid, r = n.path, a = this._bindingsByRootAndName, o = a[i], n = e[e.length - 1], t = t._cacheIndex; e[n._cacheIndex = t] = n, e.pop(), delete o[r]; t: { for (var s in o) break t; delete a[i] } }, _lendBinding: function (t) { var e = this._bindings, n = t._cacheIndex, i = this._nActiveBindings++, r = e[i]; e[t._cacheIndex = i] = t, e[r._cacheIndex = n] = r }, _takeBackBinding: function (t) { var e = this._bindings, n = t._cacheIndex, i = --this._nActiveBindings, r = e[i]; e[t._cacheIndex = i] = t, e[r._cacheIndex = n] = r }, _lendControlInterpolant: function () { var t = this._controlInterpolants, e = this._nActiveControlInterpolants++, n = t[e]; return void 0 === n && (t[(n = new sh(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e] = n), n }, _takeBackControlInterpolant: function (t) { var e = this._controlInterpolants, n = t.__cacheIndex, i = --this._nActiveControlInterpolants, r = e[i]; e[t.__cacheIndex = i] = t, e[r.__cacheIndex = n] = r }, _controlInterpolantsResultBuffer: new Float32Array(1), clipAction: function (t, e) { var n = e || this._root, i = n.uuid, r = "string" == typeof t ? vh.findByName(n, t) : t, a = null !== r ? r.uuid : t, o = this._actionsByClip[a], n = null; if (void 0 !== o) { t = o.actionByRoot[i]; if (void 0 !== t) return t; n = o.knownActions[0], null === r && (r = n._clip) } if (null === r) return null; e = new Fu(this, r, e); return this._bindAction(e, n), this._addInactiveAction(e, a, i), e }, existingAction: function (t, e) { var n = e || this._root, e = n.uuid, n = "string" == typeof t ? vh.findByName(n, t) : t, t = n ? n.uuid : t, t = this._actionsByClip[t]; return void 0 !== t && t.actionByRoot[e] || null }, stopAllAction: function () { var t = this._actions, e = this._nActiveActions, n = this._bindings, i = this._nActiveBindings; this._nActiveActions = 0; for (var r = this._nActiveBindings = 0; r !== e; ++r)t[r].reset(); for (r = 0; r !== i; ++r)n[r].useCount = 0; return this }, update: function (t) { t *= this.timeScale; for (var e = this._actions, n = this._nActiveActions, i = this.time += t, r = Math.sign(t), a = this._accuIndex ^= 1, o = 0; o !== n; ++o)e[o]._update(i, t, r, a); for (var s = this._bindings, c = this._nActiveBindings, o = 0; o !== c; ++o)s[o].apply(a); return this }, getRoot: function () { return this._root }, uncacheClip: function (t) { var e = this._actions, n = t.uuid, i = this._actionsByClip, t = i[n]; if (void 0 !== t) { for (var r = t.knownActions, a = 0, o = r.length; a !== o; ++a) { var s = r[a]; this._deactivateAction(s); var c = s._cacheIndex, h = e[e.length - 1]; s._cacheIndex = null, s._byClipCacheIndex = null, e[h._cacheIndex = c] = h, e.pop(), this._removeInactiveBindingsForAction(s) } delete i[n] } }, uncacheRoot: function (t) { var e, n = t.uuid, i = this._actionsByClip; for (e in i) { var r = i[e].actionByRoot[n]; void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r)) } var a = this._bindingsByRootAndName[n]; if (void 0 !== a) for (var o in a) { var s = a[o]; s.restoreOriginalState(), this._removeInactiveBinding(s) } }, uncacheAction: function (t, e) { e = this.existingAction(t, e); null !== e && (this._deactivateAction(e), this._removeInactiveAction(e)) } }), Vu.prototype.clone = function () { return new Vu(void 0 === this.value.clone ? this.value : this.value.clone()) }, ku.prototype = Object.assign(Object.create(rr.prototype), { constructor: ku, isInstancedBufferGeometry: !0, copy: function (t) { return rr.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this }, clone: function () { return (new this.constructor).copy(this) } }), ju.prototype = Object.assign(Object.create(_s.prototype), { constructor: ju, isInstancedInterleavedBuffer: !0, copy: function (t) { return _s.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this } }), Wu.prototype = Object.assign(Object.create(Ni.prototype), { constructor: Wu, isInstancedBufferAttribute: !0, copy: function (t) { return Ni.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this } }), Object.assign(qu.prototype, { linePrecision: 1, set: function (t, e) { this.ray.set(t, e) }, setFromCamera: function (t, e) { e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.") }, intersectObject: function (t, e, n) { n = n || []; return Yu(t, this, n, e), n.sort(Xu), n }, intersectObjects: function (t, e, n) { var i = n || []; if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i; for (var r = 0, a = t.length; r < a; r++)Yu(t[r], this, i, e); return i.sort(Xu), i } }), Object.assign(Ju.prototype, { set: function (t, e, n) { return this.radius = t, this.phi = e, this.theta = n, this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this }, makeSafe: function () { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this }, setFromVector3: function (t) { return this.setFromCartesianCoords(t.x, t.y, t.z) }, setFromCartesianCoords: function (t, e, n) { return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(Ve.clamp(e / this.radius, -1, 1))), this } }), Object.assign(Zu.prototype, { set: function (t, e, n) { return this.radius = t, this.theta = e, this.y = n, this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this }, setFromVector3: function (t) { return this.setFromCartesianCoords(t.x, t.y, t.z) }, setFromCartesianCoords: function (t, e, n) { return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this } }), Object.assign(Qu.prototype, { set: function (t, e) { return this.min.copy(t), this.max.copy(e), this }, setFromPoints: function (t) { this.makeEmpty(); for (var e = 0, n = t.length; e < n; e++)this.expandByPoint(t[e]); return this }, setFromCenterAndSize: (cu = new ke, function (t, e) { e = cu.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(e), this.max.copy(t).add(e), this }), clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.min.copy(t.min), this.max.copy(t.max), this }, makeEmpty: function () { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y }, getCenter: function (t) { return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new ke), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) }, getSize: function (t) { return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new ke), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min) }, expandByPoint: function (t) { return this.min.min(t), this.max.max(t), this }, expandByVector: function (t) { return this.min.sub(t), this.max.add(t), this }, expandByScalar: function (t) { return this.min.addScalar(-t), this.max.addScalar(t), this }, containsPoint: function (t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y) }, containsBox: function (t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y }, getParameter: function (t, e) { return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new ke), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y)) }, intersectsBox: function (t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y) }, clampPoint: function (t, e) { return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new ke), e.copy(t).clamp(this.min, this.max) }, distanceToPoint: (su = new ke, function (t) { return su.copy(t).clamp(this.min, this.max).sub(t).length() }), intersect: function (t) { return this.min.max(t.min), this.max.min(t.max), this }, union: function (t) { return this.min.min(t.min), this.max.max(t.max), this }, translate: function (t) { return this.min.add(t), this.max.add(t), this }, equals: function (t) { return t.min.equals(this.min) && t.max.equals(this.max) } }), Object.assign(Ku.prototype, { set: function (t, e) { return this.start.copy(t), this.end.copy(e), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.start.copy(t.start), this.end.copy(t.end), this }, getCenter: function (t) { return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new qe), t.addVectors(this.start, this.end).multiplyScalar(.5) }, delta: function (t) { return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new qe), t.subVectors(this.end, this.start) }, distanceSq: function () { return this.start.distanceToSquared(this.end) }, distance: function () { return this.start.distanceTo(this.end) }, at: function (t, e) { return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new qe), this.delta(e).multiplyScalar(t).add(this.start) }, closestPointToPointParameter: (hu = new qe, lu = new qe, function (t, e) { hu.subVectors(t, this.start), lu.subVectors(this.end, this.start); t = lu.dot(lu), t = lu.dot(hu) / t; return e && (t = Ve.clamp(t, 0, 1)), t }), closestPointToPoint: function (t, e, n) { e = this.closestPointToPointParameter(t, e); return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new qe), this.delta(n).multiplyScalar(e).add(this.start) }, applyMatrix4: function (t) { return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this }, equals: function (t) { return t.start.equals(this.start) && t.end.equals(this.end) } }), (($u.prototype = Object.create(Si.prototype)).constructor = $u).prototype.isImmediateRenderObject = !0, ((tp.prototype = Object.create(Is.prototype)).constructor = tp).prototype.update = (uu = new qe, pu = new qe, du = new Xe, function () { var t = ["a", "b", "c"]; this.object.updateMatrixWorld(!0), du.getNormalMatrix(this.object.matrixWorld); var e = this.object.matrixWorld, n = this.geometry.attributes.position, i = this.object.geometry; if (i && i.isGeometry) for (var r = i.vertices, a = i.faces, o = 0, s = 0, c = a.length; s < c; s++)for (var h = a[s], l = 0, u = h.vertexNormals.length; l < u; l++) { var p = r[h[t[l]]], d = h.vertexNormals[l]; uu.copy(p).applyMatrix4(e), pu.copy(d).applyMatrix3(du).normalize().multiplyScalar(this.size).add(uu), n.setXYZ(o, uu.x, uu.y, uu.z), o += 1, n.setXYZ(o, pu.x, pu.y, pu.z), o += 1 } else if (i && i.isBufferGeometry) for (var f = i.attributes.position, m = i.attributes.normal, o = 0, l = 0, u = f.count; l < u; l++)uu.set(f.getX(l), f.getY(l), f.getZ(l)).applyMatrix4(e), pu.set(m.getX(l), m.getY(l), m.getZ(l)), pu.applyMatrix3(du).normalize().multiplyScalar(this.size).add(uu), n.setXYZ(o, uu.x, uu.y, uu.z), o += 1, n.setXYZ(o, pu.x, pu.y, pu.z), o += 1; n.needsUpdate = !0 }), ((ep.prototype = Object.create(Si.prototype)).constructor = ep).prototype.dispose = function () { this.cone.geometry.dispose(), this.cone.material.dispose() }, ep.prototype.update = (fu = new qe, function () { this.light.updateMatrixWorld(); var t = this.light.distance || 1e3, e = t * Math.tan(this.light.angle); this.cone.scale.set(e, e, t), fu.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(fu), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) }), ((np.prototype = Object.create(Is.prototype)).constructor = np).prototype.updateMatrixWorld = (mu = new qe, gu = new je, vu = new je, function (t) { var e = this.bones, n = this.geometry, i = n.getAttribute("position"); vu.getInverse(this.root.matrixWorld); for (var r = 0, a = 0; r < e.length; r++) { var o = e[r]; o.parent && o.parent.isBone && (gu.multiplyMatrices(vu, o.matrixWorld), mu.setFromMatrixPosition(gu), i.setXYZ(a, mu.x, mu.y, mu.z), gu.multiplyMatrices(vu, o.parent.matrixWorld), mu.setFromMatrixPosition(gu), i.setXYZ(a + 1, mu.x, mu.y, mu.z), a += 2) } n.getAttribute("position").needsUpdate = !0, Si.prototype.updateMatrixWorld.call(this, t) }), ((ip.prototype = Object.create(na.prototype)).constructor = ip).prototype.dispose = function () { this.geometry.dispose(), this.material.dispose() }, ip.prototype.update = function () { void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) }, ((rp.prototype = Object.create(Os.prototype)).constructor = rp).prototype.update = function () { var t, e; this.scale.set(.5 * this.light.width, .5 * this.light.height, 1), void 0 !== this.color ? (this.material.color.set(this.color), this.children[0].material.color.set(this.color)) : (this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity), t = this.material.color, 1 < (e = Math.max(t.r, t.g, t.b)) && t.multiplyScalar(1 / e), this.children[0].material.color.copy(this.material.color)) }, rp.prototype.dispose = function () { this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose() }, ((ap.prototype = Object.create(Si.prototype)).constructor = ap).prototype.dispose = function () { this.children[0].geometry.dispose(), this.children[0].material.dispose() }, ap.prototype.update = (yu = new qe, xu = new Xn, bu = new Xn, function () { var t = this.children[0]; if (void 0 !== this.color) this.material.color.set(this.color); else { var e = t.geometry.getAttribute("color"); xu.copy(this.light.color), bu.copy(this.light.groundColor); for (var n = 0, i = e.count; n < i; n++) { var r = n < i / 2 ? xu : bu; e.setXYZ(n, r.r, r.g, r.b) } e.needsUpdate = !0 } t.lookAt(yu.setFromMatrixPosition(this.light.matrixWorld).negate()) }), (op.prototype = Object.create(Is.prototype)).constructor = op, (sp.prototype = Object.create(Is.prototype)).constructor = sp, ((cp.prototype = Object.create(Os.prototype)).constructor = cp).prototype.update = function () { var a, o, t = this.audio, s = this.range, e = this.divisionsInnerAngle, n = this.divisionsOuterAngle, i = Ve.degToRad(t.panner.coneInnerAngle), r = Ve.degToRad(t.panner.coneOuterAngle), c = i / 2, t = r / 2, h = 0, l = 0, u = this.geometry, p = u.attributes.position; function d(t, e, n, i) { var r = (e - t) / n; for (p.setXYZ(h, 0, 0, 0), l++, a = t; a < e; a += r)o = h + l, p.setXYZ(o, Math.sin(a) * s, 0, Math.cos(a) * s), p.setXYZ(o + 1, Math.sin(Math.min(a + r, e)) * s, 0, Math.cos(Math.min(a + r, e)) * s), p.setXYZ(o + 2, 0, 0, 0), l += 3; u.addGroup(h, l, i), h += l, l = 0 } u.clearGroups(), d(-t, -c, n, 0), d(-c, c, e, 1), d(c, t, n, 0), p.needsUpdate = !0, i === r && (this.material[0].visible = !1) }, cp.prototype.dispose = function () { this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose() }, ((hp.prototype = Object.create(Is.prototype)).constructor = hp).prototype.update = (wu = new qe, _u = new qe, Mu = new Xe, function () { this.object.updateMatrixWorld(!0), Mu.getNormalMatrix(this.object.matrixWorld); for (var t = this.object.matrixWorld, e = this.geometry.attributes.position, n = this.object.geometry, i = n.vertices, r = n.faces, a = 0, o = 0, s = r.length; o < s; o++) { var c = r[o], h = c.normal; wu.copy(i[c.a]).add(i[c.b]).add(i[c.c]).divideScalar(3).applyMatrix4(t), _u.copy(h).applyMatrix3(Mu).normalize().multiplyScalar(this.size).add(wu), e.setXYZ(a, wu.x, wu.y, wu.z), a += 1, e.setXYZ(a, _u.x, _u.y, _u.z), a += 1 } e.needsUpdate = !0 }), ((lp.prototype = Object.create(Si.prototype)).constructor = lp).prototype.dispose = function () { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() }, lp.prototype.update = (Eu = new qe, Su = new qe, Tu = new qe, function () { Eu.setFromMatrixPosition(this.light.matrixWorld), Su.setFromMatrixPosition(this.light.target.matrixWorld), Tu.subVectors(Su, Eu), this.lightPlane.lookAt(Su), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Su), this.targetLine.scale.z = Tu.length() }), ((up.prototype = Object.create(Is.prototype)).constructor = up).prototype.update = (Ru = new qe, Pu = new Bo, function () { Au = this.geometry, Lu = this.pointMap; Pu.projectionMatrix.copy(this.camera.projectionMatrix), pp("c", 0, 0, -1), pp("t", 0, 0, 1), pp("n1", -1, -1, -1), pp("n2", 1, -1, -1), pp("n3", -1, 1, -1), pp("n4", 1, 1, -1), pp("f1", -1, -1, 1), pp("f2", 1, -1, 1), pp("f3", -1, 1, 1), pp("f4", 1, 1, 1), pp("u1", .7, 1.1, -1), pp("u2", -.7, 1.1, -1), pp("u3", 0, 2, -1), pp("cf1", -1, 0, 1), pp("cf2", 1, 0, 1), pp("cf3", 0, -1, 1), pp("cf4", 0, 1, 1), pp("cn1", -1, 0, -1), pp("cn2", 1, 0, -1), pp("cn3", 0, -1, -1), pp("cn4", 0, 1, -1), Au.getAttribute("position").needsUpdate = !0 }), ((dp.prototype = Object.create(Is.prototype)).constructor = dp).prototype.update = (Cu = new In, function (t) { var e, n, i; void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Cu.setFromObject(this.object), Cu.isEmpty() || (e = Cu.min, n = Cu.max, (t = (i = this.geometry.attributes.position).array)[0] = n.x, t[1] = n.y, t[2] = n.z, t[3] = e.x, t[4] = n.y, t[5] = n.z, t[6] = e.x, t[7] = e.y, t[8] = n.z, t[9] = n.x, t[10] = e.y, t[11] = n.z, t[12] = n.x, t[13] = n.y, t[14] = e.z, t[15] = e.x, t[16] = n.y, t[17] = e.z, t[18] = e.x, t[19] = e.y, t[20] = e.z, t[21] = n.x, t[22] = e.y, t[23] = e.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere()) }), dp.prototype.setFromObject = function (t) { return this.object = t, this.update(), this }, dp.prototype.copy = function (t) { return Is.prototype.copy.call(this, t), this.object = t.object, this }, dp.prototype.clone = function () { return (new this.constructor).copy(this) }, ((fp.prototype = Object.create(Is.prototype)).constructor = fp).prototype.updateMatrixWorld = function (t) { var e = this.box; e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), Si.prototype.updateMatrixWorld.call(this, t)) }, ((mp.prototype = Object.create(Os.prototype)).constructor = mp).prototype.updateMatrixWorld = function (t) { var e = -this.plane.constant; Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? _t : O, this.lookAt(this.plane.normal), Si.prototype.updateMatrixWorld.call(this, t) }, ((gp.prototype = Object.create(Si.prototype)).constructor = gp).prototype.setDirection = (Nu = new qe, function (t) { .99999 < t.y ? this.quaternion.set(0, 0, 0, 1) : t.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (Nu.set(t.z, 0, -t.x).normalize(), Du = Math.acos(t.y), this.quaternion.setFromAxisAngle(Nu, Du)) }), gp.prototype.setLength = function (t, e, n) { void 0 === e && (e = .2 * t), void 0 === n && (n = .2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix() }, gp.prototype.setColor = function (t) { this.line.material.color.copy(t), this.cone.material.color.copy(t) }, gp.prototype.copy = function (t) { return Si.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this }, gp.prototype.clone = function () { return (new this.constructor).copy(this) }, (vp.prototype = Object.create(Is.prototype)).constructor = vp; var yp; function xp(t) { console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Uh.call(this, t), this.type = "catmullrom", this.closed = !0 } function bp(t) { console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Uh.call(this, t), this.type = "catmullrom" } function wp(t) { console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Uh.call(this, t), this.type = "catmullrom" } Ph.create = function (t, e) { return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Ph.prototype), (t.prototype.constructor = t).prototype.getPoint = e, t }, Object.assign(Zh.prototype, { createPointsGeometry: function (t) { console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); t = this.getPoints(t); return this.createGeometry(t) }, createSpacedPointsGeometry: function (t) { console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); t = this.getSpacedPoints(t); return this.createGeometry(t) }, createGeometry: function (t) { console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); for (var e = new Di, n = 0, i = t.length; n < i; n++) { var r = t[n]; e.vertices.push(new qe(r.x, r.y, r.z || 0)) } return e } }), Object.assign(Qh.prototype, { fromPoints: function (t) { console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t) } }), xp.prototype = Object.create(Uh.prototype), bp.prototype = Object.create(Uh.prototype), wp.prototype = Object.create(Uh.prototype), Object.assign(wp.prototype, { initFromArray: function () { console.error("THREE.Spline: .initFromArray() has been removed.") }, getControlPointsArray: function () { console.error("THREE.Spline: .getControlPointsArray() has been removed.") }, reparametrizeByArcLength: function () { console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.") } }), op.prototype.setColors = function () { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }, np.prototype.update = function () { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }, Object.assign(Al.prototype, { extractUrlBase: function (t) { return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), ul.extractUrlBase(t) } }), Object.assign(fl.prototype, { setTexturePath: function (t) { return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t) } }), Object.assign(Qu.prototype, { center: function (t) { return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t) }, empty: function () { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function (t) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, size: function (t) { return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t) } }), Object.assign(In.prototype, { center: function (t) { return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t) }, empty: function () { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function (t) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, isIntersectionSphere: function (t) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) }, size: function (t) { return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t) } }), Ku.prototype.center = function (t) { return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t) }, Object.assign(Ve, { random16: function () { return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random() }, nearestPowerOfTwo: function (t) { return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Ve.floorPowerOfTwo(t) }, nextPowerOfTwo: function (t) { return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Ve.ceilPowerOfTwo(t) } }), Object.assign(Xe.prototype, { flattenToArrayOffset: function (t, e) { return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e) }, multiplyVector3: function (t) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this) }, multiplyVector3Array: function () { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, applyToBuffer: function (t) { return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t) }, applyToVector3Array: function () { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") } }), Object.assign(je.prototype, { extractPosition: function (t) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t) }, flattenToArrayOffset: function (t, e) { return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e) }, getPosition: function () { return void 0 === yp && (yp = new qe), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), yp.setFromMatrixColumn(this, 3) }, setRotationFromQuaternion: function (t) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t) }, multiplyToArray: function () { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, multiplyVector3: function (t) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, multiplyVector4: function (t) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, multiplyVector3Array: function () { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, rotateAxis: function (t) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this) }, crossVector: function (t) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, translate: function () { console.error("THREE.Matrix4: .translate() has been removed.") }, rotateX: function () { console.error("THREE.Matrix4: .rotateX() has been removed.") }, rotateY: function () { console.error("THREE.Matrix4: .rotateY() has been removed.") }, rotateZ: function () { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, rotateByAxis: function () { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, applyToBuffer: function (t) { return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t) }, applyToVector3Array: function () { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, makeFrustum: function (t, e, n, i, r, a) { return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, a) } }), zn.prototype.isIntersectionLine = function (t) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t) }, We.prototype.multiplyVector3 = function (t) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this) }, Object.assign($r.prototype, { isIntersectionBox: function (t) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, isIntersectionPlane: function (t) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t) }, isIntersectionSphere: function (t) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) } }), Object.assign(ta.prototype, { area: function () { return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea() }, barycoordFromPoint: function (t, e) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e) }, midpoint: function (t) { return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t) }, normal: function (t) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t) }, plane: function (t) { return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t) } }), Object.assign(ta, { barycoordFromPoint: function (t, e, n, i, r) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), ta.getBarycoord(t, e, n, i, r) }, normal: function (t, e, n, i) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), ta.getNormal(t, e, n, i) } }), Object.assign(Kh.prototype, { extractAllPoints: function (t) { return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t) }, extrude: function (t) { return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Ec(this, t) }, makeGeometry: function (t) { return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Bc(this, t) } }), Object.assign(ke.prototype, { fromAttribute: function (t, e, n) { return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, distanceToManhattan: function (t) { return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t) }, lengthManhattan: function () { return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(qe.prototype, { setEulerFromRotationMatrix: function () { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, setEulerFromQuaternion: function () { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, getPositionFromMatrix: function (t) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t) }, getScaleFromMatrix: function (t) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t) }, getColumnFromMatrix: function (t, e) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t) }, applyProjection: function (t) { return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t) }, fromAttribute: function (t, e, n) { return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, distanceToManhattan: function (t) { return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t) }, lengthManhattan: function () { return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(Ln.prototype, { fromAttribute: function (t, e, n) { return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, lengthManhattan: function () { return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(Di.prototype, { computeTangents: function () { console.error("THREE.Geometry: .computeTangents() has been removed.") }, computeLineDistances: function () { console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.") } }), Object.assign(Si.prototype, { getChildByName: function (t) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t) }, renderDepth: function () { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, translate: function (t, e) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t) }, getWorldRotation: function () { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") } }), Object.defineProperties(Si.prototype, { eulerOrder: { get: function () { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function (t) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t } }, useQuaternion: { get: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), Object.defineProperties(As.prototype, { objects: { get: function () { return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels } } }), Object.defineProperty(Rs.prototype, "useVertexTexture", { get: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed.") }, set: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed.") } }), Ls.prototype.initBones = function () { console.error("THREE.SkinnedMesh: initBones() has been removed.") }, Object.defineProperty(Ph.prototype, "__arcLengthDivisions", { get: function () { return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions }, set: function (t) { console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t } }), zo.prototype.setLens = function (t, e) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t) }, Object.defineProperties($h.prototype, { onlyShadow: { set: function () { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function (t) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t } }, shadowCameraLeft: { set: function (t) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t } }, shadowCameraRight: { set: function (t) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t } }, shadowCameraTop: { set: function (t) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t } }, shadowCameraBottom: { set: function (t) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t } }, shadowCameraNear: { set: function (t) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t } }, shadowCameraFar: { set: function (t) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t } }, shadowCameraVisible: { set: function () { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function (t) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t } }, shadowDarkness: { set: function () { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function (t) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t } }, shadowMapHeight: { set: function (t) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t } } }), Object.defineProperties(Ni.prototype, { length: { get: function () { return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length } }, copyIndicesArray: function () { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") } }), Object.assign(rr.prototype, { addIndex: function (t) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t) }, addDrawCall: function (t, e, n) { void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e) }, clearDrawCalls: function () { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, computeTangents: function () { console.warn("THREE.BufferGeometry: .computeTangents() has been removed.") }, computeOffsets: function () { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") } }), Object.defineProperties(rr.prototype, { drawcalls: { get: function () { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function () { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), Object.assign(Sc.prototype, { getArrays: function () { console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.") }, addShapeList: function () { console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.") }, addShape: function () { console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.") } }), Object.defineProperties(Vu.prototype, { dynamic: { set: function () { console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.") } }, onUpdate: { value: function () { return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this } } }), Object.defineProperties(lr.prototype, { wrapAround: { get: function () { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function () { console.warn("THREE.Material: .wrapAround has been removed.") } }, overdraw: { get: function () { console.warn("THREE.Material: .overdraw has been removed.") }, set: function () { console.warn("THREE.Material: .overdraw has been removed.") } }, wrapRGB: { get: function () { return console.warn("THREE.Material: .wrapRGB has been removed."), new Xn } }, shading: { get: function () { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function (t) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t } } }), Object.defineProperties(Qc.prototype, { metal: { get: function () { return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1 }, set: function () { console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead") } } }), Object.defineProperties(Kr.prototype, { derivatives: { get: function () { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function (t) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t } } }), Object.assign(ys.prototype, { clearTarget: function (t, e, n, i) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i) }, animate: function (t) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t) }, getCurrentRenderTarget: function () { return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget() }, getMaxAnisotropy: function () { return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy() }, getPrecision: function () { return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision }, resetGLState: function () { return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset() }, supportsFloatTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, supportsHalfFloatTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, supportsStandardDerivatives: function () { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, supportsCompressedTextureS3TC: function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, supportsCompressedTexturePVRTC: function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, supportsBlendMinMax: function () { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, supportsVertexTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures }, supportsInstancedArrays: function () { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, enableScissorTest: function (t) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t) }, initMaterial: function () { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, addPrePlugin: function () { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, addPostPlugin: function () { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, updateShadowMap: function () { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, setFaceCulling: function () { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") } }), Object.defineProperties(ys.prototype, { shadowMapEnabled: { get: function () { return this.shadowMap.enabled }, set: function (t) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t } }, shadowMapType: { get: function () { return this.shadowMap.type }, set: function (t) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t } }, shadowMapCullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(Co.prototype, { cullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(Cn.prototype, { activeCubeFace: { set: function () { console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().") } }, activeMipMapLevel: { set: function () { console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().") } } }), Object.defineProperties(Rn.prototype, { wrapS: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t } }, wrapT: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t } }, magFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t } }, minFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t } }, anisotropy: { get: function () { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t } }, offset: { get: function () { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t } }, repeat: { get: function () { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t } }, format: { get: function () { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t } }, type: { get: function () { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t } }, generateMipmaps: { get: function () { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t } } }), Object.defineProperties(gs.prototype, { standing: { set: function () { console.warn("THREE.WebVRManager: .standing has been removed.") } }, userHeight: { set: function () { console.warn("THREE.WebVRManager: .userHeight has been removed.") } } }), $l.prototype.load = function (t) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); var e = this; return (new Yl).load(t, function (t) { e.setBuffer(t) }), this }, eu.prototype.getData = function () { return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData() }, Zl.prototype.updateCubeMap = function (t, e) { return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e) }; var _p = { merge: function (t, e, n) { var i; console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), i = e.matrix, e = e.geometry), t.merge(e, i, n) }, center: function (t) { return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center() } }; Sn.crossOrigin = void 0, Sn.loadTexture = function (t, e, n, i) { console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."); var r = new Rh; r.setCrossOrigin(this.crossOrigin); i = r.load(t, n, void 0, i); return e && (i.mapping = e), i }, Sn.loadTextureCube = function (t, e, n, i) { console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."); var r = new Lh; r.setCrossOrigin(this.crossOrigin); i = r.load(t, n, void 0, i); return e && (i.mapping = e), i }, Sn.loadCompressedTexture = function () { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, Sn.loadCompressedTextureCube = function () { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") }; var Mp = { createMultiMaterialObject: function () { console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js") }, detach: function () { console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js") }, attach: function () { console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js") } }; t.WebGLMultisampleRenderTarget = Pn, t.WebGLRenderTargetCube = Cn, t.WebGLRenderTarget = Rn, t.WebGLRenderer = ys, t.ShaderLib = ti, t.UniformsLib = $n, t.UniformsUtils = Wn, t.ShaderChunk = Gn, t.FogExp2 = xs, t.Fog = bs, t.Scene = ws, t.Sprite = Ss, t.LOD = As, t.SkinnedMesh = Ls, t.Skeleton = Rs, t.Bone = Ps, t.Mesh = na, t.LineSegments = Is, t.LineLoop = Ds, t.Line = Os, t.Points = Bs, t.Group = No, t.VideoTexture = zs, t.DataTexture = On, t.DataTexture3D = va, t.CompressedTexture = Us, t.CubeTexture = ga, t.CanvasTexture = Gs, t.DepthTexture = Fs, t.Texture = An, t.AnimationLoader = Eh, t.CompressedTextureLoader = Sh, t.DataTextureLoader = Th, t.CubeTextureLoader = Lh, t.TextureLoader = Rh, t.ObjectLoader = fl, t.MaterialLoader = ll, t.BufferGeometryLoader = pl, t.DefaultLoadingManager = wh, t.LoadingManager = bh, t.ImageLoader = Ah, t.ImageBitmapLoader = Ml, t.FontLoader = Tl, t.FileLoader = Mh, t.Loader = Al, t.LoaderUtils = ul, t.Cache = xh, t.AudioLoader = Yl, t.SpotLightShadow = nl, t.SpotLight = il, t.PointLight = rl, t.RectAreaLight = hl, t.HemisphereLight = tl, t.DirectionalLightShadow = ol, t.DirectionalLight = sl, t.AmbientLight = cl, t.LightShadow = el, t.Light = $h, t.StereoCamera = Jl, t.PerspectiveCamera = zo, t.OrthographicCamera = al, t.CubeCamera = Zl, t.ArrayCamera = Uo, t.Camera = Bo, t.AudioListener = Kl, t.PositionalAudio = tu, t.AudioContext = Xl, t.AudioAnalyser = eu, t.Audio = $l, t.VectorKeyframeTrack = gh, t.StringKeyframeTrack = mh, t.QuaternionKeyframeTrack = fh, t.NumberKeyframeTrack = ph, t.ColorKeyframeTrack = uh, t.BooleanKeyframeTrack = lh, t.PropertyMixer = nu, t.PropertyBinding = Uu, t.KeyframeTrack = hh, t.AnimationUtils = rh, t.AnimationObjectGroup = Gu, t.AnimationMixer = Hu, t.AnimationClip = vh, t.Uniform = Vu, t.InstancedBufferGeometry = ku, t.BufferGeometry = rr, t.Geometry = Di, t.InterleavedBufferAttribute = Ms, t.InstancedInterleavedBuffer = ju, t.InterleavedBuffer = _s, t.InstancedBufferAttribute = Wu, t.Face3 = ii, t.Object3D = Si, t.Raycaster = qu, t.Layers = ai, t.EventDispatcher = e, t.Clock = Ql, t.QuaternionLinearInterpolant = dh, t.LinearInterpolant = sh, t.DiscreteInterpolant = ch, t.CubicInterpolant = oh, t.Interpolant = ah, t.Triangle = ta, t.Math = Ve, t.Spherical = Ju, t.Cylindrical = Zu, t.Plane = zn, t.Frustum = Un, t.Sphere = Bn, t.Ray = $r, t.Matrix4 = je, t.Matrix3 = Xe, t.Box3 = In, t.Box2 = Qu, t.Line3 = Ku, t.Euler = ri, t.Vector4 = Ln, t.Vector3 = qe, t.Vector2 = ke, t.Quaternion = We, t.Color = Xn, t.ImmediateRenderObject = $u, t.VertexNormalsHelper = tp, t.SpotLightHelper = ep, t.SkeletonHelper = np, t.PointLightHelper = ip, t.RectAreaLightHelper = rp, t.HemisphereLightHelper = ap, t.GridHelper = op, t.PolarGridHelper = sp, t.PositionalAudioHelper = cp, t.FaceNormalsHelper = hp, t.DirectionalLightHelper = lp, t.CameraHelper = up, t.BoxHelper = dp, t.Box3Helper = fp, t.PlaneHelper = mp, t.ArrowHelper = gp, t.AxesHelper = vp, t.Shape = Kh, t.Path = Qh, t.ShapePath = El, t.Font = Sl, t.CurvePath = Zh, t.Curve = Ph, t.ImageUtils = Sn, t.ShapeUtils = wc, t.WebGLUtils = Do, t.WireframeGeometry = Hs, t.ParametricGeometry = Vs, t.ParametricBufferGeometry = ks, t.TetrahedronGeometry = qs, t.TetrahedronBufferGeometry = Xs, t.OctahedronGeometry = Ys, t.OctahedronBufferGeometry = Js, t.IcosahedronGeometry = Zs, t.IcosahedronBufferGeometry = Qs, t.DodecahedronGeometry = Ks, t.DodecahedronBufferGeometry = $s, t.PolyhedronGeometry = js, t.PolyhedronBufferGeometry = Ws, t.TubeGeometry = tc, t.TubeBufferGeometry = ec, t.TorusKnotGeometry = nc, t.TorusKnotBufferGeometry = ic, t.TorusGeometry = rc, t.TorusBufferGeometry = ac, t.TextGeometry = Lc, t.TextBufferGeometry = Rc, t.SphereGeometry = Pc, t.SphereBufferGeometry = Cc, t.RingGeometry = Oc, t.RingBufferGeometry = Ic, t.PlaneGeometry = sr, t.PlaneBufferGeometry = cr, t.LatheGeometry = Dc, t.LatheBufferGeometry = Nc, t.ShapeGeometry = Bc, t.ShapeBufferGeometry = zc, t.ExtrudeGeometry = Ec, t.ExtrudeBufferGeometry = Sc, t.EdgesGeometry = Gc, t.ConeGeometry = Vc, t.ConeBufferGeometry = kc, t.CylinderGeometry = Fc, t.CylinderBufferGeometry = Hc, t.CircleGeometry = jc, t.CircleBufferGeometry = Wc, t.BoxGeometry = ar, t.CubeGeometry = ar, t.BoxBufferGeometry = or, t.ShadowMaterial = Xc, t.SpriteMaterial = Es, t.RawShaderMaterial = Yc, t.ShaderMaterial = Kr, t.PointsMaterial = Ns, t.MeshPhysicalMaterial = Zc, t.MeshStandardMaterial = Jc, t.MeshPhongMaterial = Qc, t.MeshToonMaterial = Kc, t.MeshNormalMaterial = $c, t.MeshLambertMaterial = th, t.MeshDepthMaterial = Ro, t.MeshDistanceMaterial = Po, t.MeshBasicMaterial = ea, t.MeshMatcapMaterial = eh, t.LineDashedMaterial = nh, t.LineBasicMaterial = Cs, t.Material = lr, t.Float64BufferAttribute = ji, t.Float32BufferAttribute = ki, t.Uint32BufferAttribute = Vi, t.Int32BufferAttribute = Hi, t.Uint16BufferAttribute = Fi, t.Int16BufferAttribute = Gi, t.Uint8ClampedBufferAttribute = Ui, t.Uint8BufferAttribute = zi, t.Int8BufferAttribute = Bi, t.BufferAttribute = Ni, t.ArcCurve = Oh, t.CatmullRomCurve3 = Uh, t.CubicBezierCurve = Vh, t.CubicBezierCurve3 = kh, t.EllipseCurve = Ch, t.LineCurve = jh, t.LineCurve3 = Wh, t.QuadraticBezierCurve = qh, t.QuadraticBezierCurve3 = Xh, t.SplineCurve = Yh, t.REVISION = "102", t.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }, t.CullFaceNone = W, t.CullFaceBack = q, t.CullFaceFront = X, t.CullFaceFrontBack = 3, t.FrontFaceDirectionCW = 0, t.FrontFaceDirectionCCW = 1, t.BasicShadowMap = 0, t.PCFShadowMap = C, t.PCFSoftShadowMap = A, t.FrontSide = O, t.BackSide = _t, t.DoubleSide = Y, t.FlatShading = 1, t.SmoothShading = 2, t.NoColors = E, t.FaceColors = 1, t.VertexColors = S, t.NoBlending = J, t.NormalBlending = Z, t.AdditiveBlending = Q, t.SubtractiveBlending = K, t.MultiplyBlending = $, t.CustomBlending = tt, t.AddEquation = et, t.SubtractEquation = T, t.ReverseSubtractEquation = L, t.MinEquation = R, t.MaxEquation = P, t.ZeroFactor = I, t.OneFactor = D, t.SrcColorFactor = N, t.OneMinusSrcColorFactor = B, t.SrcAlphaFactor = z, t.OneMinusSrcAlphaFactor = U, t.DstAlphaFactor = G, t.OneMinusDstAlphaFactor = F, t.DstColorFactor = H, t.OneMinusDstColorFactor = V, t.SrcAlphaSaturateFactor = k, t.NeverDepth = nt, t.AlwaysDepth = it, t.LessDepth = rt, t.LessEqualDepth = at, t.EqualDepth = ot, t.GreaterEqualDepth = st, t.GreaterDepth = ct, t.NotEqualDepth = ht, t.MultiplyOperation = j, t.MixOperation = lt, t.AddOperation = ut, t.NoToneMapping = pt, t.LinearToneMapping = Mt, t.ReinhardToneMapping = dt, t.Uncharted2ToneMapping = ft, t.CineonToneMapping = mt, t.ACESFilmicToneMapping = gt, t.UVMapping = 300, t.CubeReflectionMapping = vt, t.CubeRefractionMapping = yt, t.EquirectangularReflectionMapping = xt, t.EquirectangularRefractionMapping = bt, t.SphericalReflectionMapping = wt, t.CubeUVReflectionMapping = Et, t.CubeUVRefractionMapping = St, t.RepeatWrapping = Tt, t.ClampToEdgeWrapping = At, t.MirroredRepeatWrapping = Lt, t.NearestFilter = Rt, t.NearestMipMapNearestFilter = Pt, t.NearestMipMapLinearFilter = Ct, t.LinearFilter = Ot, t.LinearMipMapNearestFilter = It, t.LinearMipMapLinearFilter = Dt, t.UnsignedByteType = Nt, t.ByteType = Bt, t.ShortType = zt, t.UnsignedShortType = Ut, t.IntType = Gt, t.UnsignedIntType = Ft, t.FloatType = Ht, t.HalfFloatType = Vt, t.UnsignedShort4444Type = kt, t.UnsignedShort5551Type = jt, t.UnsignedShort565Type = Wt, t.UnsignedInt248Type = qt, t.AlphaFormat = Xt, t.RGBFormat = Yt, t.RGBAFormat = Jt, t.LuminanceFormat = Zt, t.LuminanceAlphaFormat = Qt, t.RGBEFormat = Kt, t.DepthFormat = $t, t.DepthStencilFormat = te, t.RedFormat = ee, t.RGB_S3TC_DXT1_Format = ne, t.RGBA_S3TC_DXT1_Format = ie, t.RGBA_S3TC_DXT3_Format = re, t.RGBA_S3TC_DXT5_Format = ae, t.RGB_PVRTC_4BPPV1_Format = oe, t.RGB_PVRTC_2BPPV1_Format = se, t.RGBA_PVRTC_4BPPV1_Format = ce, t.RGBA_PVRTC_2BPPV1_Format = he, t.RGB_ETC1_Format = le, t.RGBA_ASTC_4x4_Format = ue, t.RGBA_ASTC_5x4_Format = pe, t.RGBA_ASTC_5x5_Format = de, t.RGBA_ASTC_6x5_Format = fe, t.RGBA_ASTC_6x6_Format = me, t.RGBA_ASTC_8x5_Format = ge, t.RGBA_ASTC_8x6_Format = ve, t.RGBA_ASTC_8x8_Format = ye, t.RGBA_ASTC_10x5_Format = xe, t.RGBA_ASTC_10x6_Format = be, t.RGBA_ASTC_10x8_Format = we, t.RGBA_ASTC_10x10_Format = _e, t.RGBA_ASTC_12x10_Format = Me, t.RGBA_ASTC_12x12_Format = Ee, t.LoopOnce = 2200, t.LoopRepeat = 2201, t.LoopPingPong = 2202, t.InterpolateDiscrete = Se, t.InterpolateLinear = Te, t.InterpolateSmooth = 2302, t.ZeroCurvatureEnding = Ae, t.ZeroSlopeEnding = Le, t.WrapAroundEnding = Re, t.TrianglesDrawMode = Pe, t.TriangleStripDrawMode = 1, t.TriangleFanDrawMode = 2, t.LinearEncoding = Ce, t.sRGBEncoding = Oe, t.GammaEncoding = Ie, t.RGBEEncoding = De, t.LogLuvEncoding = 3003, t.RGBM7Encoding = Ne, t.RGBM16Encoding = Be, t.RGBDEncoding = ze, t.BasicDepthPacking = Ue, t.RGBADepthPacking = Ge, t.TangentSpaceNormalMap = Fe, t.ObjectSpaceNormalMap = He, t.Face4 = function (t, e, n, i, r, a, o) { return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new ii(t, e, n, r, a, o) }, t.LineStrip = 0, t.LinePieces = 1, t.MeshFaceMaterial = function (t) { return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t }, t.MultiMaterial = function (t) { return void 0 === t && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, (t.materials = t).clone = function () { return t.slice() }, t }, t.PointCloud = function (t, e) { return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Bs(t, e) }, t.Particle = function (t) { return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Ss(t) }, t.ParticleSystem = function (t, e) { return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Bs(t, e) }, t.PointCloudMaterial = function (t) { return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Ns(t) }, t.ParticleBasicMaterial = function (t) { return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Ns(t) }, t.ParticleSystemMaterial = function (t) { return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Ns(t) }, t.Vertex = function (t, e, n) { return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new qe(t, e, n) }, t.DynamicBufferAttribute = function (t, e) { return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new Ni(t, e).setDynamic(!0) }, t.Int8Attribute = function (t, e) { return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new Bi(t, e) }, t.Uint8Attribute = function (t, e) { return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new zi(t, e) }, t.Uint8ClampedAttribute = function (t, e) { return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Ui(t, e) }, t.Int16Attribute = function (t, e) { return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Gi(t, e) }, t.Uint16Attribute = function (t, e) { return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Fi(t, e) }, t.Int32Attribute = function (t, e) { return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Hi(t, e) }, t.Uint32Attribute = function (t, e) { return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Vi(t, e) }, t.Float32Attribute = function (t, e) { return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new ki(t, e) }, t.Float64Attribute = function (t, e) { return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new ji(t, e) }, t.ClosedSplineCurve3 = xp, t.SplineCurve3 = bp, t.Spline = wp, t.AxisHelper = function (t) { return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new vp(t) }, t.BoundingBoxHelper = function (t, e) { return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new dp(t, e) }, t.EdgesHelper = function (t, e) { return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Is(new Gc(t.geometry), new Cs({ color: void 0 !== e ? e : 16777215 })) }, t.WireframeHelper = function (t, e) { return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Is(new Hs(t.geometry), new Cs({ color: void 0 !== e ? e : 16777215 })) }, t.XHRLoader = function (t) { return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Mh(t) }, t.BinaryTextureLoader = function (t) { return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Th(t) }, t.GeometryUtils = _p, t.Projector = function () { console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function (t, e) { console.warn("THREE.Projector: .projectVector() is now vector.project()."), t.project(e) }, this.unprojectVector = function (t, e) { console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), t.unproject(e) }, this.pickingRay = function () { console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().") } }, t.CanvasRenderer = function () { console.error("THREE.CanvasRenderer has been removed") }, t.JSONLoader = function () { console.error("THREE.JSONLoader has been removed.") }, t.SceneUtils = Mp, t.LensFlare = function () { console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js") }, Object.defineProperty(t, "__esModule", { value: !0 }) });